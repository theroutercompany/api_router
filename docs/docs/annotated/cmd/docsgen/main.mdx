---
title: "cmd/docsgen/main.go"
---

<!--
Generated by `go run ./cmd/docsgen`.
Do not edit this file directly.
Edit commentary in `docs/annotations/cmd/docsgen/main.yaml`.
-->

## Source

- Package: `main`
- File: `cmd/docsgen/main.go`
- GitHub: https://github.com/theroutercompany/api_router/blob/main/cmd/docsgen/main.go

## Overview

**What:**

Generates "Annotated Source" documentation pages for Go files.

Each generated page includes:
- source metadata (package, file path, GitHub link)
- rendered declaration blocks (imports, const/var/type) with line numbers
- per-symbol "What / Why / How" commentary (loaded from YAML annotations)
- per-function statement walkthroughs (including nested blocks and inline closures)

**Why:**

The gateway codebase is small enough to read, but large enough that intent and invariants can be lost during onboarding or refactors.

This generator exists to:
- keep docs synchronized with source (structure/snippets are AST-driven)
- keep intent explanations editable (human text in YAML)
- enable "line-by-line" onboarding without manually maintaining huge MDX files

**How:**

For each input Go file, the generator:
1. Parses the file with `go/parser` into an AST.
2. Extracts declaration blocks and function/method declarations.
3. Loads per-file annotations from `docs/annotations/<path>.yaml`.
4. Renders an MDX page under `docs/docs/annotated/<path>.mdx` with syntax-highlighted Go snippets.
5. Optionally writes/refreshes YAML stubs (`-init-annotations`) to keep the symbol list current.

**Notes:**

The rendered MDX is intentionally treated as build output: edit YAML, re-run docsgen, and commit the regenerated MDX.

MDX authoring gotchas:
- Avoid raw `<` in prose unless it is inside inline code.
- Avoid starting YAML values with backticks (some YAML parsers can be finicky).


## Imports

### `import` block 1

```go title="cmd/docsgen/main.go#L3" showLineNumbers
import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"io/fs"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"gopkg.in/yaml.v3"
)
```


## Types

### `type` block 1

```go title="cmd/docsgen/main.go#L21" showLineNumbers
type annotationText struct {
	What  string `yaml:"what"`
	How   string `yaml:"how"`
	Why   string `yaml:"why"`
	Notes string `yaml:"notes"`
}
```

#### `annotationText`

**What:** Holds the human-authored explanation fields for a symbol or file overview.

**Why:** Separates intent-focused prose from the rendered MDX, making documentation maintainable and reviewable.

**How:** Loaded from YAML and rendered into MDX by `writeWhatHowWhy`.

### `type` block 2

```go title="cmd/docsgen/main.go#L28" showLineNumbers
type fileAnnotations struct {
	File     string                    `yaml:"file"`
	Title    string                    `yaml:"title"`
	Overview annotationText            `yaml:"overview"`
	Symbols  map[string]annotationText `yaml:"symbols"`
}
```

#### `fileAnnotations`

**What:** Parsed representation of a per-source-file annotation YAML document.

**Why:** Allows commentary to be associated with stable symbol IDs independent of line movements or formatting changes.

**How:** Contains a file path, title, overview text, and a map of symbol IDs to `annotationText`.

### `type` block 3

```go title="cmd/docsgen/main.go#L35" showLineNumbers
type symbolEntry struct {
	ID      string
	Heading string
}
```

#### `symbolEntry`

**What:** Minimal representation of a declared symbol used to build the per-block index.

**Why:** Allows the generator to attach YAML commentary using stable IDs without duplicating full AST structures.

**How:** Stores the stable symbol ID and the human-friendly heading used in MDX.

### `type` block 4

```go title="cmd/docsgen/main.go#L40" showLineNumbers
type declBlock struct {
	Label     string
	Kind      string
	StartLine int
	Snippet   string
	Symbols   []symbolEntry
}
```

#### `declBlock`

**What:** Represents one top-level declaration block (imports/const/var/type) for rendering.

**Why:** Go groups declarations; rendering them as blocks preserves source structure and reduces duplication.

**How:** Stores the section label, starting line, original snippet, and derived symbol IDs for the block.

### `type` block 5

```go title="cmd/docsgen/main.go#L48" showLineNumbers
type funcEntry struct {
	ID        string
	Heading   string
	StartLine int
	Snippet   string
	Steps     []walkStep
}
```

#### `funcEntry`

**What:** Represents a single function or method section in the rendered docs.

**Why:** Bundles stable identity, a source snippet, and walkthrough steps so rendering stays straightforward.

**How:** Built by `extractFuncs` and rendered under "Functions and Methods".

### `type` block 6

```go title="cmd/docsgen/main.go#L56" showLineNumbers
type walkStep struct {
	StartLine int
	Code      string
	What      string
	Why       string
	How       string
	Children  []walkStep
}
```

#### `walkStep`

**What:** One node in the statement walkthrough tree (possibly with nested children).

**Why:** Nested control flow needs nested documentation to avoid flattening complex behavior into an unreadable list.

**How:** Captures line number, condensed code preview, What/Why/How strings, and recursively nested steps.

### `type` block 7

```go title="cmd/docsgen/main.go#L65" showLineNumbers
type walkthroughConfig struct {
	Enabled  bool
	MaxDepth int
	MaxSteps int
}
```

#### `walkthroughConfig`

**What:** Controls whether walkthroughs are generated and how deep/large they are.

**Why:** Some functions are large; limits keep docs readable and builds fast while still allowing deeper output when needed.

**How:** Passed through extraction helpers and enforced by `walkStmt`/`extractWalkthroughSteps`.

### `type` block 8

```go title="cmd/docsgen/main.go#L71" showLineNumbers
type fileDoc struct {
	SrcPath        string
	OutPath        string
	AnnotationPath string
	Title          string
	PackageName    string
	Overview       annotationText
	Blocks         []declBlock
	Funcs          []funcEntry
}
```

#### `fileDoc`

**What:** In-memory model of everything needed to render one annotated MDX page.

**Why:** Keeps extraction (AST/source) separate from rendering (MDX) and makes the generator easier to evolve.

**How:** Populated by `generateFile` from parsed AST and annotation YAML, then consumed by `render`.


## Functions and Methods

### `main`

**What:** CLI entrypoint that wires flags and drives per-file generation.

**Why:** Provides a simple "regenerate all docs" workflow while still allowing one-off runs on specific files.

**How:** Parses flags, chooses either the curated core list or explicit file args, and runs `generateFile` while collecting errors.

```go title="cmd/docsgen/main.go#L82" showLineNumbers
func main() {
	var (
		repoRoot      = flag.String("repo", ".", "repo root")
		outDir        = flag.String("out", "docs/docs/annotated", "output directory for generated mdx files")
		annotationDir = flag.String("annotations", "docs/annotations", "directory for per-file annotation yaml")
		githubBase    = flag.String("github-base", "https://github.com/theroutercompany/api_router/blob/main/", "base URL for source links")
		initAnn       = flag.Bool("init-annotations", false, "create/update annotation yaml stubs for the generated files")
		walkthrough   = flag.Bool("walkthrough", true, "include statement-by-statement walkthroughs for functions/methods")
		walkMaxDepth  = flag.Int("walkthrough-max-depth", 6, "maximum nesting depth for walkthrough output")
		walkMaxSteps  = flag.Int("walkthrough-max-steps", 500, "maximum number of walkthrough steps per function/method")
	)
	flag.Parse()

	files := coreFiles()
	if len(flag.Args()) > 0 {
		files = flag.Args()
	}

	var errs []error
	walkCfg := walkthroughConfig{
		Enabled:  *walkthrough,
		MaxDepth: *walkMaxDepth,
		MaxSteps: *walkMaxSteps,
	}
	for _, rel := range files {
		if err := generateFile(*repoRoot, *outDir, *annotationDir, *githubBase, rel, *initAnn, walkCfg); err != nil {
			errs = append(errs, err)
		}
	}
	if len(errs) > 0 {
		for _, err := range errs {
			fmt.Fprintf(os.Stderr, "docsgen error: %v\n", err)
		}
		os.Exit(1)
	}
}
```

#### Walkthrough

The list below documents the statements inside the function body, including nested blocks and inline closures.

- **L83**: `var ( repoRoot = flag.String("repo", ".", "repo root") outDir = flag.String("out", "docs/docs/annotated", "output directory for generated m…`
  - **What:** Declares local names.
  - **Why:** Introduces variables or types used later in the function.
  - **How:** Executes a Go declaration statement inside the function body.
- **L93**: `flag.Parse()`
  - **What:** Calls flag.Parse.
  - **Why:** Performs side effects or delegates work to a helper.
  - **How:** Executes the expression statement.
- **L95**: `files := coreFiles()`
  - **What:** Defines files.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L96**: `if len(flag.Args()) > 0 { files = flag.Args() }`
  - **What:** Branches conditionally.
  - **Why:** Handles different execution paths based on runtime state.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L97**: `files = flag.Args()`
      - **What:** Assigns files.
      - **Why:** Keeps intermediate state available for later steps in the function.
      - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L100**: `var errs []error`
  - **What:** Declares local names.
  - **Why:** Introduces variables or types used later in the function.
  - **How:** Executes a Go declaration statement inside the function body.
- **L101**: `walkCfg := walkthroughConfig{ Enabled: *walkthrough, MaxDepth: *walkMaxDepth, MaxSteps: *walkMaxSteps, }`
  - **What:** Defines walkCfg.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L106**: `for _, rel := range files { if err := generateFile(*repoRoot, *outDir, *annotationDir, *githubBase, rel, *initAnn, walkCfg); err != nil { e…`
  - **What:** Iterates over a collection.
  - **Why:** Processes multiple elements with the same logic.
  - **How:** Executes a `for ... range` loop.
  - **Nested steps:**
    - **L107**: `if err := generateFile(*repoRoot, *outDir, *annotationDir, *githubBase, rel, *initAnn, walkCfg); err != nil { errs = append(errs, err) }`
      - **What:** Branches conditionally.
      - **Why:** Handles different execution paths based on runtime state.
      - **How:** Evaluates the condition and executes the matching branch.
      - **Nested steps:**
        - **L107**: `err := generateFile(*repoRoot, *outDir, *annotationDir, *githubBase, rel, *initAnn, walkCfg)`
          - **What:** Defines err.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L108**: `errs = append(errs, err)`
          - **What:** Assigns errs.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L111**: `if len(errs) > 0 { for _, err := range errs { fmt.Fprintf(os.Stderr, "docsgen error: %v\n", err) } os.Exit(1) }`
  - **What:** Branches conditionally.
  - **Why:** Handles different execution paths based on runtime state.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L112**: `for _, err := range errs { fmt.Fprintf(os.Stderr, "docsgen error: %v\n", err) }`
      - **What:** Iterates over a collection.
      - **Why:** Processes multiple elements with the same logic.
      - **How:** Executes a `for ... range` loop.
      - **Nested steps:**
        - **L113**: `fmt.Fprintf(os.Stderr, "docsgen error: %v\n", err)`
          - **What:** Calls fmt.Fprintf.
          - **Why:** Performs side effects or delegates work to a helper.
          - **How:** Executes the expression statement.
    - **L115**: `os.Exit(1)`
      - **What:** Calls os.Exit.
      - **Why:** Performs side effects or delegates work to a helper.
      - **How:** Executes the expression statement.

### `coreFiles`

**What:** Returns the curated list of Go files that the docs site treats as the "core" reading path.

**Why:** Keeps the annotated source section focused on primary entrypoints and runtime packages rather than every incidental file in the repo.

**How:** Returns a static slice of repo-relative paths; passing explicit CLI args overrides this list.

```go title="cmd/docsgen/main.go#L119" showLineNumbers
func coreFiles() []string {
	return []string{
		"cmd/apigw/main.go",
		"cmd/docsgen/main.go",
		"cmd/gateway/main.go",
		"cmd/openapi/main.go",

		"cmd/shadowdiff/main.go",

		"internal/openapi/service.go",
		"internal/platform/health/health.go",
		"internal/service/placeholder.go",
		"internal/shadowdiff/config.go",
		"internal/shadowdiff/diff.go",
		"internal/shadowdiff/fixture.go",
		"internal/shadowdiff/normalize.go",

		"examples/basic/main.go",

		"pkg/gateway/auth/authenticator.go",
		"pkg/gateway/config/config.go",
		"pkg/gateway/daemon/daemon.go",
		"pkg/gateway/metrics/registry.go",
		"pkg/gateway/problem/problem.go",
		"pkg/gateway/proxy/reverse_proxy.go",
		"pkg/gateway/proxy/testdata/graphql_stream_server.go",
		"pkg/gateway/proxy/testdata/sse_server.go",
		"pkg/gateway/runtime/runtime.go",
		"pkg/gateway/server/middleware/middleware.go",
		"pkg/gateway/server/protocol_metrics.go",
		"pkg/gateway/server/ratelimiter.go",
		"pkg/gateway/server/request_metadata.go",
		"pkg/gateway/server/server.go",
		"pkg/gateway/webhook/handler.go",

		"pkg/log/logger.go",
	}
}
```

#### Walkthrough

The list below documents the statements inside the function body, including nested blocks and inline closures.

- **L120**: `return []string{ "cmd/apigw/main.go", "cmd/docsgen/main.go", "cmd/gateway/main.go", "cmd/openapi/main.go", "cmd/shadowdiff/main.go", "inter…`
  - **What:** Returns from the current function.
  - **Why:** Ends the current execution path and hands control back to the caller.
  - **How:** Executes a `return` statement (possibly returning values).

### `generateFile`

**What:** Generates a single annotated MDX page for one repo-relative Go source file.

**Why:** Keeps the main loop simple and enables ad-hoc generation by passing file paths as CLI arguments.

**How:** Reads and parses source, extracts blocks/functions, optionally initializes annotation stubs, loads annotations, renders MDX, and writes output.

```go title="cmd/docsgen/main.go#L158" showLineNumbers
func generateFile(repoRoot, outDir, annotationDir, githubBase, relSrcPath string, initAnnotations bool, walkCfg walkthroughConfig) error {
	srcPath := filepath.Join(repoRoot, filepath.Clean(relSrcPath))
	srcBytes, err := os.ReadFile(srcPath)
	if err != nil {
		return fmt.Errorf("read %s: %w", relSrcPath, err)
	}

	fset := token.NewFileSet()
	parsed, err := parser.ParseFile(fset, srcPath, srcBytes, parser.ParseComments)
	if err != nil {
		return fmt.Errorf("parse %s: %w", relSrcPath, err)
	}

	annPath := filepath.Join(repoRoot, annotationDir, replaceExt(relSrcPath, ".yaml"))
	blocks := extractBlocks(fset, parsed, srcBytes)
	funcs := extractFuncs(fset, parsed, srcBytes, walkCfg)
	if initAnnotations {
		if err := ensureAnnotationFile(annPath, relSrcPath, blocks, funcs); err != nil {
			return fmt.Errorf("init annotations %s: %w", annPath, err)
		}
	}
	anns, err := loadAnnotations(annPath)
	if err != nil {
		return fmt.Errorf("load annotations %s: %w", annPath, err)
	}

	title := anns.Title
	if strings.TrimSpace(title) == "" {
		title = relSrcPath
	}

	outPath := filepath.Join(repoRoot, outDir, replaceExt(relSrcPath, ".mdx"))
	doc := fileDoc{
		SrcPath:        relSrcPath,
		OutPath:        outPath,
		AnnotationPath: filepath.ToSlash(filepath.Join(annotationDir, replaceExt(relSrcPath, ".yaml"))),
		Title:          title,
		PackageName:    parsed.Name.Name,
		Overview:       anns.Overview,
	}

	doc.Blocks = append(doc.Blocks, blocks...)
	doc.Funcs = append(doc.Funcs, funcs...)

	sort.SliceStable(doc.Blocks, func(i, j int) bool { return doc.Blocks[i].StartLine < doc.Blocks[j].StartLine })
	sort.SliceStable(doc.Funcs, func(i, j int) bool { return doc.Funcs[i].StartLine < doc.Funcs[j].StartLine })

	if err := os.MkdirAll(filepath.Dir(outPath), 0o755); err != nil {
		return fmt.Errorf("mkdir %s: %w", filepath.Dir(outPath), err)
	}

	content := render(doc, anns, githubBase)
	if err := os.WriteFile(outPath, content, 0o644); err != nil {
		return fmt.Errorf("write %s: %w", outPath, err)
	}
	return nil
}
```

#### Walkthrough

The list below documents the statements inside the function body, including nested blocks and inline closures.

- **L159**: `srcPath := filepath.Join(repoRoot, filepath.Clean(relSrcPath))`
  - **What:** Defines srcPath.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L160**: `srcBytes, err := os.ReadFile(srcPath)`
  - **What:** Defines srcBytes, err.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L161**: `if err != nil { return fmt.Errorf("read %s: %w", relSrcPath, err) }`
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L162**: `return fmt.Errorf("read %s: %w", relSrcPath, err)`
      - **What:** Returns from the current function.
      - **Why:** Ends the current execution path and hands control back to the caller.
      - **How:** Executes a `return` statement (possibly returning values).
- **L165**: `fset := token.NewFileSet()`
  - **What:** Defines fset.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L166**: `parsed, err := parser.ParseFile(fset, srcPath, srcBytes, parser.ParseComments)`
  - **What:** Defines parsed, err.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L167**: `if err != nil { return fmt.Errorf("parse %s: %w", relSrcPath, err) }`
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L168**: `return fmt.Errorf("parse %s: %w", relSrcPath, err)`
      - **What:** Returns from the current function.
      - **Why:** Ends the current execution path and hands control back to the caller.
      - **How:** Executes a `return` statement (possibly returning values).
- **L171**: `annPath := filepath.Join(repoRoot, annotationDir, replaceExt(relSrcPath, ".yaml"))`
  - **What:** Defines annPath.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L172**: `blocks := extractBlocks(fset, parsed, srcBytes)`
  - **What:** Defines blocks.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L173**: `funcs := extractFuncs(fset, parsed, srcBytes, walkCfg)`
  - **What:** Defines funcs.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L174**: `if initAnnotations { if err := ensureAnnotationFile(annPath, relSrcPath, blocks, funcs); err != nil { return fmt.Errorf("init annotations %…`
  - **What:** Branches conditionally.
  - **Why:** Handles different execution paths based on runtime state.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L175**: `if err := ensureAnnotationFile(annPath, relSrcPath, blocks, funcs); err != nil { return fmt.Errorf("init annotations %s: %w", annPath, err)…`
      - **What:** Branches conditionally.
      - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
      - **How:** Evaluates the condition and executes the matching branch.
      - **Nested steps:**
        - **L175**: `err := ensureAnnotationFile(annPath, relSrcPath, blocks, funcs)`
          - **What:** Defines err.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L176**: `return fmt.Errorf("init annotations %s: %w", annPath, err)`
          - **What:** Returns from the current function.
          - **Why:** Ends the current execution path and hands control back to the caller.
          - **How:** Executes a `return` statement (possibly returning values).
- **L179**: `anns, err := loadAnnotations(annPath)`
  - **What:** Defines anns, err.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L180**: `if err != nil { return fmt.Errorf("load annotations %s: %w", annPath, err) }`
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L181**: `return fmt.Errorf("load annotations %s: %w", annPath, err)`
      - **What:** Returns from the current function.
      - **Why:** Ends the current execution path and hands control back to the caller.
      - **How:** Executes a `return` statement (possibly returning values).
- **L184**: `title := anns.Title`
  - **What:** Defines title.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L185**: `if strings.TrimSpace(title) == "" { title = relSrcPath }`
  - **What:** Branches conditionally.
  - **Why:** Handles different execution paths based on runtime state.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L186**: `title = relSrcPath`
      - **What:** Assigns title.
      - **Why:** Keeps intermediate state available for later steps in the function.
      - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L189**: `outPath := filepath.Join(repoRoot, outDir, replaceExt(relSrcPath, ".mdx"))`
  - **What:** Defines outPath.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L190**: `doc := fileDoc{ SrcPath: relSrcPath, OutPath: outPath, AnnotationPath: filepath.ToSlash(filepath.Join(annotationDir, replaceExt(relSrcPath,…`
  - **What:** Defines doc.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L199**: `doc.Blocks = append(doc.Blocks, blocks...)`
  - **What:** Assigns doc.Blocks.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L200**: `doc.Funcs = append(doc.Funcs, funcs...)`
  - **What:** Assigns doc.Funcs.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L202**: `sort.SliceStable(doc.Blocks, func(i, j int) bool { return doc.Blocks[i].StartLine < doc.Blocks[j].StartLine })`
  - **What:** Calls sort.SliceStable.
  - **Why:** Performs side effects or delegates work to a helper.
  - **How:** Executes the expression statement.
  - **Nested steps:**
    - **L202**: `func(i, j int) bool { return doc.Blocks[i].StartLine < doc.Blocks[j].StartLine }`
      - **What:** Defines an inline function (closure).
      - **Why:** Encapsulates callback logic and may capture variables from the surrounding scope.
      - **How:** Declares a `func` literal and uses it as a value (for example, as an HTTP handler or callback).
      - **Nested steps:**
        - **L202**: `return doc.Blocks[i].StartLine < doc.Blocks[j].StartLine`
          - **What:** Returns from the current function.
          - **Why:** Ends the current execution path and hands control back to the caller.
          - **How:** Executes a `return` statement (possibly returning values).
- **L203**: `sort.SliceStable(doc.Funcs, func(i, j int) bool { return doc.Funcs[i].StartLine < doc.Funcs[j].StartLine })`
  - **What:** Calls sort.SliceStable.
  - **Why:** Performs side effects or delegates work to a helper.
  - **How:** Executes the expression statement.
  - **Nested steps:**
    - **L203**: `func(i, j int) bool { return doc.Funcs[i].StartLine < doc.Funcs[j].StartLine }`
      - **What:** Defines an inline function (closure).
      - **Why:** Encapsulates callback logic and may capture variables from the surrounding scope.
      - **How:** Declares a `func` literal and uses it as a value (for example, as an HTTP handler or callback).
      - **Nested steps:**
        - **L203**: `return doc.Funcs[i].StartLine < doc.Funcs[j].StartLine`
          - **What:** Returns from the current function.
          - **Why:** Ends the current execution path and hands control back to the caller.
          - **How:** Executes a `return` statement (possibly returning values).
- **L205**: `if err := os.MkdirAll(filepath.Dir(outPath), 0o755); err != nil { return fmt.Errorf("mkdir %s: %w", filepath.Dir(outPath), err) }`
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L205**: `err := os.MkdirAll(filepath.Dir(outPath), 0o755)`
      - **What:** Defines err.
      - **Why:** Keeps intermediate state available for later steps in the function.
      - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
    - **L206**: `return fmt.Errorf("mkdir %s: %w", filepath.Dir(outPath), err)`
      - **What:** Returns from the current function.
      - **Why:** Ends the current execution path and hands control back to the caller.
      - **How:** Executes a `return` statement (possibly returning values).
- **L209**: `content := render(doc, anns, githubBase)`
  - **What:** Defines content.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L210**: `if err := os.WriteFile(outPath, content, 0o644); err != nil { return fmt.Errorf("write %s: %w", outPath, err) }`
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L210**: `err := os.WriteFile(outPath, content, 0o644)`
      - **What:** Defines err.
      - **Why:** Keeps intermediate state available for later steps in the function.
      - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
    - **L211**: `return fmt.Errorf("write %s: %w", outPath, err)`
      - **What:** Returns from the current function.
      - **Why:** Ends the current execution path and hands control back to the caller.
      - **How:** Executes a `return` statement (possibly returning values).
- **L213**: `return nil`
  - **What:** Returns from the current function.
  - **Why:** Ends the current execution path and hands control back to the caller.
  - **How:** Executes a `return` statement (possibly returning values).

### `loadAnnotations`

**What:** Loads per-file annotation YAML into `fileAnnotations`.

**Why:** Human commentary is kept separate from generated output so explanations can be edited without touching the rendered MDX.

**How:** Reads `docs/annotations/<path>.yaml`, unmarshals via `yaml.v3`, and normalizes missing `symbols` to an empty map.

```go title="cmd/docsgen/main.go#L216" showLineNumbers
func loadAnnotations(path string) (fileAnnotations, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		if errors.Is(err, fs.ErrNotExist) {
			return fileAnnotations{Symbols: map[string]annotationText{}}, nil
		}
		return fileAnnotations{}, err
	}
	var anns fileAnnotations
	if err := yaml.Unmarshal(data, &anns); err != nil {
		return fileAnnotations{}, err
	}
	if anns.Symbols == nil {
		anns.Symbols = map[string]annotationText{}
	}
	return anns, nil
}
```

#### Walkthrough

The list below documents the statements inside the function body, including nested blocks and inline closures.

- **L217**: `data, err := os.ReadFile(path)`
  - **What:** Defines data, err.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L218**: `if err != nil { if errors.Is(err, fs.ErrNotExist) { return fileAnnotations{Symbols: map[string]annotationText{}}, nil } return fileAnnotati…`
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L219**: `if errors.Is(err, fs.ErrNotExist) { return fileAnnotations{Symbols: map[string]annotationText{}}, nil }`
      - **What:** Branches conditionally.
      - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
      - **How:** Evaluates the condition and executes the matching branch.
      - **Nested steps:**
        - **L220**: `return fileAnnotations{Symbols: map[string]annotationText{}}, nil`
          - **What:** Returns from the current function.
          - **Why:** Ends the current execution path and hands control back to the caller.
          - **How:** Executes a `return` statement (possibly returning values).
    - **L222**: `return fileAnnotations{}, err`
      - **What:** Returns from the current function.
      - **Why:** Ends the current execution path and hands control back to the caller.
      - **How:** Executes a `return` statement (possibly returning values).
- **L224**: `var anns fileAnnotations`
  - **What:** Declares local names.
  - **Why:** Introduces variables or types used later in the function.
  - **How:** Executes a Go declaration statement inside the function body.
- **L225**: `if err := yaml.Unmarshal(data, &anns); err != nil { return fileAnnotations{}, err }`
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L225**: `err := yaml.Unmarshal(data, &anns)`
      - **What:** Defines err.
      - **Why:** Keeps intermediate state available for later steps in the function.
      - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
    - **L226**: `return fileAnnotations{}, err`
      - **What:** Returns from the current function.
      - **Why:** Ends the current execution path and hands control back to the caller.
      - **How:** Executes a `return` statement (possibly returning values).
- **L228**: `if anns.Symbols == nil { anns.Symbols = map[string]annotationText{} }`
  - **What:** Branches conditionally.
  - **Why:** Handles different execution paths based on runtime state.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L229**: `anns.Symbols = map[string]annotationText{}`
      - **What:** Assigns anns.Symbols.
      - **Why:** Keeps intermediate state available for later steps in the function.
      - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L231**: `return anns, nil`
  - **What:** Returns from the current function.
  - **Why:** Ends the current execution path and hands control back to the caller.
  - **How:** Executes a `return` statement (possibly returning values).

### `replaceExt`

**What:** Replaces the file extension and normalizes paths to forward slashes.

**Why:** The generator needs stable cross-platform paths for both annotation lookups and MDX output routing.

**How:** Uses `filepath.Ext`/`strings.TrimSuffix` and returns a slash-normalized path with the provided extension.

```go title="cmd/docsgen/main.go#L234" showLineNumbers
func replaceExt(path, ext string) string {
	base := strings.TrimSuffix(path, filepath.Ext(path))
	return filepath.ToSlash(base) + ext
}
```

#### Walkthrough

The list below documents the statements inside the function body, including nested blocks and inline closures.

- **L235**: `base := strings.TrimSuffix(path, filepath.Ext(path))`
  - **What:** Defines base.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L236**: `return filepath.ToSlash(base) + ext`
  - **What:** Returns from the current function.
  - **Why:** Ends the current execution path and hands control back to the caller.
  - **How:** Executes a `return` statement (possibly returning values).

### `extractBlocks`

**What:** Extracts top-level declaration blocks from a Go file (imports/const/var/type).

**Why:** The docs show declarations grouped by kind with the original source formatting and line numbers.

**How:** Walks `file.Decls`, filters `*ast.GenDecl`, and converts each supported token kind into a `declBlock`.

```go title="cmd/docsgen/main.go#L239" showLineNumbers
func extractBlocks(fset *token.FileSet, file *ast.File, src []byte) []declBlock {
	var blocks []declBlock
	for _, decl := range file.Decls {
		gen, ok := decl.(*ast.GenDecl)
		if !ok {
			continue
		}
		switch gen.Tok {
		case token.IMPORT:
			blocks = append(blocks, buildGenDeclBlock(fset, gen, src, "Imports", "import"))
		case token.CONST:
			blocks = append(blocks, buildGenDeclBlock(fset, gen, src, "Constants", "const"))
		case token.VAR:
			blocks = append(blocks, buildGenDeclBlock(fset, gen, src, "Variables", "var"))
		case token.TYPE:
			blocks = append(blocks, buildGenDeclBlock(fset, gen, src, "Types", "type"))
		}
	}
	return blocks
}
```

#### Walkthrough

The list below documents the statements inside the function body, including nested blocks and inline closures.

- **L240**: `var blocks []declBlock`
  - **What:** Declares local names.
  - **Why:** Introduces variables or types used later in the function.
  - **How:** Executes a Go declaration statement inside the function body.
- **L241**: `for _, decl := range file.Decls { gen, ok := decl.(*ast.GenDecl) if !ok { continue } switch gen.Tok { case token.IMPORT: blocks = append(bl…`
  - **What:** Iterates over a collection.
  - **Why:** Processes multiple elements with the same logic.
  - **How:** Executes a `for ... range` loop.
  - **Nested steps:**
    - **L242**: `gen, ok := decl.(*ast.GenDecl)`
      - **What:** Defines gen, ok.
      - **Why:** Keeps intermediate state available for later steps in the function.
      - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
    - **L243**: `if !ok { continue }`
      - **What:** Branches conditionally.
      - **Why:** Handles different execution paths based on runtime state.
      - **How:** Evaluates the condition and executes the matching branch.
      - **Nested steps:**
        - **L244**: `continue`
          - **What:** Executes a statement.
          - **Why:** Advances the function logic.
          - **How:** Runs this statement as part of the function body.
    - **L246**: `switch gen.Tok { case token.IMPORT: blocks = append(blocks, buildGenDeclBlock(fset, gen, src, "Imports", "import")) case token.CONST: block…`
      - **What:** Selects a branch from multiple cases.
      - **Why:** Keeps multi-case branching readable and explicit.
      - **How:** Evaluates the switch expression and executes the first matching case.
      - **Nested steps:**
        - **L247**: `case token.IMPORT:`
          - **What:** Selects a switch case.
          - **Why:** Makes multi-branch control flow explicit and readable.
          - **How:** Runs this case body when the switch value matches (or when default is selected).
          - **Nested steps:**
            - **L248**: `blocks = append(blocks, buildGenDeclBlock(fset, gen, src, "Imports", "import"))`
              - **What:** Assigns blocks.
              - **Why:** Keeps intermediate state available for later steps in the function.
              - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L249**: `case token.CONST:`
          - **What:** Selects a switch case.
          - **Why:** Makes multi-branch control flow explicit and readable.
          - **How:** Runs this case body when the switch value matches (or when default is selected).
          - **Nested steps:**
            - **L250**: `blocks = append(blocks, buildGenDeclBlock(fset, gen, src, "Constants", "const"))`
              - **What:** Assigns blocks.
              - **Why:** Keeps intermediate state available for later steps in the function.
              - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L251**: `case token.VAR:`
          - **What:** Selects a switch case.
          - **Why:** Makes multi-branch control flow explicit and readable.
          - **How:** Runs this case body when the switch value matches (or when default is selected).
          - **Nested steps:**
            - **L252**: `blocks = append(blocks, buildGenDeclBlock(fset, gen, src, "Variables", "var"))`
              - **What:** Assigns blocks.
              - **Why:** Keeps intermediate state available for later steps in the function.
              - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L253**: `case token.TYPE:`
          - **What:** Selects a switch case.
          - **Why:** Makes multi-branch control flow explicit and readable.
          - **How:** Runs this case body when the switch value matches (or when default is selected).
          - **Nested steps:**
            - **L254**: `blocks = append(blocks, buildGenDeclBlock(fset, gen, src, "Types", "type"))`
              - **What:** Assigns blocks.
              - **Why:** Keeps intermediate state available for later steps in the function.
              - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L257**: `return blocks`
  - **What:** Returns from the current function.
  - **Why:** Ends the current execution path and hands control back to the caller.
  - **How:** Executes a `return` statement (possibly returning values).

### `buildGenDeclBlock`

**What:** Builds a `declBlock` (snippet + symbol IDs) from a Go `GenDecl` (imports/const/var/type).

**Why:** Declaration blocks are the backbone of the page's symbol index and let readers jump directly to the relevant type/constant/variable.

**How:** Slices the original source for a faithful snippet, then derives stable symbol IDs from `ValueSpec` and `TypeSpec` nodes.

```go title="cmd/docsgen/main.go#L260" showLineNumbers
func buildGenDeclBlock(fset *token.FileSet, gen *ast.GenDecl, src []byte, sectionLabel, kind string) declBlock {
	startLine := fset.Position(gen.Pos()).Line
	snippet := sliceSource(fset, src, gen.Pos(), gen.End())

	var symbols []symbolEntry
	for _, spec := range gen.Specs {
		switch s := spec.(type) {
		case *ast.ValueSpec:
			for _, name := range s.Names {
				id := fmt.Sprintf("%s %s", kind, name.Name)
				symbols = append(symbols, symbolEntry{
					ID:      id,
					Heading: fmt.Sprintf("`%s`", name.Name),
				})
			}
		case *ast.TypeSpec:
			id := fmt.Sprintf("%s %s", kind, s.Name.Name)
			symbols = append(symbols, symbolEntry{
				ID:      id,
				Heading: fmt.Sprintf("`%s`", s.Name.Name),
			})
		}
	}

	return declBlock{
		Label:     sectionLabel,
		Kind:      kind,
		StartLine: startLine,
		Snippet:   snippet,
		Symbols:   symbols,
	}
}
```

#### Walkthrough

The list below documents the statements inside the function body, including nested blocks and inline closures.

- **L261**: `startLine := fset.Position(gen.Pos()).Line`
  - **What:** Defines startLine.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L262**: `snippet := sliceSource(fset, src, gen.Pos(), gen.End())`
  - **What:** Defines snippet.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L264**: `var symbols []symbolEntry`
  - **What:** Declares local names.
  - **Why:** Introduces variables or types used later in the function.
  - **How:** Executes a Go declaration statement inside the function body.
- **L265**: `for _, spec := range gen.Specs { switch s := spec.(type) { case *ast.ValueSpec: for _, name := range s.Names { id := fmt.Sprintf("%s %s", k…`
  - **What:** Iterates over a collection.
  - **Why:** Processes multiple elements with the same logic.
  - **How:** Executes a `for ... range` loop.
  - **Nested steps:**
    - **L266**: `switch s := spec.(type) { case *ast.ValueSpec: for _, name := range s.Names { id := fmt.Sprintf("%s %s", kind, name.Name) symbols = append(…`
      - **What:** Selects a branch based on dynamic type.
      - **Why:** Handles multiple concrete types cleanly.
      - **How:** Executes a type switch statement.
      - **Nested steps:**
        - **L266**: `s := spec.(type)`
          - **What:** Defines s.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L267**: `case *ast.ValueSpec:`
          - **What:** Selects a switch case.
          - **Why:** Makes multi-branch control flow explicit and readable.
          - **How:** Runs this case body when the switch value matches (or when default is selected).
          - **Nested steps:**
            - **L268**: `for _, name := range s.Names { id := fmt.Sprintf("%s %s", kind, name.Name) symbols = append(symbols, symbolEntry{ ID: id, Heading: fmt.Spri…`
              - **What:** Iterates over a collection.
              - **Why:** Processes multiple elements with the same logic.
              - **How:** Executes a `for ... range` loop.
              - **Nested steps:**
                - **L269**: `id := fmt.Sprintf("%s %s", kind, name.Name)`
                  - **What:** Defines id.
                  - **Why:** Keeps intermediate state available for later steps in the function.
                  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
                - **L270**: `` symbols = append(symbols, symbolEntry{ ID: id, Heading: fmt.Sprintf("`%s`", name.Name), }) ``
                  - **What:** Assigns symbols.
                  - **Why:** Keeps intermediate state available for later steps in the function.
                  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L275**: `case *ast.TypeSpec:`
          - **What:** Selects a switch case.
          - **Why:** Makes multi-branch control flow explicit and readable.
          - **How:** Runs this case body when the switch value matches (or when default is selected).
          - **Nested steps:**
            - **L276**: `id := fmt.Sprintf("%s %s", kind, s.Name.Name)`
              - **What:** Defines id.
              - **Why:** Keeps intermediate state available for later steps in the function.
              - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
            - **L277**: `` symbols = append(symbols, symbolEntry{ ID: id, Heading: fmt.Sprintf("`%s`", s.Name.Name), }) ``
              - **What:** Assigns symbols.
              - **Why:** Keeps intermediate state available for later steps in the function.
              - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L284**: `return declBlock{ Label: sectionLabel, Kind: kind, StartLine: startLine, Snippet: snippet, Symbols: symbols, }`
  - **What:** Returns from the current function.
  - **Why:** Ends the current execution path and hands control back to the caller.
  - **How:** Executes a `return` statement (possibly returning values).

### `extractFuncs`

**What:** Extracts top-level functions and methods into `funcEntry` records.

**Why:** Functions/methods are the main behavioral units readers look for when onboarding or debugging.

**How:** Iterates `*ast.FuncDecl` nodes, computes stable IDs for functions vs methods, slices source snippets, and optionally attaches walkthrough steps.

```go title="cmd/docsgen/main.go#L293" showLineNumbers
func extractFuncs(fset *token.FileSet, file *ast.File, src []byte, walkCfg walkthroughConfig) []funcEntry {
	var entries []funcEntry
	for _, decl := range file.Decls {
		fn, ok := decl.(*ast.FuncDecl)
		if !ok {
			continue
		}

		startLine := fset.Position(fn.Pos()).Line
		snippet := sliceSource(fset, src, fn.Pos(), fn.End())
		steps := []walkStep(nil)
		if walkCfg.Enabled {
			steps = extractWalkthroughSteps(fset, src, fn, walkCfg)
		}

		id := fmt.Sprintf("func %s", fn.Name.Name)
		heading := fmt.Sprintf("`%s`", fn.Name.Name)
		if fn.Recv != nil && len(fn.Recv.List) > 0 {
			recv := receiverTypeString(fset, fn.Recv.List[0].Type)
			id = fmt.Sprintf("method (%s).%s", recv, fn.Name.Name)
			heading = fmt.Sprintf("`(%s).%s`", recv, fn.Name.Name)
		}

		entries = append(entries, funcEntry{
			ID:        id,
			Heading:   heading,
			StartLine: startLine,
			Snippet:   snippet,
			Steps:     steps,
		})
	}
	return entries
}
```

#### Walkthrough

The list below documents the statements inside the function body, including nested blocks and inline closures.

- **L294**: `var entries []funcEntry`
  - **What:** Declares local names.
  - **Why:** Introduces variables or types used later in the function.
  - **How:** Executes a Go declaration statement inside the function body.
- **L295**: `for _, decl := range file.Decls { fn, ok := decl.(*ast.FuncDecl) if !ok { continue } startLine := fset.Position(fn.Pos()).Line snippet := s…`
  - **What:** Iterates over a collection.
  - **Why:** Processes multiple elements with the same logic.
  - **How:** Executes a `for ... range` loop.
  - **Nested steps:**
    - **L296**: `fn, ok := decl.(*ast.FuncDecl)`
      - **What:** Defines fn, ok.
      - **Why:** Keeps intermediate state available for later steps in the function.
      - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
    - **L297**: `if !ok { continue }`
      - **What:** Branches conditionally.
      - **Why:** Handles different execution paths based on runtime state.
      - **How:** Evaluates the condition and executes the matching branch.
      - **Nested steps:**
        - **L298**: `continue`
          - **What:** Executes a statement.
          - **Why:** Advances the function logic.
          - **How:** Runs this statement as part of the function body.
    - **L301**: `startLine := fset.Position(fn.Pos()).Line`
      - **What:** Defines startLine.
      - **Why:** Keeps intermediate state available for later steps in the function.
      - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
    - **L302**: `snippet := sliceSource(fset, src, fn.Pos(), fn.End())`
      - **What:** Defines snippet.
      - **Why:** Keeps intermediate state available for later steps in the function.
      - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
    - **L303**: `steps := []walkStep(nil)`
      - **What:** Defines steps.
      - **Why:** Keeps intermediate state available for later steps in the function.
      - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
    - **L304**: `if walkCfg.Enabled { steps = extractWalkthroughSteps(fset, src, fn, walkCfg) }`
      - **What:** Branches conditionally.
      - **Why:** Handles different execution paths based on runtime state.
      - **How:** Evaluates the condition and executes the matching branch.
      - **Nested steps:**
        - **L305**: `steps = extractWalkthroughSteps(fset, src, fn, walkCfg)`
          - **What:** Assigns steps.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
    - **L308**: `id := fmt.Sprintf("func %s", fn.Name.Name)`
      - **What:** Defines id.
      - **Why:** Keeps intermediate state available for later steps in the function.
      - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
    - **L309**: `` heading := fmt.Sprintf("`%s`", fn.Name.Name) ``
      - **What:** Defines heading.
      - **Why:** Keeps intermediate state available for later steps in the function.
      - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
    - **L310**: `if fn.Recv != nil && len(fn.Recv.List) > 0 { recv := receiverTypeString(fset, fn.Recv.List[0].Type) id = fmt.Sprintf("method (%s).%s", recv…`
      - **What:** Branches conditionally.
      - **Why:** Handles different execution paths based on runtime state.
      - **How:** Evaluates the condition and executes the matching branch.
      - **Nested steps:**
        - **L311**: `recv := receiverTypeString(fset, fn.Recv.List[0].Type)`
          - **What:** Defines recv.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L312**: `id = fmt.Sprintf("method (%s).%s", recv, fn.Name.Name)`
          - **What:** Assigns id.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L313**: `` heading = fmt.Sprintf("`(%s).%s`", recv, fn.Name.Name) ``
          - **What:** Assigns heading.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
    - **L316**: `entries = append(entries, funcEntry{ ID: id, Heading: heading, StartLine: startLine, Snippet: snippet, Steps: steps, })`
      - **What:** Assigns entries.
      - **Why:** Keeps intermediate state available for later steps in the function.
      - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L324**: `return entries`
  - **What:** Returns from the current function.
  - **Why:** Ends the current execution path and hands control back to the caller.
  - **How:** Executes a `return` statement (possibly returning values).

### `extractWalkthroughSteps`

**What:** Produces a statement-by-statement walkthrough for a function body.

**Why:** Implements the "line-by-line" requirement by explaining what each statement does and how it fits into the function logic.

**How:** Walks the function's top-level statements with `walkStmt`, respecting `MaxSteps` and emitting a truncation sentinel when exceeded.

```go title="cmd/docsgen/main.go#L327" showLineNumbers
func extractWalkthroughSteps(fset *token.FileSet, src []byte, fn *ast.FuncDecl, cfg walkthroughConfig) []walkStep {
	if fn == nil || fn.Body == nil || len(fn.Body.List) == 0 || cfg.MaxSteps <= 0 {
		return nil
	}

	steps := make([]walkStep, 0, len(fn.Body.List))
	count := 0
	for _, stmt := range fn.Body.List {
		if stmt == nil || count >= cfg.MaxSteps {
			break
		}
		step, ok := walkStmt(fset, src, stmt, 0, cfg, &count)
		if ok {
			steps = append(steps, step)
		}
	}
	if count >= cfg.MaxSteps {
		steps = append(steps, walkStep{
			StartLine: fset.Position(fn.End()).Line,
			Code:      "(walkthrough truncated)",
			What:      "Walkthrough output was truncated.",
			Why:       "Keeps pages readable and avoids generating excessively large MDX output by default.",
			How:       "Re-run docsgen with a higher `-walkthrough-max-steps` value to include more steps.",
		})
	}
	return steps
}
```

#### Walkthrough

The list below documents the statements inside the function body, including nested blocks and inline closures.

- **L328**: `if fn == nil || fn.Body == nil || len(fn.Body.List) == 0 || cfg.MaxSteps <= 0 { return nil }`
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L329**: `return nil`
      - **What:** Returns from the current function.
      - **Why:** Ends the current execution path and hands control back to the caller.
      - **How:** Executes a `return` statement (possibly returning values).
- **L332**: `steps := make([]walkStep, 0, len(fn.Body.List))`
  - **What:** Defines steps.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L333**: `count := 0`
  - **What:** Defines count.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L334**: `for _, stmt := range fn.Body.List { if stmt == nil || count >= cfg.MaxSteps { break } step, ok := walkStmt(fset, src, stmt, 0, cfg, &count)…`
  - **What:** Iterates over a collection.
  - **Why:** Processes multiple elements with the same logic.
  - **How:** Executes a `for ... range` loop.
  - **Nested steps:**
    - **L335**: `if stmt == nil || count >= cfg.MaxSteps { break }`
      - **What:** Branches conditionally.
      - **Why:** Handles different execution paths based on runtime state.
      - **How:** Evaluates the condition and executes the matching branch.
      - **Nested steps:**
        - **L336**: `break`
          - **What:** Executes a statement.
          - **Why:** Advances the function logic.
          - **How:** Runs this statement as part of the function body.
    - **L338**: `step, ok := walkStmt(fset, src, stmt, 0, cfg, &count)`
      - **What:** Defines step, ok.
      - **Why:** Keeps intermediate state available for later steps in the function.
      - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
    - **L339**: `if ok { steps = append(steps, step) }`
      - **What:** Branches conditionally.
      - **Why:** Handles different execution paths based on runtime state.
      - **How:** Evaluates the condition and executes the matching branch.
      - **Nested steps:**
        - **L340**: `steps = append(steps, step)`
          - **What:** Assigns steps.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L343**: `if count >= cfg.MaxSteps { steps = append(steps, walkStep{ StartLine: fset.Position(fn.End()).Line, Code: "(walkthrough truncated)", What: …`
  - **What:** Branches conditionally.
  - **Why:** Handles different execution paths based on runtime state.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L344**: `steps = append(steps, walkStep{ StartLine: fset.Position(fn.End()).Line, Code: "(walkthrough truncated)", What: "Walkthrough output was tru…`
      - **What:** Assigns steps.
      - **Why:** Keeps intermediate state available for later steps in the function.
      - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L352**: `return steps`
  - **What:** Returns from the current function.
  - **Why:** Ends the current execution path and hands control back to the caller.
  - **How:** Executes a `return` statement (possibly returning values).

### `walkStmt`

**What:** Converts a statement into a walkthrough step and recursively collects nested steps.

**Why:** Implements structured, nested walkthrough output that matches how humans mentally model control flow.

**How:** Describes the statement, increments a shared step counter, and then dives into child blocks/branches (if/for/switch/select) and embedded closures.

```go title="cmd/docsgen/main.go#L355" showLineNumbers
func walkStmt(fset *token.FileSet, src []byte, stmt ast.Stmt, depth int, cfg walkthroughConfig, count *int) (walkStep, bool) {
	if stmt == nil || count == nil || *count >= cfg.MaxSteps {
		return walkStep{}, false
	}

	startLine := fset.Position(stmt.Pos()).Line
	code := condenseSnippet(sliceSource(fset, src, stmt.Pos(), stmt.End()))
	what, why, how := describeStmt(fset, stmt)
	step := walkStep{
		StartLine: startLine,
		Code:      code,
		What:      what,
		Why:       why,
		How:       how,
	}
	*count++
	if *count >= cfg.MaxSteps || depth >= cfg.MaxDepth {
		return step, true
	}

	appendChild := func(child walkStep) {
		if *count >= cfg.MaxSteps {
			return
		}
		step.Children = append(step.Children, child)
	}
	appendChildren := func(children []walkStep) {
		for _, child := range children {
			if *count >= cfg.MaxSteps {
				return
			}
			step.Children = append(step.Children, child)
		}
	}

	switch s := stmt.(type) {
	case *ast.BlockStmt:
		appendChildren(walkStmtList(fset, src, s.List, depth+1, cfg, count))
		return step, true

	case *ast.LabeledStmt:
		if s.Stmt != nil {
			if child, ok := walkStmt(fset, src, s.Stmt, depth+1, cfg, count); ok {
				appendChild(child)
			}
		}
		return step, true

	case *ast.IfStmt:
		if s.Init != nil {
			if child, ok := walkStmt(fset, src, s.Init, depth+1, cfg, count); ok {
				appendChild(child)
			}
		}
		appendChildren(walkStmtList(fset, src, s.Body.List, depth+1, cfg, count))
		switch elseNode := s.Else.(type) {
		case *ast.BlockStmt:
			appendChildren(walkStmtList(fset, src, elseNode.List, depth+1, cfg, count))
		case ast.Stmt:
			if child, ok := walkStmt(fset, src, elseNode, depth+1, cfg, count); ok {
				appendChild(child)
			}
		}
		appendChildren(walkFuncLitsFromExpr(fset, src, s.Cond, depth+1, cfg, count))
		return step, true

	case *ast.ForStmt:
		if s.Init != nil {
			if child, ok := walkStmt(fset, src, s.Init, depth+1, cfg, count); ok {
				appendChild(child)
			}
		}
		if s.Post != nil {
			if child, ok := walkStmt(fset, src, s.Post, depth+1, cfg, count); ok {
				appendChild(child)
			}
		}
		appendChildren(walkStmtList(fset, src, s.Body.List, depth+1, cfg, count))
		appendChildren(walkFuncLitsFromExpr(fset, src, s.Cond, depth+1, cfg, count))
		return step, true

	case *ast.RangeStmt:
		appendChildren(walkStmtList(fset, src, s.Body.List, depth+1, cfg, count))
		appendChildren(walkFuncLitsFromExpr(fset, src, s.X, depth+1, cfg, count))
		return step, true

	case *ast.SwitchStmt:
		if s.Init != nil {
			if child, ok := walkStmt(fset, src, s.Init, depth+1, cfg, count); ok {
				appendChild(child)
			}
		}
		appendChildren(walkFuncLitsFromExpr(fset, src, s.Tag, depth+1, cfg, count))
		for _, raw := range s.Body.List {
			cc, ok := raw.(*ast.CaseClause)
			if !ok || *count >= cfg.MaxSteps {
				break
			}
			caseStep, ok := walkCaseClause(fset, src, cc, depth+1, cfg, count)
			if ok {
				appendChild(caseStep)
			}
		}
		return step, true

	case *ast.TypeSwitchStmt:
		if s.Init != nil {
			if child, ok := walkStmt(fset, src, s.Init, depth+1, cfg, count); ok {
				appendChild(child)
			}
		}
		if s.Assign != nil {
			if child, ok := walkStmt(fset, src, s.Assign, depth+1, cfg, count); ok {
				appendChild(child)
			}
		}
		for _, raw := range s.Body.List {
			cc, ok := raw.(*ast.CaseClause)
			if !ok || *count >= cfg.MaxSteps {
				break
			}
			caseStep, ok := walkCaseClause(fset, src, cc, depth+1, cfg, count)
			if ok {
				appendChild(caseStep)
			}
		}
		return step, true

	case *ast.SelectStmt:
		for _, raw := range s.Body.List {
			cl, ok := raw.(*ast.CommClause)
			if !ok || *count >= cfg.MaxSteps {
				break
			}
			caseStep, ok := walkCommClause(fset, src, cl, depth+1, cfg, count)
			if ok {
				appendChild(caseStep)
			}
		}
		return step, true

	case *ast.AssignStmt:
		for _, expr := range s.Rhs {
			appendChildren(walkFuncLitsFromExpr(fset, src, expr, depth+1, cfg, count))
		}
		return step, true

	case *ast.ReturnStmt:
		for _, expr := range s.Results {
			appendChildren(walkFuncLitsFromExpr(fset, src, expr, depth+1, cfg, count))
		}
		return step, true

	case *ast.ExprStmt:
		appendChildren(walkFuncLitsFromExpr(fset, src, s.X, depth+1, cfg, count))
		return step, true

	case *ast.GoStmt:
		if s.Call != nil {
			appendChildren(walkFuncLitsFromExpr(fset, src, s.Call, depth+1, cfg, count))
		}
		return step, true

	case *ast.DeferStmt:
		if s.Call != nil {
			appendChildren(walkFuncLitsFromExpr(fset, src, s.Call, depth+1, cfg, count))
		}
		return step, true

	default:
		return step, true
	}
}
```

#### Walkthrough

The list below documents the statements inside the function body, including nested blocks and inline closures.

- **L356**: `if stmt == nil || count == nil || *count >= cfg.MaxSteps { return walkStep{}, false }`
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L357**: `return walkStep{}, false`
      - **What:** Returns from the current function.
      - **Why:** Ends the current execution path and hands control back to the caller.
      - **How:** Executes a `return` statement (possibly returning values).
- **L360**: `startLine := fset.Position(stmt.Pos()).Line`
  - **What:** Defines startLine.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L361**: `code := condenseSnippet(sliceSource(fset, src, stmt.Pos(), stmt.End()))`
  - **What:** Defines code.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L362**: `what, why, how := describeStmt(fset, stmt)`
  - **What:** Defines what, why, how.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L363**: `step := walkStep{ StartLine: startLine, Code: code, What: what, Why: why, How: how, }`
  - **What:** Defines step.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L370**: `*count++`
  - **What:** Updates a counter.
  - **Why:** Maintains an index or tally used by subsequent logic.
  - **How:** Executes an increment/decrement statement.
- **L371**: `if *count >= cfg.MaxSteps || depth >= cfg.MaxDepth { return step, true }`
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L372**: `return step, true`
      - **What:** Returns from the current function.
      - **Why:** Ends the current execution path and hands control back to the caller.
      - **How:** Executes a `return` statement (possibly returning values).
- **L375**: `appendChild := func(child walkStep) { if *count >= cfg.MaxSteps { return } step.Children = append(step.Children, child) }`
  - **What:** Defines appendChild.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
  - **Nested steps:**
    - **L375**: `func(child walkStep) { if *count >= cfg.MaxSteps { return } step.Children = append(step.Children, child) }`
      - **What:** Defines an inline function (closure).
      - **Why:** Encapsulates callback logic and may capture variables from the surrounding scope.
      - **How:** Declares a `func` literal and uses it as a value (for example, as an HTTP handler or callback).
      - **Nested steps:**
        - **L376**: `if *count >= cfg.MaxSteps { return }`
          - **What:** Branches conditionally.
          - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
          - **How:** Evaluates the condition and executes the matching branch.
          - **Nested steps:**
            - **L377**: `return`
              - **What:** Returns from the current function.
              - **Why:** Ends the current execution path and hands control back to the caller.
              - **How:** Executes a `return` statement (possibly returning values).
        - **L379**: `step.Children = append(step.Children, child)`
          - **What:** Assigns step.Children.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L381**: `appendChildren := func(children []walkStep) { for _, child := range children { if *count >= cfg.MaxSteps { return } step.Children = append(…`
  - **What:** Defines appendChildren.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
  - **Nested steps:**
    - **L381**: `func(children []walkStep) { for _, child := range children { if *count >= cfg.MaxSteps { return } step.Children = append(step.Children, chi…`
      - **What:** Defines an inline function (closure).
      - **Why:** Encapsulates callback logic and may capture variables from the surrounding scope.
      - **How:** Declares a `func` literal and uses it as a value (for example, as an HTTP handler or callback).
      - **Nested steps:**
        - **L382**: `for _, child := range children { if *count >= cfg.MaxSteps { return } step.Children = append(step.Children, child) }`
          - **What:** Iterates over a collection.
          - **Why:** Processes multiple elements with the same logic.
          - **How:** Executes a `for ... range` loop.
          - **Nested steps:**
            - **L383**: `if *count >= cfg.MaxSteps { return }`
              - **What:** Branches conditionally.
              - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
              - **How:** Evaluates the condition and executes the matching branch.
              - **Nested steps:**
                - **L384**: `return`
                  - **What:** Returns from the current function.
                  - **Why:** Ends the current execution path and hands control back to the caller.
                  - **How:** Executes a `return` statement (possibly returning values).
            - **L386**: `step.Children = append(step.Children, child)`
              - **What:** Assigns step.Children.
              - **Why:** Keeps intermediate state available for later steps in the function.
              - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L390**: `switch s := stmt.(type) { case *ast.BlockStmt: appendChildren(walkStmtList(fset, src, s.List, depth+1, cfg, count)) return step, true case …`
  - **What:** Selects a branch based on dynamic type.
  - **Why:** Handles multiple concrete types cleanly.
  - **How:** Executes a type switch statement.
  - **Nested steps:**
    - **L390**: `s := stmt.(type)`
      - **What:** Defines s.
      - **Why:** Keeps intermediate state available for later steps in the function.
      - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
    - **L391**: `case *ast.BlockStmt:`
      - **What:** Selects a switch case.
      - **Why:** Makes multi-branch control flow explicit and readable.
      - **How:** Runs this case body when the switch value matches (or when default is selected).
      - **Nested steps:**
        - **L392**: `appendChildren(walkStmtList(fset, src, s.List, depth+1, cfg, count))`
          - **What:** Calls appendChildren.
          - **Why:** Performs side effects or delegates work to a helper.
          - **How:** Executes the expression statement.
        - **L393**: `return step, true`
          - **What:** Returns from the current function.
          - **Why:** Ends the current execution path and hands control back to the caller.
          - **How:** Executes a `return` statement (possibly returning values).
    - **L395**: `case *ast.LabeledStmt:`
      - **What:** Selects a switch case.
      - **Why:** Makes multi-branch control flow explicit and readable.
      - **How:** Runs this case body when the switch value matches (or when default is selected).
      - **Nested steps:**
        - **L396**: `if s.Stmt != nil { if child, ok := walkStmt(fset, src, s.Stmt, depth+1, cfg, count); ok { appendChild(child) } }`
          - **What:** Branches conditionally.
          - **Why:** Handles different execution paths based on runtime state.
          - **How:** Evaluates the condition and executes the matching branch.
          - **Nested steps:**
            - **L397**: `if child, ok := walkStmt(fset, src, s.Stmt, depth+1, cfg, count); ok { appendChild(child) }`
              - **What:** Branches conditionally.
              - **Why:** Handles different execution paths based on runtime state.
              - **How:** Evaluates the condition and executes the matching branch.
              - **Nested steps:**
                - **L397**: `child, ok := walkStmt(fset, src, s.Stmt, depth+1, cfg, count)`
                  - **What:** Defines child, ok.
                  - **Why:** Keeps intermediate state available for later steps in the function.
                  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
                - **L398**: `appendChild(child)`
                  - **What:** Calls appendChild.
                  - **Why:** Performs side effects or delegates work to a helper.
                  - **How:** Executes the expression statement.
        - **L401**: `return step, true`
          - **What:** Returns from the current function.
          - **Why:** Ends the current execution path and hands control back to the caller.
          - **How:** Executes a `return` statement (possibly returning values).
    - **L403**: `case *ast.IfStmt:`
      - **What:** Selects a switch case.
      - **Why:** Makes multi-branch control flow explicit and readable.
      - **How:** Runs this case body when the switch value matches (or when default is selected).
      - **Nested steps:**
        - **L404**: `if s.Init != nil { if child, ok := walkStmt(fset, src, s.Init, depth+1, cfg, count); ok { appendChild(child) } }`
          - **What:** Branches conditionally.
          - **Why:** Handles different execution paths based on runtime state.
          - **How:** Evaluates the condition and executes the matching branch.
          - **Nested steps:**
            - **L405**: `if child, ok := walkStmt(fset, src, s.Init, depth+1, cfg, count); ok { appendChild(child) }`
              - **What:** Branches conditionally.
              - **Why:** Handles different execution paths based on runtime state.
              - **How:** Evaluates the condition and executes the matching branch.
              - **Nested steps:**
                - **L405**: `child, ok := walkStmt(fset, src, s.Init, depth+1, cfg, count)`
                  - **What:** Defines child, ok.
                  - **Why:** Keeps intermediate state available for later steps in the function.
                  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
                - **L406**: `appendChild(child)`
                  - **What:** Calls appendChild.
                  - **Why:** Performs side effects or delegates work to a helper.
                  - **How:** Executes the expression statement.
        - **L409**: `appendChildren(walkStmtList(fset, src, s.Body.List, depth+1, cfg, count))`
          - **What:** Calls appendChildren.
          - **Why:** Performs side effects or delegates work to a helper.
          - **How:** Executes the expression statement.
        - **L410**: `switch elseNode := s.Else.(type) { case *ast.BlockStmt: appendChildren(walkStmtList(fset, src, elseNode.List, depth+1, cfg, count)) case as…`
          - **What:** Selects a branch based on dynamic type.
          - **Why:** Handles multiple concrete types cleanly.
          - **How:** Executes a type switch statement.
          - **Nested steps:**
            - **L410**: `elseNode := s.Else.(type)`
              - **What:** Defines elseNode.
              - **Why:** Keeps intermediate state available for later steps in the function.
              - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
            - **L411**: `case *ast.BlockStmt:`
              - **What:** Selects a switch case.
              - **Why:** Makes multi-branch control flow explicit and readable.
              - **How:** Runs this case body when the switch value matches (or when default is selected).
              - **Nested steps:**
                - **L412**: `appendChildren(walkStmtList(fset, src, elseNode.List, depth+1, cfg, count))`
                  - **What:** Calls appendChildren.
                  - **Why:** Performs side effects or delegates work to a helper.
                  - **How:** Executes the expression statement.
            - **L413**: `case ast.Stmt:`
              - **What:** Selects a switch case.
              - **Why:** Makes multi-branch control flow explicit and readable.
              - **How:** Runs this case body when the switch value matches (or when default is selected).
              - **Nested steps:**
                - **L414**: `if child, ok := walkStmt(fset, src, elseNode, depth+1, cfg, count); ok { appendChild(child) }`
                  - **What:** Branches conditionally.
                  - **Why:** Handles different execution paths based on runtime state.
                  - **How:** Evaluates the condition and executes the matching branch.
                  - **Nested steps:**
                    - **L414**: `child, ok := walkStmt(fset, src, elseNode, depth+1, cfg, count)`
                      - **What:** Defines child, ok.
                      - **Why:** Keeps intermediate state available for later steps in the function.
                      - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
                    - **L415**: `appendChild(child)`
                      - **What:** Calls appendChild.
                      - **Why:** Performs side effects or delegates work to a helper.
                      - **How:** Executes the expression statement.
        - **L418**: `appendChildren(walkFuncLitsFromExpr(fset, src, s.Cond, depth+1, cfg, count))`
          - **What:** Calls appendChildren.
          - **Why:** Performs side effects or delegates work to a helper.
          - **How:** Executes the expression statement.
        - **L419**: `return step, true`
          - **What:** Returns from the current function.
          - **Why:** Ends the current execution path and hands control back to the caller.
          - **How:** Executes a `return` statement (possibly returning values).
    - **L421**: `case *ast.ForStmt:`
      - **What:** Selects a switch case.
      - **Why:** Makes multi-branch control flow explicit and readable.
      - **How:** Runs this case body when the switch value matches (or when default is selected).
      - **Nested steps:**
        - **L422**: `if s.Init != nil { if child, ok := walkStmt(fset, src, s.Init, depth+1, cfg, count); ok { appendChild(child) } }`
          - **What:** Branches conditionally.
          - **Why:** Handles different execution paths based on runtime state.
          - **How:** Evaluates the condition and executes the matching branch.
          - **Nested steps:**
            - **L423**: `if child, ok := walkStmt(fset, src, s.Init, depth+1, cfg, count); ok { appendChild(child) }`
              - **What:** Branches conditionally.
              - **Why:** Handles different execution paths based on runtime state.
              - **How:** Evaluates the condition and executes the matching branch.
              - **Nested steps:**
                - **L423**: `child, ok := walkStmt(fset, src, s.Init, depth+1, cfg, count)`
                  - **What:** Defines child, ok.
                  - **Why:** Keeps intermediate state available for later steps in the function.
                  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
                - **L424**: `appendChild(child)`
                  - **What:** Calls appendChild.
                  - **Why:** Performs side effects or delegates work to a helper.
                  - **How:** Executes the expression statement.
        - **L427**: `if s.Post != nil { if child, ok := walkStmt(fset, src, s.Post, depth+1, cfg, count); ok { appendChild(child) } }`
          - **What:** Branches conditionally.
          - **Why:** Handles different execution paths based on runtime state.
          - **How:** Evaluates the condition and executes the matching branch.
          - **Nested steps:**
            - **L428**: `if child, ok := walkStmt(fset, src, s.Post, depth+1, cfg, count); ok { appendChild(child) }`
              - **What:** Branches conditionally.
              - **Why:** Handles different execution paths based on runtime state.
              - **How:** Evaluates the condition and executes the matching branch.
              - **Nested steps:**
                - **L428**: `child, ok := walkStmt(fset, src, s.Post, depth+1, cfg, count)`
                  - **What:** Defines child, ok.
                  - **Why:** Keeps intermediate state available for later steps in the function.
                  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
                - **L429**: `appendChild(child)`
                  - **What:** Calls appendChild.
                  - **Why:** Performs side effects or delegates work to a helper.
                  - **How:** Executes the expression statement.
        - **L432**: `appendChildren(walkStmtList(fset, src, s.Body.List, depth+1, cfg, count))`
          - **What:** Calls appendChildren.
          - **Why:** Performs side effects or delegates work to a helper.
          - **How:** Executes the expression statement.
        - **L433**: `appendChildren(walkFuncLitsFromExpr(fset, src, s.Cond, depth+1, cfg, count))`
          - **What:** Calls appendChildren.
          - **Why:** Performs side effects or delegates work to a helper.
          - **How:** Executes the expression statement.
        - **L434**: `return step, true`
          - **What:** Returns from the current function.
          - **Why:** Ends the current execution path and hands control back to the caller.
          - **How:** Executes a `return` statement (possibly returning values).
    - **L436**: `case *ast.RangeStmt:`
      - **What:** Selects a switch case.
      - **Why:** Makes multi-branch control flow explicit and readable.
      - **How:** Runs this case body when the switch value matches (or when default is selected).
      - **Nested steps:**
        - **L437**: `appendChildren(walkStmtList(fset, src, s.Body.List, depth+1, cfg, count))`
          - **What:** Calls appendChildren.
          - **Why:** Performs side effects or delegates work to a helper.
          - **How:** Executes the expression statement.
        - **L438**: `appendChildren(walkFuncLitsFromExpr(fset, src, s.X, depth+1, cfg, count))`
          - **What:** Calls appendChildren.
          - **Why:** Performs side effects or delegates work to a helper.
          - **How:** Executes the expression statement.
        - **L439**: `return step, true`
          - **What:** Returns from the current function.
          - **Why:** Ends the current execution path and hands control back to the caller.
          - **How:** Executes a `return` statement (possibly returning values).
    - **L441**: `case *ast.SwitchStmt:`
      - **What:** Selects a switch case.
      - **Why:** Makes multi-branch control flow explicit and readable.
      - **How:** Runs this case body when the switch value matches (or when default is selected).
      - **Nested steps:**
        - **L442**: `if s.Init != nil { if child, ok := walkStmt(fset, src, s.Init, depth+1, cfg, count); ok { appendChild(child) } }`
          - **What:** Branches conditionally.
          - **Why:** Handles different execution paths based on runtime state.
          - **How:** Evaluates the condition and executes the matching branch.
          - **Nested steps:**
            - **L443**: `if child, ok := walkStmt(fset, src, s.Init, depth+1, cfg, count); ok { appendChild(child) }`
              - **What:** Branches conditionally.
              - **Why:** Handles different execution paths based on runtime state.
              - **How:** Evaluates the condition and executes the matching branch.
              - **Nested steps:**
                - **L443**: `child, ok := walkStmt(fset, src, s.Init, depth+1, cfg, count)`
                  - **What:** Defines child, ok.
                  - **Why:** Keeps intermediate state available for later steps in the function.
                  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
                - **L444**: `appendChild(child)`
                  - **What:** Calls appendChild.
                  - **Why:** Performs side effects or delegates work to a helper.
                  - **How:** Executes the expression statement.
        - **L447**: `appendChildren(walkFuncLitsFromExpr(fset, src, s.Tag, depth+1, cfg, count))`
          - **What:** Calls appendChildren.
          - **Why:** Performs side effects or delegates work to a helper.
          - **How:** Executes the expression statement.
        - **L448**: `for _, raw := range s.Body.List { cc, ok := raw.(*ast.CaseClause) if !ok || *count >= cfg.MaxSteps { break } caseStep, ok := walkCaseClause…`
          - **What:** Iterates over a collection.
          - **Why:** Processes multiple elements with the same logic.
          - **How:** Executes a `for ... range` loop.
          - **Nested steps:**
            - **L449**: `cc, ok := raw.(*ast.CaseClause)`
              - **What:** Defines cc, ok.
              - **Why:** Keeps intermediate state available for later steps in the function.
              - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
            - **L450**: `if !ok || *count >= cfg.MaxSteps { break }`
              - **What:** Branches conditionally.
              - **Why:** Handles different execution paths based on runtime state.
              - **How:** Evaluates the condition and executes the matching branch.
              - **Nested steps:**
                - **L451**: `break`
                  - **What:** Executes a statement.
                  - **Why:** Advances the function logic.
                  - **How:** Runs this statement as part of the function body.
            - **L453**: `caseStep, ok := walkCaseClause(fset, src, cc, depth+1, cfg, count)`
              - **What:** Defines caseStep, ok.
              - **Why:** Keeps intermediate state available for later steps in the function.
              - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
            - **L454**: `if ok { appendChild(caseStep) }`
              - **What:** Branches conditionally.
              - **Why:** Handles different execution paths based on runtime state.
              - **How:** Evaluates the condition and executes the matching branch.
              - **Nested steps:**
                - **L455**: `appendChild(caseStep)`
                  - **What:** Calls appendChild.
                  - **Why:** Performs side effects or delegates work to a helper.
                  - **How:** Executes the expression statement.
        - **L458**: `return step, true`
          - **What:** Returns from the current function.
          - **Why:** Ends the current execution path and hands control back to the caller.
          - **How:** Executes a `return` statement (possibly returning values).
    - **L460**: `case *ast.TypeSwitchStmt:`
      - **What:** Selects a switch case.
      - **Why:** Makes multi-branch control flow explicit and readable.
      - **How:** Runs this case body when the switch value matches (or when default is selected).
      - **Nested steps:**
        - **L461**: `if s.Init != nil { if child, ok := walkStmt(fset, src, s.Init, depth+1, cfg, count); ok { appendChild(child) } }`
          - **What:** Branches conditionally.
          - **Why:** Handles different execution paths based on runtime state.
          - **How:** Evaluates the condition and executes the matching branch.
          - **Nested steps:**
            - **L462**: `if child, ok := walkStmt(fset, src, s.Init, depth+1, cfg, count); ok { appendChild(child) }`
              - **What:** Branches conditionally.
              - **Why:** Handles different execution paths based on runtime state.
              - **How:** Evaluates the condition and executes the matching branch.
              - **Nested steps:**
                - **L462**: `child, ok := walkStmt(fset, src, s.Init, depth+1, cfg, count)`
                  - **What:** Defines child, ok.
                  - **Why:** Keeps intermediate state available for later steps in the function.
                  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
                - **L463**: `appendChild(child)`
                  - **What:** Calls appendChild.
                  - **Why:** Performs side effects or delegates work to a helper.
                  - **How:** Executes the expression statement.
        - **L466**: `if s.Assign != nil { if child, ok := walkStmt(fset, src, s.Assign, depth+1, cfg, count); ok { appendChild(child) } }`
          - **What:** Branches conditionally.
          - **Why:** Handles different execution paths based on runtime state.
          - **How:** Evaluates the condition and executes the matching branch.
          - **Nested steps:**
            - **L467**: `if child, ok := walkStmt(fset, src, s.Assign, depth+1, cfg, count); ok { appendChild(child) }`
              - **What:** Branches conditionally.
              - **Why:** Handles different execution paths based on runtime state.
              - **How:** Evaluates the condition and executes the matching branch.
              - **Nested steps:**
                - **L467**: `child, ok := walkStmt(fset, src, s.Assign, depth+1, cfg, count)`
                  - **What:** Defines child, ok.
                  - **Why:** Keeps intermediate state available for later steps in the function.
                  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
                - **L468**: `appendChild(child)`
                  - **What:** Calls appendChild.
                  - **Why:** Performs side effects or delegates work to a helper.
                  - **How:** Executes the expression statement.
        - **L471**: `for _, raw := range s.Body.List { cc, ok := raw.(*ast.CaseClause) if !ok || *count >= cfg.MaxSteps { break } caseStep, ok := walkCaseClause…`
          - **What:** Iterates over a collection.
          - **Why:** Processes multiple elements with the same logic.
          - **How:** Executes a `for ... range` loop.
          - **Nested steps:**
            - **L472**: `cc, ok := raw.(*ast.CaseClause)`
              - **What:** Defines cc, ok.
              - **Why:** Keeps intermediate state available for later steps in the function.
              - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
            - **L473**: `if !ok || *count >= cfg.MaxSteps { break }`
              - **What:** Branches conditionally.
              - **Why:** Handles different execution paths based on runtime state.
              - **How:** Evaluates the condition and executes the matching branch.
              - **Nested steps:**
                - **L474**: `break`
                  - **What:** Executes a statement.
                  - **Why:** Advances the function logic.
                  - **How:** Runs this statement as part of the function body.
            - **L476**: `caseStep, ok := walkCaseClause(fset, src, cc, depth+1, cfg, count)`
              - **What:** Defines caseStep, ok.
              - **Why:** Keeps intermediate state available for later steps in the function.
              - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
            - **L477**: `if ok { appendChild(caseStep) }`
              - **What:** Branches conditionally.
              - **Why:** Handles different execution paths based on runtime state.
              - **How:** Evaluates the condition and executes the matching branch.
              - **Nested steps:**
                - **L478**: `appendChild(caseStep)`
                  - **What:** Calls appendChild.
                  - **Why:** Performs side effects or delegates work to a helper.
                  - **How:** Executes the expression statement.
        - **L481**: `return step, true`
          - **What:** Returns from the current function.
          - **Why:** Ends the current execution path and hands control back to the caller.
          - **How:** Executes a `return` statement (possibly returning values).
    - **L483**: `case *ast.SelectStmt:`
      - **What:** Selects a switch case.
      - **Why:** Makes multi-branch control flow explicit and readable.
      - **How:** Runs this case body when the switch value matches (or when default is selected).
      - **Nested steps:**
        - **L484**: `for _, raw := range s.Body.List { cl, ok := raw.(*ast.CommClause) if !ok || *count >= cfg.MaxSteps { break } caseStep, ok := walkCommClause…`
          - **What:** Iterates over a collection.
          - **Why:** Processes multiple elements with the same logic.
          - **How:** Executes a `for ... range` loop.
          - **Nested steps:**
            - **L485**: `cl, ok := raw.(*ast.CommClause)`
              - **What:** Defines cl, ok.
              - **Why:** Keeps intermediate state available for later steps in the function.
              - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
            - **L486**: `if !ok || *count >= cfg.MaxSteps { break }`
              - **What:** Branches conditionally.
              - **Why:** Handles different execution paths based on runtime state.
              - **How:** Evaluates the condition and executes the matching branch.
              - **Nested steps:**
                - **L487**: `break`
                  - **What:** Executes a statement.
                  - **Why:** Advances the function logic.
                  - **How:** Runs this statement as part of the function body.
            - **L489**: `caseStep, ok := walkCommClause(fset, src, cl, depth+1, cfg, count)`
              - **What:** Defines caseStep, ok.
              - **Why:** Keeps intermediate state available for later steps in the function.
              - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
            - **L490**: `if ok { appendChild(caseStep) }`
              - **What:** Branches conditionally.
              - **Why:** Handles different execution paths based on runtime state.
              - **How:** Evaluates the condition and executes the matching branch.
              - **Nested steps:**
                - **L491**: `appendChild(caseStep)`
                  - **What:** Calls appendChild.
                  - **Why:** Performs side effects or delegates work to a helper.
                  - **How:** Executes the expression statement.
        - **L494**: `return step, true`
          - **What:** Returns from the current function.
          - **Why:** Ends the current execution path and hands control back to the caller.
          - **How:** Executes a `return` statement (possibly returning values).
    - **L496**: `case *ast.AssignStmt:`
      - **What:** Selects a switch case.
      - **Why:** Makes multi-branch control flow explicit and readable.
      - **How:** Runs this case body when the switch value matches (or when default is selected).
      - **Nested steps:**
        - **L497**: `for _, expr := range s.Rhs { appendChildren(walkFuncLitsFromExpr(fset, src, expr, depth+1, cfg, count)) }`
          - **What:** Iterates over a collection.
          - **Why:** Processes multiple elements with the same logic.
          - **How:** Executes a `for ... range` loop.
          - **Nested steps:**
            - **L498**: `appendChildren(walkFuncLitsFromExpr(fset, src, expr, depth+1, cfg, count))`
              - **What:** Calls appendChildren.
              - **Why:** Performs side effects or delegates work to a helper.
              - **How:** Executes the expression statement.
        - **L500**: `return step, true`
          - **What:** Returns from the current function.
          - **Why:** Ends the current execution path and hands control back to the caller.
          - **How:** Executes a `return` statement (possibly returning values).
    - **L502**: `case *ast.ReturnStmt:`
      - **What:** Selects a switch case.
      - **Why:** Makes multi-branch control flow explicit and readable.
      - **How:** Runs this case body when the switch value matches (or when default is selected).
      - **Nested steps:**
        - **L503**: `for _, expr := range s.Results { appendChildren(walkFuncLitsFromExpr(fset, src, expr, depth+1, cfg, count)) }`
          - **What:** Iterates over a collection.
          - **Why:** Processes multiple elements with the same logic.
          - **How:** Executes a `for ... range` loop.
          - **Nested steps:**
            - **L504**: `appendChildren(walkFuncLitsFromExpr(fset, src, expr, depth+1, cfg, count))`
              - **What:** Calls appendChildren.
              - **Why:** Performs side effects or delegates work to a helper.
              - **How:** Executes the expression statement.
        - **L506**: `return step, true`
          - **What:** Returns from the current function.
          - **Why:** Ends the current execution path and hands control back to the caller.
          - **How:** Executes a `return` statement (possibly returning values).
    - **L508**: `case *ast.ExprStmt:`
      - **What:** Selects a switch case.
      - **Why:** Makes multi-branch control flow explicit and readable.
      - **How:** Runs this case body when the switch value matches (or when default is selected).
      - **Nested steps:**
        - **L509**: `appendChildren(walkFuncLitsFromExpr(fset, src, s.X, depth+1, cfg, count))`
          - **What:** Calls appendChildren.
          - **Why:** Performs side effects or delegates work to a helper.
          - **How:** Executes the expression statement.
        - **L510**: `return step, true`
          - **What:** Returns from the current function.
          - **Why:** Ends the current execution path and hands control back to the caller.
          - **How:** Executes a `return` statement (possibly returning values).
    - **L512**: `case *ast.GoStmt:`
      - **What:** Selects a switch case.
      - **Why:** Makes multi-branch control flow explicit and readable.
      - **How:** Runs this case body when the switch value matches (or when default is selected).
      - **Nested steps:**
        - **L513**: `if s.Call != nil { appendChildren(walkFuncLitsFromExpr(fset, src, s.Call, depth+1, cfg, count)) }`
          - **What:** Branches conditionally.
          - **Why:** Handles different execution paths based on runtime state.
          - **How:** Evaluates the condition and executes the matching branch.
          - **Nested steps:**
            - **L514**: `appendChildren(walkFuncLitsFromExpr(fset, src, s.Call, depth+1, cfg, count))`
              - **What:** Calls appendChildren.
              - **Why:** Performs side effects or delegates work to a helper.
              - **How:** Executes the expression statement.
        - **L516**: `return step, true`
          - **What:** Returns from the current function.
          - **Why:** Ends the current execution path and hands control back to the caller.
          - **How:** Executes a `return` statement (possibly returning values).
    - **L518**: `case *ast.DeferStmt:`
      - **What:** Selects a switch case.
      - **Why:** Makes multi-branch control flow explicit and readable.
      - **How:** Runs this case body when the switch value matches (or when default is selected).
      - **Nested steps:**
        - **L519**: `if s.Call != nil { appendChildren(walkFuncLitsFromExpr(fset, src, s.Call, depth+1, cfg, count)) }`
          - **What:** Branches conditionally.
          - **Why:** Handles different execution paths based on runtime state.
          - **How:** Evaluates the condition and executes the matching branch.
          - **Nested steps:**
            - **L520**: `appendChildren(walkFuncLitsFromExpr(fset, src, s.Call, depth+1, cfg, count))`
              - **What:** Calls appendChildren.
              - **Why:** Performs side effects or delegates work to a helper.
              - **How:** Executes the expression statement.
        - **L522**: `return step, true`
          - **What:** Returns from the current function.
          - **Why:** Ends the current execution path and hands control back to the caller.
          - **How:** Executes a `return` statement (possibly returning values).
    - **L524**: `default:`
      - **What:** Selects a switch case.
      - **Why:** Makes multi-branch control flow explicit and readable.
      - **How:** Runs this case body when the switch value matches (or when default is selected).
      - **Nested steps:**
        - **L525**: `return step, true`
          - **What:** Returns from the current function.
          - **Why:** Ends the current execution path and hands control back to the caller.
          - **How:** Executes a `return` statement (possibly returning values).

### `walkStmtList`

**What:** Walks a list of statements into walkthrough steps.

**Why:** Common helper used for all block-like constructs to keep recursion logic consistent.

**How:** Iterates the list, calling `walkStmt` while respecting max-steps limits.

```go title="cmd/docsgen/main.go#L529" showLineNumbers
func walkStmtList(fset *token.FileSet, src []byte, list []ast.Stmt, depth int, cfg walkthroughConfig, count *int) []walkStep {
	if len(list) == 0 || count == nil || *count >= cfg.MaxSteps {
		return nil
	}
	out := make([]walkStep, 0, len(list))
	for _, stmt := range list {
		if stmt == nil || *count >= cfg.MaxSteps {
			break
		}
		step, ok := walkStmt(fset, src, stmt, depth, cfg, count)
		if ok {
			out = append(out, step)
		}
	}
	return out
}
```

#### Walkthrough

The list below documents the statements inside the function body, including nested blocks and inline closures.

- **L530**: `if len(list) == 0 || count == nil || *count >= cfg.MaxSteps { return nil }`
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L531**: `return nil`
      - **What:** Returns from the current function.
      - **Why:** Ends the current execution path and hands control back to the caller.
      - **How:** Executes a `return` statement (possibly returning values).
- **L533**: `out := make([]walkStep, 0, len(list))`
  - **What:** Defines out.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L534**: `for _, stmt := range list { if stmt == nil || *count >= cfg.MaxSteps { break } step, ok := walkStmt(fset, src, stmt, depth, cfg, count) if …`
  - **What:** Iterates over a collection.
  - **Why:** Processes multiple elements with the same logic.
  - **How:** Executes a `for ... range` loop.
  - **Nested steps:**
    - **L535**: `if stmt == nil || *count >= cfg.MaxSteps { break }`
      - **What:** Branches conditionally.
      - **Why:** Handles different execution paths based on runtime state.
      - **How:** Evaluates the condition and executes the matching branch.
      - **Nested steps:**
        - **L536**: `break`
          - **What:** Executes a statement.
          - **Why:** Advances the function logic.
          - **How:** Runs this statement as part of the function body.
    - **L538**: `step, ok := walkStmt(fset, src, stmt, depth, cfg, count)`
      - **What:** Defines step, ok.
      - **Why:** Keeps intermediate state available for later steps in the function.
      - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
    - **L539**: `if ok { out = append(out, step) }`
      - **What:** Branches conditionally.
      - **Why:** Handles different execution paths based on runtime state.
      - **How:** Evaluates the condition and executes the matching branch.
      - **Nested steps:**
        - **L540**: `out = append(out, step)`
          - **What:** Assigns out.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L543**: `return out`
  - **What:** Returns from the current function.
  - **Why:** Ends the current execution path and hands control back to the caller.
  - **How:** Executes a `return` statement (possibly returning values).

### `walkFuncLitsFromExpr`

**What:** Finds and walks all closures nested inside an expression.

**Why:** Many statements embed closures in call arguments; without this, walkthroughs would skip important behavior.

**How:** Extracts `*ast.FuncLit` values from the expression and wraps each using `walkFuncLit`.

```go title="cmd/docsgen/main.go#L546" showLineNumbers
func walkFuncLitsFromExpr(fset *token.FileSet, src []byte, expr ast.Expr, depth int, cfg walkthroughConfig, count *int) []walkStep {
	if expr == nil || count == nil || *count >= cfg.MaxSteps {
		return nil
	}
	lits := funcLitsInExpr(expr)
	if len(lits) == 0 {
		return nil
	}
	out := make([]walkStep, 0, len(lits))
	for _, lit := range lits {
		if lit == nil || *count >= cfg.MaxSteps {
			break
		}
		step, ok := walkFuncLit(fset, src, lit, depth, cfg, count)
		if ok {
			out = append(out, step)
		}
	}
	return out
}
```

#### Walkthrough

The list below documents the statements inside the function body, including nested blocks and inline closures.

- **L547**: `if expr == nil || count == nil || *count >= cfg.MaxSteps { return nil }`
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L548**: `return nil`
      - **What:** Returns from the current function.
      - **Why:** Ends the current execution path and hands control back to the caller.
      - **How:** Executes a `return` statement (possibly returning values).
- **L550**: `lits := funcLitsInExpr(expr)`
  - **What:** Defines lits.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L551**: `if len(lits) == 0 { return nil }`
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L552**: `return nil`
      - **What:** Returns from the current function.
      - **Why:** Ends the current execution path and hands control back to the caller.
      - **How:** Executes a `return` statement (possibly returning values).
- **L554**: `out := make([]walkStep, 0, len(lits))`
  - **What:** Defines out.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L555**: `for _, lit := range lits { if lit == nil || *count >= cfg.MaxSteps { break } step, ok := walkFuncLit(fset, src, lit, depth, cfg, count) if …`
  - **What:** Iterates over a collection.
  - **Why:** Processes multiple elements with the same logic.
  - **How:** Executes a `for ... range` loop.
  - **Nested steps:**
    - **L556**: `if lit == nil || *count >= cfg.MaxSteps { break }`
      - **What:** Branches conditionally.
      - **Why:** Handles different execution paths based on runtime state.
      - **How:** Evaluates the condition and executes the matching branch.
      - **Nested steps:**
        - **L557**: `break`
          - **What:** Executes a statement.
          - **Why:** Advances the function logic.
          - **How:** Runs this statement as part of the function body.
    - **L559**: `step, ok := walkFuncLit(fset, src, lit, depth, cfg, count)`
      - **What:** Defines step, ok.
      - **Why:** Keeps intermediate state available for later steps in the function.
      - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
    - **L560**: `if ok { out = append(out, step) }`
      - **What:** Branches conditionally.
      - **Why:** Handles different execution paths based on runtime state.
      - **How:** Evaluates the condition and executes the matching branch.
      - **Nested steps:**
        - **L561**: `out = append(out, step)`
          - **What:** Assigns out.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L564**: `return out`
  - **What:** Returns from the current function.
  - **Why:** Ends the current execution path and hands control back to the caller.
  - **How:** Executes a `return` statement (possibly returning values).

### `walkFuncLit`

**What:** Converts an inline function literal into a walkthrough step and walks its body as nested steps.

**Why:** Closures often contain the "real" behavior in handler-heavy code; including them satisfies the line-by-line documentation goal.

**How:** Emits a synthetic step for the closure and then recursively walks the closure body if present.

```go title="cmd/docsgen/main.go#L567" showLineNumbers
func walkFuncLit(fset *token.FileSet, src []byte, lit *ast.FuncLit, depth int, cfg walkthroughConfig, count *int) (walkStep, bool) {
	if lit == nil || count == nil || *count >= cfg.MaxSteps {
		return walkStep{}, false
	}

	startLine := fset.Position(lit.Pos()).Line
	code := condenseSnippet(sliceSource(fset, src, lit.Pos(), lit.End()))
	step := walkStep{
		StartLine: startLine,
		Code:      code,
		What:      "Defines an inline function (closure).",
		Why:       "Encapsulates callback logic and may capture variables from the surrounding scope.",
		How:       "Declares a `func` literal and uses it as a value (for example, as an HTTP handler or callback).",
	}
	*count++
	if *count >= cfg.MaxSteps || depth >= cfg.MaxDepth || lit.Body == nil || len(lit.Body.List) == 0 {
		return step, true
	}

	step.Children = append(step.Children, walkStmtList(fset, src, lit.Body.List, depth+1, cfg, count)...)
	return step, true
}
```

#### Walkthrough

The list below documents the statements inside the function body, including nested blocks and inline closures.

- **L568**: `if lit == nil || count == nil || *count >= cfg.MaxSteps { return walkStep{}, false }`
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L569**: `return walkStep{}, false`
      - **What:** Returns from the current function.
      - **Why:** Ends the current execution path and hands control back to the caller.
      - **How:** Executes a `return` statement (possibly returning values).
- **L572**: `startLine := fset.Position(lit.Pos()).Line`
  - **What:** Defines startLine.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L573**: `code := condenseSnippet(sliceSource(fset, src, lit.Pos(), lit.End()))`
  - **What:** Defines code.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L574**: `step := walkStep{ StartLine: startLine, Code: code, What: "Defines an inline function (closure).", Why: "Encapsulates callback logic and ma…`
  - **What:** Defines step.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L581**: `*count++`
  - **What:** Updates a counter.
  - **Why:** Maintains an index or tally used by subsequent logic.
  - **How:** Executes an increment/decrement statement.
- **L582**: `if *count >= cfg.MaxSteps || depth >= cfg.MaxDepth || lit.Body == nil || len(lit.Body.List) == 0 { return step, true }`
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L583**: `return step, true`
      - **What:** Returns from the current function.
      - **Why:** Ends the current execution path and hands control back to the caller.
      - **How:** Executes a `return` statement (possibly returning values).
- **L586**: `step.Children = append(step.Children, walkStmtList(fset, src, lit.Body.List, depth+1, cfg, count)...)`
  - **What:** Assigns step.Children.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L587**: `return step, true`
  - **What:** Returns from the current function.
  - **Why:** Ends the current execution path and hands control back to the caller.
  - **How:** Executes a `return` statement (possibly returning values).

### `walkCaseClause`

**What:** Converts a `switch` case clause into a walkthrough step (with nested statement children).

**Why:** Switch bodies often hold substantial logic that should appear in walkthroughs, not as an opaque single statement.

**How:** Builds a `case ...:` / `default:` header, then walks the clause body via `walkStmtList` respecting depth/step limits.

```go title="cmd/docsgen/main.go#L590" showLineNumbers
func walkCaseClause(fset *token.FileSet, src []byte, clause *ast.CaseClause, depth int, cfg walkthroughConfig, count *int) (walkStep, bool) {
	if clause == nil || count == nil || *count >= cfg.MaxSteps {
		return walkStep{}, false
	}

	startLine := fset.Position(clause.Pos()).Line
	var head string
	if len(clause.List) == 0 {
		head = "default:"
	} else {
		var parts []string
		for _, expr := range clause.List {
			parts = append(parts, strings.TrimSpace(nodeString(fset, expr)))
		}
		head = "case " + strings.Join(parts, ", ") + ":"
	}

	step := walkStep{
		StartLine: startLine,
		Code:      condenseSnippet(head),
		What:      "Selects a switch case.",
		Why:       "Makes multi-branch control flow explicit and readable.",
		How:       "Runs this case body when the switch value matches (or when default is selected).",
	}
	*count++
	if *count >= cfg.MaxSteps || depth >= cfg.MaxDepth || len(clause.Body) == 0 {
		return step, true
	}
	step.Children = append(step.Children, walkStmtList(fset, src, clause.Body, depth+1, cfg, count)...)
	return step, true
}
```

#### Walkthrough

The list below documents the statements inside the function body, including nested blocks and inline closures.

- **L591**: `if clause == nil || count == nil || *count >= cfg.MaxSteps { return walkStep{}, false }`
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L592**: `return walkStep{}, false`
      - **What:** Returns from the current function.
      - **Why:** Ends the current execution path and hands control back to the caller.
      - **How:** Executes a `return` statement (possibly returning values).
- **L595**: `startLine := fset.Position(clause.Pos()).Line`
  - **What:** Defines startLine.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L596**: `var head string`
  - **What:** Declares local names.
  - **Why:** Introduces variables or types used later in the function.
  - **How:** Executes a Go declaration statement inside the function body.
- **L597**: `if len(clause.List) == 0 { head = "default:" } else { var parts []string for _, expr := range clause.List { parts = append(parts, strings.T…`
  - **What:** Branches conditionally.
  - **Why:** Handles different execution paths based on runtime state.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L598**: `head = "default:"`
      - **What:** Assigns head.
      - **Why:** Keeps intermediate state available for later steps in the function.
      - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
    - **L600**: `var parts []string`
      - **What:** Declares local names.
      - **Why:** Introduces variables or types used later in the function.
      - **How:** Executes a Go declaration statement inside the function body.
    - **L601**: `for _, expr := range clause.List { parts = append(parts, strings.TrimSpace(nodeString(fset, expr))) }`
      - **What:** Iterates over a collection.
      - **Why:** Processes multiple elements with the same logic.
      - **How:** Executes a `for ... range` loop.
      - **Nested steps:**
        - **L602**: `parts = append(parts, strings.TrimSpace(nodeString(fset, expr)))`
          - **What:** Assigns parts.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
    - **L604**: `head = "case " + strings.Join(parts, ", ") + ":"`
      - **What:** Assigns head.
      - **Why:** Keeps intermediate state available for later steps in the function.
      - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L607**: `step := walkStep{ StartLine: startLine, Code: condenseSnippet(head), What: "Selects a switch case.", Why: "Makes multi-branch control flow …`
  - **What:** Defines step.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L614**: `*count++`
  - **What:** Updates a counter.
  - **Why:** Maintains an index or tally used by subsequent logic.
  - **How:** Executes an increment/decrement statement.
- **L615**: `if *count >= cfg.MaxSteps || depth >= cfg.MaxDepth || len(clause.Body) == 0 { return step, true }`
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L616**: `return step, true`
      - **What:** Returns from the current function.
      - **Why:** Ends the current execution path and hands control back to the caller.
      - **How:** Executes a `return` statement (possibly returning values).
- **L618**: `step.Children = append(step.Children, walkStmtList(fset, src, clause.Body, depth+1, cfg, count)...)`
  - **What:** Assigns step.Children.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L619**: `return step, true`
  - **What:** Returns from the current function.
  - **Why:** Ends the current execution path and hands control back to the caller.
  - **How:** Executes a `return` statement (possibly returning values).

### `walkCommClause`

**What:** Converts a `select` communication clause into a walkthrough step (with nested statement children).

**Why:** Select blocks coordinate concurrency; documenting each branch improves comprehension of control flow.

**How:** Builds a `case <comm>:` / `default:` header, then walks the clause body via `walkStmtList`.

```go title="cmd/docsgen/main.go#L622" showLineNumbers
func walkCommClause(fset *token.FileSet, src []byte, clause *ast.CommClause, depth int, cfg walkthroughConfig, count *int) (walkStep, bool) {
	if clause == nil || count == nil || *count >= cfg.MaxSteps {
		return walkStep{}, false
	}

	startLine := fset.Position(clause.Pos()).Line
	head := "default:"
	if clause.Comm != nil {
		head = "case " + strings.TrimSpace(nodeString(fset, clause.Comm)) + ":"
	}

	step := walkStep{
		StartLine: startLine,
		Code:      condenseSnippet(head),
		What:      "Selects a select-case branch.",
		Why:       "Coordinates concurrent operations without blocking incorrectly.",
		How:       "Runs this case body when its channel operation is ready (or runs default immediately).",
	}
	*count++
	if *count >= cfg.MaxSteps || depth >= cfg.MaxDepth || len(clause.Body) == 0 {
		return step, true
	}
	step.Children = append(step.Children, walkStmtList(fset, src, clause.Body, depth+1, cfg, count)...)
	return step, true
}
```

#### Walkthrough

The list below documents the statements inside the function body, including nested blocks and inline closures.

- **L623**: `if clause == nil || count == nil || *count >= cfg.MaxSteps { return walkStep{}, false }`
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L624**: `return walkStep{}, false`
      - **What:** Returns from the current function.
      - **Why:** Ends the current execution path and hands control back to the caller.
      - **How:** Executes a `return` statement (possibly returning values).
- **L627**: `startLine := fset.Position(clause.Pos()).Line`
  - **What:** Defines startLine.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L628**: `head := "default:"`
  - **What:** Defines head.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L629**: `if clause.Comm != nil { head = "case " + strings.TrimSpace(nodeString(fset, clause.Comm)) + ":" }`
  - **What:** Branches conditionally.
  - **Why:** Handles different execution paths based on runtime state.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L630**: `head = "case " + strings.TrimSpace(nodeString(fset, clause.Comm)) + ":"`
      - **What:** Assigns head.
      - **Why:** Keeps intermediate state available for later steps in the function.
      - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L633**: `step := walkStep{ StartLine: startLine, Code: condenseSnippet(head), What: "Selects a select-case branch.", Why: "Coordinates concurrent op…`
  - **What:** Defines step.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L640**: `*count++`
  - **What:** Updates a counter.
  - **Why:** Maintains an index or tally used by subsequent logic.
  - **How:** Executes an increment/decrement statement.
- **L641**: `if *count >= cfg.MaxSteps || depth >= cfg.MaxDepth || len(clause.Body) == 0 { return step, true }`
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L642**: `return step, true`
      - **What:** Returns from the current function.
      - **Why:** Ends the current execution path and hands control back to the caller.
      - **How:** Executes a `return` statement (possibly returning values).
- **L644**: `step.Children = append(step.Children, walkStmtList(fset, src, clause.Body, depth+1, cfg, count)...)`
  - **What:** Assigns step.Children.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L645**: `return step, true`
  - **What:** Returns from the current function.
  - **Why:** Ends the current execution path and hands control back to the caller.
  - **How:** Executes a `return` statement (possibly returning values).

### `funcLitsInExpr`

**What:** Finds inline function literals (closures) within an expression tree.

**Why:** Core gateway code frequently embeds closures (handlers, callbacks); walkthroughs should not skip their bodies.

**How:** Uses `ast.Inspect` to collect `*ast.FuncLit` nodes and returns them in discovery order.

```go title="cmd/docsgen/main.go#L648" showLineNumbers
func funcLitsInExpr(expr ast.Expr) []*ast.FuncLit {
	if expr == nil {
		return nil
	}
	var lits []*ast.FuncLit
	ast.Inspect(expr, func(n ast.Node) bool {
		if n == nil {
			return false
		}
		lit, ok := n.(*ast.FuncLit)
		if !ok {
			return true
		}
		lits = append(lits, lit)
		return false
	})
	return lits
}
```

#### Walkthrough

The list below documents the statements inside the function body, including nested blocks and inline closures.

- **L649**: `if expr == nil { return nil }`
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L650**: `return nil`
      - **What:** Returns from the current function.
      - **Why:** Ends the current execution path and hands control back to the caller.
      - **How:** Executes a `return` statement (possibly returning values).
- **L652**: `var lits []*ast.FuncLit`
  - **What:** Declares local names.
  - **Why:** Introduces variables or types used later in the function.
  - **How:** Executes a Go declaration statement inside the function body.
- **L653**: `ast.Inspect(expr, func(n ast.Node) bool { if n == nil { return false } lit, ok := n.(*ast.FuncLit) if !ok { return true } lits = append(lit…`
  - **What:** Calls ast.Inspect.
  - **Why:** Performs side effects or delegates work to a helper.
  - **How:** Executes the expression statement.
  - **Nested steps:**
    - **L653**: `func(n ast.Node) bool { if n == nil { return false } lit, ok := n.(*ast.FuncLit) if !ok { return true } lits = append(lits, lit) return fal…`
      - **What:** Defines an inline function (closure).
      - **Why:** Encapsulates callback logic and may capture variables from the surrounding scope.
      - **How:** Declares a `func` literal and uses it as a value (for example, as an HTTP handler or callback).
      - **Nested steps:**
        - **L654**: `if n == nil { return false }`
          - **What:** Branches conditionally.
          - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
          - **How:** Evaluates the condition and executes the matching branch.
          - **Nested steps:**
            - **L655**: `return false`
              - **What:** Returns from the current function.
              - **Why:** Ends the current execution path and hands control back to the caller.
              - **How:** Executes a `return` statement (possibly returning values).
        - **L657**: `lit, ok := n.(*ast.FuncLit)`
          - **What:** Defines lit, ok.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L658**: `if !ok { return true }`
          - **What:** Branches conditionally.
          - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
          - **How:** Evaluates the condition and executes the matching branch.
          - **Nested steps:**
            - **L659**: `return true`
              - **What:** Returns from the current function.
              - **Why:** Ends the current execution path and hands control back to the caller.
              - **How:** Executes a `return` statement (possibly returning values).
        - **L661**: `lits = append(lits, lit)`
          - **What:** Assigns lits.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L662**: `return false`
          - **What:** Returns from the current function.
          - **Why:** Ends the current execution path and hands control back to the caller.
          - **How:** Executes a `return` statement (possibly returning values).
- **L664**: `return lits`
  - **What:** Returns from the current function.
  - **Why:** Ends the current execution path and hands control back to the caller.
  - **How:** Executes a `return` statement (possibly returning values).

### `describeStmt`

**What:** Produces a generic "What/Why/How" explanation for a single Go statement node.

**Why:** Walkthroughs need reasonable defaults even when no human-authored commentary exists for each individual statement.

**How:** Uses a type switch over `ast.Stmt` implementations and emits short intent-focused strings (with special handling for guard `if` statements).

```go title="cmd/docsgen/main.go#L667" showLineNumbers
func describeStmt(fset *token.FileSet, stmt ast.Stmt) (what, why, how string) {
	switch s := stmt.(type) {
	case *ast.AssignStmt:
		names := strings.TrimSpace(exprListString(fset, s.Lhs))
		if names == "" {
			names = "value(s)"
		}
		if s.Tok == token.DEFINE {
			what = fmt.Sprintf("Defines %s.", names)
		} else {
			what = fmt.Sprintf("Assigns %s.", names)
		}
		why = "Keeps intermediate state available for later steps in the function."
		how = "Evaluates the right-hand side expressions and stores results in the left-hand variables."
		return what, why, how

	case *ast.DeclStmt:
		what = "Declares local names."
		why = "Introduces variables or types used later in the function."
		how = "Executes a Go declaration statement inside the function body."
		return what, why, how

	case *ast.IfStmt:
		what = "Branches conditionally."
		if isGuardIf(s) {
			why = "Short-circuits early when a precondition is not met or an error/edge case is detected."
		} else {
			why = "Handles different execution paths based on runtime state."
		}
		how = "Evaluates the condition and executes the matching branch."
		return what, why, how

	case *ast.ReturnStmt:
		what = "Returns from the current function."
		why = "Ends the current execution path and hands control back to the caller."
		how = "Executes a `return` statement (possibly returning values)."
		return what, why, how

	case *ast.ExprStmt:
		if call, ok := s.X.(*ast.CallExpr); ok {
			callee := strings.TrimSpace(nodeString(fset, call.Fun))
			if callee != "" {
				what = fmt.Sprintf("Calls %s.", callee)
			} else {
				what = "Calls a function."
			}
		} else {
			what = "Evaluates an expression."
		}
		why = "Performs side effects or delegates work to a helper."
		how = "Executes the expression statement."
		return what, why, how

	case *ast.ForStmt:
		what = "Runs a loop."
		why = "Repeats logic until a condition is met or the loop terminates."
		how = "Executes a `for` loop statement."
		return what, why, how

	case *ast.RangeStmt:
		what = "Iterates over a collection."
		why = "Processes multiple elements with the same logic."
		how = "Executes a `for ... range` loop."
		return what, why, how

	case *ast.SwitchStmt:
		what = "Selects a branch from multiple cases."
		why = "Keeps multi-case branching readable and explicit."
		how = "Evaluates the switch expression and executes the first matching case."
		return what, why, how

	case *ast.TypeSwitchStmt:
		what = "Selects a branch based on dynamic type."
		why = "Handles multiple concrete types cleanly."
		how = "Executes a type switch statement."
		return what, why, how

	case *ast.SelectStmt:
		what = "Selects among concurrent operations."
		why = "Coordinates channel operations without blocking incorrectly."
		how = "Executes a `select` statement and runs one ready case."
		return what, why, how

	case *ast.SendStmt:
		what = "Sends a value on a channel."
		why = "Communicates with another goroutine."
		how = "Executes a channel send operation."
		return what, why, how

	case *ast.DeferStmt:
		what = "Defers a call for cleanup."
		why = "Ensures the deferred action runs even on early returns."
		how = "Schedules the call to run when the surrounding function returns."
		return what, why, how

	case *ast.GoStmt:
		what = "Starts a goroutine."
		why = "Runs work concurrently."
		how = "Invokes the function call asynchronously using `go`."
		return what, why, how

	case *ast.IncDecStmt:
		what = "Updates a counter."
		why = "Maintains an index or tally used by subsequent logic."
		how = "Executes an increment/decrement statement."
		return what, why, how

	default:
		what = "Executes a statement."
		why = "Advances the function logic."
		how = "Runs this statement as part of the function body."
		return what, why, how
	}
}
```

#### Walkthrough

The list below documents the statements inside the function body, including nested blocks and inline closures.

- **L668**: `switch s := stmt.(type) { case *ast.AssignStmt: names := strings.TrimSpace(exprListString(fset, s.Lhs)) if names == "" { names = "value(s)"…`
  - **What:** Selects a branch based on dynamic type.
  - **Why:** Handles multiple concrete types cleanly.
  - **How:** Executes a type switch statement.
  - **Nested steps:**
    - **L668**: `s := stmt.(type)`
      - **What:** Defines s.
      - **Why:** Keeps intermediate state available for later steps in the function.
      - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
    - **L669**: `case *ast.AssignStmt:`
      - **What:** Selects a switch case.
      - **Why:** Makes multi-branch control flow explicit and readable.
      - **How:** Runs this case body when the switch value matches (or when default is selected).
      - **Nested steps:**
        - **L670**: `names := strings.TrimSpace(exprListString(fset, s.Lhs))`
          - **What:** Defines names.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L671**: `if names == "" { names = "value(s)" }`
          - **What:** Branches conditionally.
          - **Why:** Handles different execution paths based on runtime state.
          - **How:** Evaluates the condition and executes the matching branch.
          - **Nested steps:**
            - **L672**: `names = "value(s)"`
              - **What:** Assigns names.
              - **Why:** Keeps intermediate state available for later steps in the function.
              - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L674**: `if s.Tok == token.DEFINE { what = fmt.Sprintf("Defines %s.", names) } else { what = fmt.Sprintf("Assigns %s.", names) }`
          - **What:** Branches conditionally.
          - **Why:** Handles different execution paths based on runtime state.
          - **How:** Evaluates the condition and executes the matching branch.
          - **Nested steps:**
            - **L675**: `what = fmt.Sprintf("Defines %s.", names)`
              - **What:** Assigns what.
              - **Why:** Keeps intermediate state available for later steps in the function.
              - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
            - **L677**: `what = fmt.Sprintf("Assigns %s.", names)`
              - **What:** Assigns what.
              - **Why:** Keeps intermediate state available for later steps in the function.
              - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L679**: `why = "Keeps intermediate state available for later steps in the function."`
          - **What:** Assigns why.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L680**: `how = "Evaluates the right-hand side expressions and stores results in the left-hand variables."`
          - **What:** Assigns how.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L681**: `return what, why, how`
          - **What:** Returns from the current function.
          - **Why:** Ends the current execution path and hands control back to the caller.
          - **How:** Executes a `return` statement (possibly returning values).
    - **L683**: `case *ast.DeclStmt:`
      - **What:** Selects a switch case.
      - **Why:** Makes multi-branch control flow explicit and readable.
      - **How:** Runs this case body when the switch value matches (or when default is selected).
      - **Nested steps:**
        - **L684**: `what = "Declares local names."`
          - **What:** Assigns what.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L685**: `why = "Introduces variables or types used later in the function."`
          - **What:** Assigns why.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L686**: `how = "Executes a Go declaration statement inside the function body."`
          - **What:** Assigns how.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L687**: `return what, why, how`
          - **What:** Returns from the current function.
          - **Why:** Ends the current execution path and hands control back to the caller.
          - **How:** Executes a `return` statement (possibly returning values).
    - **L689**: `case *ast.IfStmt:`
      - **What:** Selects a switch case.
      - **Why:** Makes multi-branch control flow explicit and readable.
      - **How:** Runs this case body when the switch value matches (or when default is selected).
      - **Nested steps:**
        - **L690**: `what = "Branches conditionally."`
          - **What:** Assigns what.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L691**: `if isGuardIf(s) { why = "Short-circuits early when a precondition is not met or an error/edge case is detected." } else { why = "Handles di…`
          - **What:** Branches conditionally.
          - **Why:** Handles different execution paths based on runtime state.
          - **How:** Evaluates the condition and executes the matching branch.
          - **Nested steps:**
            - **L692**: `why = "Short-circuits early when a precondition is not met or an error/edge case is detected."`
              - **What:** Assigns why.
              - **Why:** Keeps intermediate state available for later steps in the function.
              - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
            - **L694**: `why = "Handles different execution paths based on runtime state."`
              - **What:** Assigns why.
              - **Why:** Keeps intermediate state available for later steps in the function.
              - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L696**: `how = "Evaluates the condition and executes the matching branch."`
          - **What:** Assigns how.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L697**: `return what, why, how`
          - **What:** Returns from the current function.
          - **Why:** Ends the current execution path and hands control back to the caller.
          - **How:** Executes a `return` statement (possibly returning values).
    - **L699**: `case *ast.ReturnStmt:`
      - **What:** Selects a switch case.
      - **Why:** Makes multi-branch control flow explicit and readable.
      - **How:** Runs this case body when the switch value matches (or when default is selected).
      - **Nested steps:**
        - **L700**: `what = "Returns from the current function."`
          - **What:** Assigns what.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L701**: `why = "Ends the current execution path and hands control back to the caller."`
          - **What:** Assigns why.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L702**: `` how = "Executes a `return` statement (possibly returning values)." ``
          - **What:** Assigns how.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L703**: `return what, why, how`
          - **What:** Returns from the current function.
          - **Why:** Ends the current execution path and hands control back to the caller.
          - **How:** Executes a `return` statement (possibly returning values).
    - **L705**: `case *ast.ExprStmt:`
      - **What:** Selects a switch case.
      - **Why:** Makes multi-branch control flow explicit and readable.
      - **How:** Runs this case body when the switch value matches (or when default is selected).
      - **Nested steps:**
        - **L706**: `if call, ok := s.X.(*ast.CallExpr); ok { callee := strings.TrimSpace(nodeString(fset, call.Fun)) if callee != "" { what = fmt.Sprintf("Call…`
          - **What:** Branches conditionally.
          - **Why:** Handles different execution paths based on runtime state.
          - **How:** Evaluates the condition and executes the matching branch.
          - **Nested steps:**
            - **L706**: `call, ok := s.X.(*ast.CallExpr)`
              - **What:** Defines call, ok.
              - **Why:** Keeps intermediate state available for later steps in the function.
              - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
            - **L707**: `callee := strings.TrimSpace(nodeString(fset, call.Fun))`
              - **What:** Defines callee.
              - **Why:** Keeps intermediate state available for later steps in the function.
              - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
            - **L708**: `if callee != "" { what = fmt.Sprintf("Calls %s.", callee) } else { what = "Calls a function." }`
              - **What:** Branches conditionally.
              - **Why:** Handles different execution paths based on runtime state.
              - **How:** Evaluates the condition and executes the matching branch.
              - **Nested steps:**
                - **L709**: `what = fmt.Sprintf("Calls %s.", callee)`
                  - **What:** Assigns what.
                  - **Why:** Keeps intermediate state available for later steps in the function.
                  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
                - **L711**: `what = "Calls a function."`
                  - **What:** Assigns what.
                  - **Why:** Keeps intermediate state available for later steps in the function.
                  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
            - **L714**: `what = "Evaluates an expression."`
              - **What:** Assigns what.
              - **Why:** Keeps intermediate state available for later steps in the function.
              - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L716**: `why = "Performs side effects or delegates work to a helper."`
          - **What:** Assigns why.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L717**: `how = "Executes the expression statement."`
          - **What:** Assigns how.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L718**: `return what, why, how`
          - **What:** Returns from the current function.
          - **Why:** Ends the current execution path and hands control back to the caller.
          - **How:** Executes a `return` statement (possibly returning values).
    - **L720**: `case *ast.ForStmt:`
      - **What:** Selects a switch case.
      - **Why:** Makes multi-branch control flow explicit and readable.
      - **How:** Runs this case body when the switch value matches (or when default is selected).
      - **Nested steps:**
        - **L721**: `what = "Runs a loop."`
          - **What:** Assigns what.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L722**: `why = "Repeats logic until a condition is met or the loop terminates."`
          - **What:** Assigns why.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L723**: `` how = "Executes a `for` loop statement." ``
          - **What:** Assigns how.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L724**: `return what, why, how`
          - **What:** Returns from the current function.
          - **Why:** Ends the current execution path and hands control back to the caller.
          - **How:** Executes a `return` statement (possibly returning values).
    - **L726**: `case *ast.RangeStmt:`
      - **What:** Selects a switch case.
      - **Why:** Makes multi-branch control flow explicit and readable.
      - **How:** Runs this case body when the switch value matches (or when default is selected).
      - **Nested steps:**
        - **L727**: `what = "Iterates over a collection."`
          - **What:** Assigns what.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L728**: `why = "Processes multiple elements with the same logic."`
          - **What:** Assigns why.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L729**: `` how = "Executes a `for ... range` loop." ``
          - **What:** Assigns how.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L730**: `return what, why, how`
          - **What:** Returns from the current function.
          - **Why:** Ends the current execution path and hands control back to the caller.
          - **How:** Executes a `return` statement (possibly returning values).
    - **L732**: `case *ast.SwitchStmt:`
      - **What:** Selects a switch case.
      - **Why:** Makes multi-branch control flow explicit and readable.
      - **How:** Runs this case body when the switch value matches (or when default is selected).
      - **Nested steps:**
        - **L733**: `what = "Selects a branch from multiple cases."`
          - **What:** Assigns what.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L734**: `why = "Keeps multi-case branching readable and explicit."`
          - **What:** Assigns why.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L735**: `how = "Evaluates the switch expression and executes the first matching case."`
          - **What:** Assigns how.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L736**: `return what, why, how`
          - **What:** Returns from the current function.
          - **Why:** Ends the current execution path and hands control back to the caller.
          - **How:** Executes a `return` statement (possibly returning values).
    - **L738**: `case *ast.TypeSwitchStmt:`
      - **What:** Selects a switch case.
      - **Why:** Makes multi-branch control flow explicit and readable.
      - **How:** Runs this case body when the switch value matches (or when default is selected).
      - **Nested steps:**
        - **L739**: `what = "Selects a branch based on dynamic type."`
          - **What:** Assigns what.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L740**: `why = "Handles multiple concrete types cleanly."`
          - **What:** Assigns why.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L741**: `how = "Executes a type switch statement."`
          - **What:** Assigns how.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L742**: `return what, why, how`
          - **What:** Returns from the current function.
          - **Why:** Ends the current execution path and hands control back to the caller.
          - **How:** Executes a `return` statement (possibly returning values).
    - **L744**: `case *ast.SelectStmt:`
      - **What:** Selects a switch case.
      - **Why:** Makes multi-branch control flow explicit and readable.
      - **How:** Runs this case body when the switch value matches (or when default is selected).
      - **Nested steps:**
        - **L745**: `what = "Selects among concurrent operations."`
          - **What:** Assigns what.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L746**: `why = "Coordinates channel operations without blocking incorrectly."`
          - **What:** Assigns why.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L747**: `` how = "Executes a `select` statement and runs one ready case." ``
          - **What:** Assigns how.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L748**: `return what, why, how`
          - **What:** Returns from the current function.
          - **Why:** Ends the current execution path and hands control back to the caller.
          - **How:** Executes a `return` statement (possibly returning values).
    - **L750**: `case *ast.SendStmt:`
      - **What:** Selects a switch case.
      - **Why:** Makes multi-branch control flow explicit and readable.
      - **How:** Runs this case body when the switch value matches (or when default is selected).
      - **Nested steps:**
        - **L751**: `what = "Sends a value on a channel."`
          - **What:** Assigns what.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L752**: `why = "Communicates with another goroutine."`
          - **What:** Assigns why.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L753**: `how = "Executes a channel send operation."`
          - **What:** Assigns how.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L754**: `return what, why, how`
          - **What:** Returns from the current function.
          - **Why:** Ends the current execution path and hands control back to the caller.
          - **How:** Executes a `return` statement (possibly returning values).
    - **L756**: `case *ast.DeferStmt:`
      - **What:** Selects a switch case.
      - **Why:** Makes multi-branch control flow explicit and readable.
      - **How:** Runs this case body when the switch value matches (or when default is selected).
      - **Nested steps:**
        - **L757**: `what = "Defers a call for cleanup."`
          - **What:** Assigns what.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L758**: `why = "Ensures the deferred action runs even on early returns."`
          - **What:** Assigns why.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L759**: `how = "Schedules the call to run when the surrounding function returns."`
          - **What:** Assigns how.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L760**: `return what, why, how`
          - **What:** Returns from the current function.
          - **Why:** Ends the current execution path and hands control back to the caller.
          - **How:** Executes a `return` statement (possibly returning values).
    - **L762**: `case *ast.GoStmt:`
      - **What:** Selects a switch case.
      - **Why:** Makes multi-branch control flow explicit and readable.
      - **How:** Runs this case body when the switch value matches (or when default is selected).
      - **Nested steps:**
        - **L763**: `what = "Starts a goroutine."`
          - **What:** Assigns what.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L764**: `why = "Runs work concurrently."`
          - **What:** Assigns why.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L765**: `` how = "Invokes the function call asynchronously using `go`." ``
          - **What:** Assigns how.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L766**: `return what, why, how`
          - **What:** Returns from the current function.
          - **Why:** Ends the current execution path and hands control back to the caller.
          - **How:** Executes a `return` statement (possibly returning values).
    - **L768**: `case *ast.IncDecStmt:`
      - **What:** Selects a switch case.
      - **Why:** Makes multi-branch control flow explicit and readable.
      - **How:** Runs this case body when the switch value matches (or when default is selected).
      - **Nested steps:**
        - **L769**: `what = "Updates a counter."`
          - **What:** Assigns what.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L770**: `why = "Maintains an index or tally used by subsequent logic."`
          - **What:** Assigns why.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L771**: `how = "Executes an increment/decrement statement."`
          - **What:** Assigns how.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L772**: `return what, why, how`
          - **What:** Returns from the current function.
          - **Why:** Ends the current execution path and hands control back to the caller.
          - **How:** Executes a `return` statement (possibly returning values).
    - **L774**: `default:`
      - **What:** Selects a switch case.
      - **Why:** Makes multi-branch control flow explicit and readable.
      - **How:** Runs this case body when the switch value matches (or when default is selected).
      - **Nested steps:**
        - **L775**: `what = "Executes a statement."`
          - **What:** Assigns what.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L776**: `why = "Advances the function logic."`
          - **What:** Assigns why.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L777**: `how = "Runs this statement as part of the function body."`
          - **What:** Assigns how.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L778**: `return what, why, how`
          - **What:** Returns from the current function.
          - **Why:** Ends the current execution path and hands control back to the caller.
          - **How:** Executes a `return` statement (possibly returning values).

### `isGuardIf`

**What:** Detects whether an `if` statement is an early-return guard clause.

**Why:** Walkthrough prose is clearer when guard clauses are labeled as "short-circuit on error/precondition failure".

**How:** Treats an `if` with no `else` and a body containing a `return` as a guard.

```go title="cmd/docsgen/main.go#L782" showLineNumbers
func isGuardIf(stmt *ast.IfStmt) bool {
	if stmt == nil || stmt.Else != nil || stmt.Body == nil || len(stmt.Body.List) == 0 {
		return false
	}
	for _, s := range stmt.Body.List {
		if _, ok := s.(*ast.ReturnStmt); ok {
			return true
		}
	}
	return false
}
```

#### Walkthrough

The list below documents the statements inside the function body, including nested blocks and inline closures.

- **L783**: `if stmt == nil || stmt.Else != nil || stmt.Body == nil || len(stmt.Body.List) == 0 { return false }`
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L784**: `return false`
      - **What:** Returns from the current function.
      - **Why:** Ends the current execution path and hands control back to the caller.
      - **How:** Executes a `return` statement (possibly returning values).
- **L786**: `for _, s := range stmt.Body.List { if _, ok := s.(*ast.ReturnStmt); ok { return true } }`
  - **What:** Iterates over a collection.
  - **Why:** Processes multiple elements with the same logic.
  - **How:** Executes a `for ... range` loop.
  - **Nested steps:**
    - **L787**: `if _, ok := s.(*ast.ReturnStmt); ok { return true }`
      - **What:** Branches conditionally.
      - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
      - **How:** Evaluates the condition and executes the matching branch.
      - **Nested steps:**
        - **L787**: `_, ok := s.(*ast.ReturnStmt)`
          - **What:** Defines _, ok.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L788**: `return true`
          - **What:** Returns from the current function.
          - **Why:** Ends the current execution path and hands control back to the caller.
          - **How:** Executes a `return` statement (possibly returning values).
- **L791**: `return false`
  - **What:** Returns from the current function.
  - **Why:** Ends the current execution path and hands control back to the caller.
  - **How:** Executes a `return` statement (possibly returning values).

### `ensureAnnotationFile`

**What:** Creates or updates an annotation YAML file with stubs for all extracted symbol IDs.

**Why:** When source changes, the docs need a stable place for humans to add explanations without manually discovering new symbol names.

**How:** Loads the existing YAML (if present), backfills missing `file/title`, inserts missing `symbols` keys, and rewrites the YAML deterministically.

```go title="cmd/docsgen/main.go#L794" showLineNumbers
func ensureAnnotationFile(path string, relSrcPath string, blocks []declBlock, funcs []funcEntry) error {
	if err := os.MkdirAll(filepath.Dir(path), 0o755); err != nil {
		return err
	}

	anns, err := loadAnnotations(path)
	if err != nil {
		return err
	}

	if strings.TrimSpace(anns.File) == "" {
		anns.File = relSrcPath
	}
	if strings.TrimSpace(anns.Title) == "" {
		anns.Title = relSrcPath
	}
	if anns.Symbols == nil {
		anns.Symbols = map[string]annotationText{}
	}

	var ids []string
	for _, block := range blocks {
		for _, sym := range block.Symbols {
			ids = append(ids, sym.ID)
		}
	}
	for _, fn := range funcs {
		ids = append(ids, fn.ID)
	}
	sort.Strings(ids)

	for _, id := range ids {
		if _, ok := anns.Symbols[id]; !ok {
			anns.Symbols[id] = annotationText{}
		}
	}

	out, err := marshalAnnotations(anns)
	if err != nil {
		return err
	}
	return os.WriteFile(path, out, 0o644)
}
```

#### Walkthrough

The list below documents the statements inside the function body, including nested blocks and inline closures.

- **L795**: `if err := os.MkdirAll(filepath.Dir(path), 0o755); err != nil { return err }`
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L795**: `err := os.MkdirAll(filepath.Dir(path), 0o755)`
      - **What:** Defines err.
      - **Why:** Keeps intermediate state available for later steps in the function.
      - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
    - **L796**: `return err`
      - **What:** Returns from the current function.
      - **Why:** Ends the current execution path and hands control back to the caller.
      - **How:** Executes a `return` statement (possibly returning values).
- **L799**: `anns, err := loadAnnotations(path)`
  - **What:** Defines anns, err.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L800**: `if err != nil { return err }`
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L801**: `return err`
      - **What:** Returns from the current function.
      - **Why:** Ends the current execution path and hands control back to the caller.
      - **How:** Executes a `return` statement (possibly returning values).
- **L804**: `if strings.TrimSpace(anns.File) == "" { anns.File = relSrcPath }`
  - **What:** Branches conditionally.
  - **Why:** Handles different execution paths based on runtime state.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L805**: `anns.File = relSrcPath`
      - **What:** Assigns anns.File.
      - **Why:** Keeps intermediate state available for later steps in the function.
      - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L807**: `if strings.TrimSpace(anns.Title) == "" { anns.Title = relSrcPath }`
  - **What:** Branches conditionally.
  - **Why:** Handles different execution paths based on runtime state.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L808**: `anns.Title = relSrcPath`
      - **What:** Assigns anns.Title.
      - **Why:** Keeps intermediate state available for later steps in the function.
      - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L810**: `if anns.Symbols == nil { anns.Symbols = map[string]annotationText{} }`
  - **What:** Branches conditionally.
  - **Why:** Handles different execution paths based on runtime state.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L811**: `anns.Symbols = map[string]annotationText{}`
      - **What:** Assigns anns.Symbols.
      - **Why:** Keeps intermediate state available for later steps in the function.
      - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L814**: `var ids []string`
  - **What:** Declares local names.
  - **Why:** Introduces variables or types used later in the function.
  - **How:** Executes a Go declaration statement inside the function body.
- **L815**: `for _, block := range blocks { for _, sym := range block.Symbols { ids = append(ids, sym.ID) } }`
  - **What:** Iterates over a collection.
  - **Why:** Processes multiple elements with the same logic.
  - **How:** Executes a `for ... range` loop.
  - **Nested steps:**
    - **L816**: `for _, sym := range block.Symbols { ids = append(ids, sym.ID) }`
      - **What:** Iterates over a collection.
      - **Why:** Processes multiple elements with the same logic.
      - **How:** Executes a `for ... range` loop.
      - **Nested steps:**
        - **L817**: `ids = append(ids, sym.ID)`
          - **What:** Assigns ids.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L820**: `for _, fn := range funcs { ids = append(ids, fn.ID) }`
  - **What:** Iterates over a collection.
  - **Why:** Processes multiple elements with the same logic.
  - **How:** Executes a `for ... range` loop.
  - **Nested steps:**
    - **L821**: `ids = append(ids, fn.ID)`
      - **What:** Assigns ids.
      - **Why:** Keeps intermediate state available for later steps in the function.
      - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L823**: `sort.Strings(ids)`
  - **What:** Calls sort.Strings.
  - **Why:** Performs side effects or delegates work to a helper.
  - **How:** Executes the expression statement.
- **L825**: `for _, id := range ids { if _, ok := anns.Symbols[id]; !ok { anns.Symbols[id] = annotationText{} } }`
  - **What:** Iterates over a collection.
  - **Why:** Processes multiple elements with the same logic.
  - **How:** Executes a `for ... range` loop.
  - **Nested steps:**
    - **L826**: `if _, ok := anns.Symbols[id]; !ok { anns.Symbols[id] = annotationText{} }`
      - **What:** Branches conditionally.
      - **Why:** Handles different execution paths based on runtime state.
      - **How:** Evaluates the condition and executes the matching branch.
      - **Nested steps:**
        - **L826**: `_, ok := anns.Symbols[id]`
          - **What:** Defines _, ok.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L827**: `anns.Symbols[id] = annotationText{}`
          - **What:** Assigns anns.Symbols[id].
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L831**: `out, err := marshalAnnotations(anns)`
  - **What:** Defines out, err.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L832**: `if err != nil { return err }`
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L833**: `return err`
      - **What:** Returns from the current function.
      - **Why:** Ends the current execution path and hands control back to the caller.
      - **How:** Executes a `return` statement (possibly returning values).
- **L835**: `return os.WriteFile(path, out, 0o644)`
  - **What:** Returns from the current function.
  - **Why:** Ends the current execution path and hands control back to the caller.
  - **How:** Executes a `return` statement (possibly returning values).

### `marshalAnnotations`

**What:** Serializes `fileAnnotations` to YAML with deterministic ordering and formatting.

**Why:** Deterministic output reduces noisy diffs and makes it safe to auto-refresh stubs in commits.

**How:** Builds a `yaml.Node` tree, sorts symbol keys, encodes with indentation, and returns the resulting bytes.

```go title="cmd/docsgen/main.go#L838" showLineNumbers
func marshalAnnotations(anns fileAnnotations) ([]byte, error) {
	root := &yaml.Node{Kind: yaml.MappingNode}

	appendKV(root, "file", yamlStringNode(anns.File))
	appendKV(root, "title", yamlStringNode(anns.Title))

	overview := &yaml.Node{Kind: yaml.MappingNode}
	appendKV(overview, "what", yamlStringNode(anns.Overview.What))
	appendKV(overview, "why", yamlStringNode(anns.Overview.Why))
	appendKV(overview, "how", yamlStringNode(anns.Overview.How))
	appendKV(overview, "notes", yamlStringNode(anns.Overview.Notes))
	appendKV(root, "overview", overview)

	symbols := &yaml.Node{Kind: yaml.MappingNode}
	keys := make([]string, 0, len(anns.Symbols))
	for key := range anns.Symbols {
		keys = append(keys, key)
	}
	sort.Strings(keys)
	for _, key := range keys {
		val := anns.Symbols[key]
		entry := &yaml.Node{Kind: yaml.MappingNode}
		appendKV(entry, "what", yamlStringNode(val.What))
		appendKV(entry, "why", yamlStringNode(val.Why))
		appendKV(entry, "how", yamlStringNode(val.How))
		appendKV(entry, "notes", yamlStringNode(val.Notes))
		appendKV(symbols, key, entry)
	}
	appendKV(root, "symbols", symbols)

	var buf bytes.Buffer
	enc := yaml.NewEncoder(&buf)
	enc.SetIndent(2)
	if err := enc.Encode(root); err != nil {
		return nil, err
	}
	if err := enc.Close(); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
```

#### Walkthrough

The list below documents the statements inside the function body, including nested blocks and inline closures.

- **L839**: `root := &yaml.Node{Kind: yaml.MappingNode}`
  - **What:** Defines root.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L841**: `appendKV(root, "file", yamlStringNode(anns.File))`
  - **What:** Calls appendKV.
  - **Why:** Performs side effects or delegates work to a helper.
  - **How:** Executes the expression statement.
- **L842**: `appendKV(root, "title", yamlStringNode(anns.Title))`
  - **What:** Calls appendKV.
  - **Why:** Performs side effects or delegates work to a helper.
  - **How:** Executes the expression statement.
- **L844**: `overview := &yaml.Node{Kind: yaml.MappingNode}`
  - **What:** Defines overview.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L845**: `appendKV(overview, "what", yamlStringNode(anns.Overview.What))`
  - **What:** Calls appendKV.
  - **Why:** Performs side effects or delegates work to a helper.
  - **How:** Executes the expression statement.
- **L846**: `appendKV(overview, "why", yamlStringNode(anns.Overview.Why))`
  - **What:** Calls appendKV.
  - **Why:** Performs side effects or delegates work to a helper.
  - **How:** Executes the expression statement.
- **L847**: `appendKV(overview, "how", yamlStringNode(anns.Overview.How))`
  - **What:** Calls appendKV.
  - **Why:** Performs side effects or delegates work to a helper.
  - **How:** Executes the expression statement.
- **L848**: `appendKV(overview, "notes", yamlStringNode(anns.Overview.Notes))`
  - **What:** Calls appendKV.
  - **Why:** Performs side effects or delegates work to a helper.
  - **How:** Executes the expression statement.
- **L849**: `appendKV(root, "overview", overview)`
  - **What:** Calls appendKV.
  - **Why:** Performs side effects or delegates work to a helper.
  - **How:** Executes the expression statement.
- **L851**: `symbols := &yaml.Node{Kind: yaml.MappingNode}`
  - **What:** Defines symbols.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L852**: `keys := make([]string, 0, len(anns.Symbols))`
  - **What:** Defines keys.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L853**: `for key := range anns.Symbols { keys = append(keys, key) }`
  - **What:** Iterates over a collection.
  - **Why:** Processes multiple elements with the same logic.
  - **How:** Executes a `for ... range` loop.
  - **Nested steps:**
    - **L854**: `keys = append(keys, key)`
      - **What:** Assigns keys.
      - **Why:** Keeps intermediate state available for later steps in the function.
      - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L856**: `sort.Strings(keys)`
  - **What:** Calls sort.Strings.
  - **Why:** Performs side effects or delegates work to a helper.
  - **How:** Executes the expression statement.
- **L857**: `for _, key := range keys { val := anns.Symbols[key] entry := &yaml.Node{Kind: yaml.MappingNode} appendKV(entry, "what", yamlStringNode(val.…`
  - **What:** Iterates over a collection.
  - **Why:** Processes multiple elements with the same logic.
  - **How:** Executes a `for ... range` loop.
  - **Nested steps:**
    - **L858**: `val := anns.Symbols[key]`
      - **What:** Defines val.
      - **Why:** Keeps intermediate state available for later steps in the function.
      - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
    - **L859**: `entry := &yaml.Node{Kind: yaml.MappingNode}`
      - **What:** Defines entry.
      - **Why:** Keeps intermediate state available for later steps in the function.
      - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
    - **L860**: `appendKV(entry, "what", yamlStringNode(val.What))`
      - **What:** Calls appendKV.
      - **Why:** Performs side effects or delegates work to a helper.
      - **How:** Executes the expression statement.
    - **L861**: `appendKV(entry, "why", yamlStringNode(val.Why))`
      - **What:** Calls appendKV.
      - **Why:** Performs side effects or delegates work to a helper.
      - **How:** Executes the expression statement.
    - **L862**: `appendKV(entry, "how", yamlStringNode(val.How))`
      - **What:** Calls appendKV.
      - **Why:** Performs side effects or delegates work to a helper.
      - **How:** Executes the expression statement.
    - **L863**: `appendKV(entry, "notes", yamlStringNode(val.Notes))`
      - **What:** Calls appendKV.
      - **Why:** Performs side effects or delegates work to a helper.
      - **How:** Executes the expression statement.
    - **L864**: `appendKV(symbols, key, entry)`
      - **What:** Calls appendKV.
      - **Why:** Performs side effects or delegates work to a helper.
      - **How:** Executes the expression statement.
- **L866**: `appendKV(root, "symbols", symbols)`
  - **What:** Calls appendKV.
  - **Why:** Performs side effects or delegates work to a helper.
  - **How:** Executes the expression statement.
- **L868**: `var buf bytes.Buffer`
  - **What:** Declares local names.
  - **Why:** Introduces variables or types used later in the function.
  - **How:** Executes a Go declaration statement inside the function body.
- **L869**: `enc := yaml.NewEncoder(&buf)`
  - **What:** Defines enc.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L870**: `enc.SetIndent(2)`
  - **What:** Calls enc.SetIndent.
  - **Why:** Performs side effects or delegates work to a helper.
  - **How:** Executes the expression statement.
- **L871**: `if err := enc.Encode(root); err != nil { return nil, err }`
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L871**: `err := enc.Encode(root)`
      - **What:** Defines err.
      - **Why:** Keeps intermediate state available for later steps in the function.
      - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
    - **L872**: `return nil, err`
      - **What:** Returns from the current function.
      - **Why:** Ends the current execution path and hands control back to the caller.
      - **How:** Executes a `return` statement (possibly returning values).
- **L874**: `if err := enc.Close(); err != nil { return nil, err }`
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L874**: `err := enc.Close()`
      - **What:** Defines err.
      - **Why:** Keeps intermediate state available for later steps in the function.
      - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
    - **L875**: `return nil, err`
      - **What:** Returns from the current function.
      - **Why:** Ends the current execution path and hands control back to the caller.
      - **How:** Executes a `return` statement (possibly returning values).
- **L877**: `return buf.Bytes(), nil`
  - **What:** Returns from the current function.
  - **Why:** Ends the current execution path and hands control back to the caller.
  - **How:** Executes a `return` statement (possibly returning values).

### `appendKV`

**What:** Appends a key/value pair to a YAML mapping node.

**Why:** The generator writes YAML stubs with stable key ordering and formatting without relying on struct tag marshaling behavior.

**How:** Extends `node.Content` with two scalar nodes: the key and the value node.

```go title="cmd/docsgen/main.go#L880" showLineNumbers
func appendKV(node *yaml.Node, key string, value *yaml.Node) {
	node.Content = append(node.Content, &yaml.Node{
		Kind:  yaml.ScalarNode,
		Tag:   "!!str",
		Value: key,
	}, value)
}
```

#### Walkthrough

The list below documents the statements inside the function body, including nested blocks and inline closures.

- **L881**: `node.Content = append(node.Content, &yaml.Node{ Kind: yaml.ScalarNode, Tag: "!!str", Value: key, }, value)`
  - **What:** Assigns node.Content.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.

### `yamlStringNode`

**What:** Builds a YAML scalar node for a string value, choosing literal style for multiline text.

**Why:** Multiline annotations should remain readable in YAML and should round-trip without awkward escaping.

**How:** Trims whitespace and sets `yaml.LiteralStyle` when the value contains newlines.

```go title="cmd/docsgen/main.go#L888" showLineNumbers
func yamlStringNode(value string) *yaml.Node {
	value = strings.TrimSpace(value)
	node := &yaml.Node{
		Kind:  yaml.ScalarNode,
		Tag:   "!!str",
		Value: value,
	}
	if strings.Contains(value, "\n") {
		node.Style = yaml.LiteralStyle
	}
	return node
}
```

#### Walkthrough

The list below documents the statements inside the function body, including nested blocks and inline closures.

- **L889**: `value = strings.TrimSpace(value)`
  - **What:** Assigns value.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L890**: `node := &yaml.Node{ Kind: yaml.ScalarNode, Tag: "!!str", Value: value, }`
  - **What:** Defines node.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L895**: `if strings.Contains(value, "\n") { node.Style = yaml.LiteralStyle }`
  - **What:** Branches conditionally.
  - **Why:** Handles different execution paths based on runtime state.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L896**: `node.Style = yaml.LiteralStyle`
      - **What:** Assigns node.Style.
      - **Why:** Keeps intermediate state available for later steps in the function.
      - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L898**: `return node`
  - **What:** Returns from the current function.
  - **Why:** Ends the current execution path and hands control back to the caller.
  - **How:** Executes a `return` statement (possibly returning values).

### `receiverTypeString`

**What:** Formats a method receiver type as Go source text.

**Why:** Method symbol IDs should remain stable and human-recognizable (for example, `method (*Server).ServeHTTP`).

**How:** Prints the receiver type AST node via `go/printer` and trims whitespace.

```go title="cmd/docsgen/main.go#L901" showLineNumbers
func receiverTypeString(fset *token.FileSet, expr ast.Expr) string {
	var buf bytes.Buffer
	_ = printer.Fprint(&buf, fset, expr)
	return strings.TrimSpace(buf.String())
}
```

#### Walkthrough

The list below documents the statements inside the function body, including nested blocks and inline closures.

- **L902**: `var buf bytes.Buffer`
  - **What:** Declares local names.
  - **Why:** Introduces variables or types used later in the function.
  - **How:** Executes a Go declaration statement inside the function body.
- **L903**: `_ = printer.Fprint(&buf, fset, expr)`
  - **What:** Assigns _.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L904**: `return strings.TrimSpace(buf.String())`
  - **What:** Returns from the current function.
  - **Why:** Ends the current execution path and hands control back to the caller.
  - **How:** Executes a `return` statement (possibly returning values).

### `nodeString`

**What:** Renders an AST node (expression/statement) to a compact Go code string.

**Why:** Walkthrough headings and certain heuristic descriptions need readable fragments without hand-assembling them.

**How:** Uses `go/printer.Fprint` against a shared `token.FileSet`, then trims whitespace.

```go title="cmd/docsgen/main.go#L907" showLineNumbers
func nodeString(fset *token.FileSet, node any) string {
	var buf bytes.Buffer
	_ = printer.Fprint(&buf, fset, node)
	return strings.TrimSpace(buf.String())
}
```

#### Walkthrough

The list below documents the statements inside the function body, including nested blocks and inline closures.

- **L908**: `var buf bytes.Buffer`
  - **What:** Declares local names.
  - **Why:** Introduces variables or types used later in the function.
  - **How:** Executes a Go declaration statement inside the function body.
- **L909**: `_ = printer.Fprint(&buf, fset, node)`
  - **What:** Assigns _.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L910**: `return strings.TrimSpace(buf.String())`
  - **What:** Returns from the current function.
  - **Why:** Ends the current execution path and hands control back to the caller.
  - **How:** Executes a `return` statement (possibly returning values).

### `exprListString`

**What:** Formats a list of expressions into a readable string.

**Why:** Used to generate better inline descriptions (for example, "Defines x, y") and switch/case headings.

**How:** Prints each expression with `go/printer` and joins the results with commas.

```go title="cmd/docsgen/main.go#L913" showLineNumbers
func exprListString(fset *token.FileSet, exprs []ast.Expr) string {
	if len(exprs) == 0 {
		return ""
	}
	var parts []string
	for _, expr := range exprs {
		parts = append(parts, strings.TrimSpace(nodeString(fset, expr)))
	}
	return strings.Join(parts, ", ")
}
```

#### Walkthrough

The list below documents the statements inside the function body, including nested blocks and inline closures.

- **L914**: `if len(exprs) == 0 { return "" }`
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L915**: `return ""`
      - **What:** Returns from the current function.
      - **Why:** Ends the current execution path and hands control back to the caller.
      - **How:** Executes a `return` statement (possibly returning values).
- **L917**: `var parts []string`
  - **What:** Declares local names.
  - **Why:** Introduces variables or types used later in the function.
  - **How:** Executes a Go declaration statement inside the function body.
- **L918**: `for _, expr := range exprs { parts = append(parts, strings.TrimSpace(nodeString(fset, expr))) }`
  - **What:** Iterates over a collection.
  - **Why:** Processes multiple elements with the same logic.
  - **How:** Executes a `for ... range` loop.
  - **Nested steps:**
    - **L919**: `parts = append(parts, strings.TrimSpace(nodeString(fset, expr)))`
      - **What:** Assigns parts.
      - **Why:** Keeps intermediate state available for later steps in the function.
      - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L921**: `return strings.Join(parts, ", ")`
  - **What:** Returns from the current function.
  - **Why:** Ends the current execution path and hands control back to the caller.
  - **How:** Executes a `return` statement (possibly returning values).

### `sliceSource`

**What:** Extracts the exact source substring for a token position span.

**Why:** Using the original bytes preserves formatting and comments in the displayed snippet (instead of pretty-printing the AST).

**How:** Converts `token.Pos` to byte offsets using the `token.FileSet`, validates bounds, and returns a trimmed substring.

```go title="cmd/docsgen/main.go#L924" showLineNumbers
func sliceSource(fset *token.FileSet, src []byte, start, end token.Pos) string {
	file := fset.File(start)
	if file == nil {
		return ""
	}
	startOff := file.Offset(start)
	endOff := file.Offset(end)
	if startOff < 0 || endOff < 0 || startOff >= len(src) || endOff > len(src) || startOff >= endOff {
		return ""
	}
	return strings.TrimRight(string(src[startOff:endOff]), "\n")
}
```

#### Walkthrough

The list below documents the statements inside the function body, including nested blocks and inline closures.

- **L925**: `file := fset.File(start)`
  - **What:** Defines file.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L926**: `if file == nil { return "" }`
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L927**: `return ""`
      - **What:** Returns from the current function.
      - **Why:** Ends the current execution path and hands control back to the caller.
      - **How:** Executes a `return` statement (possibly returning values).
- **L929**: `startOff := file.Offset(start)`
  - **What:** Defines startOff.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L930**: `endOff := file.Offset(end)`
  - **What:** Defines endOff.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L931**: `if startOff < 0 || endOff < 0 || startOff >= len(src) || endOff > len(src) || startOff >= endOff { return "" }`
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L932**: `return ""`
      - **What:** Returns from the current function.
      - **Why:** Ends the current execution path and hands control back to the caller.
      - **How:** Executes a `return` statement (possibly returning values).
- **L934**: `return strings.TrimRight(string(src[startOff:endOff]), "\n")`
  - **What:** Returns from the current function.
  - **Why:** Ends the current execution path and hands control back to the caller.
  - **How:** Executes a `return` statement (possibly returning values).

### `condenseSnippet`

**What:** Produces a short, single-line summary of a code fragment.

**Why:** Walkthrough steps render code inline; long multi-line statements would make the MDX unreadable.

**How:** Normalizes whitespace/newlines into a single line and truncates by rune count.

```go title="cmd/docsgen/main.go#L937" showLineNumbers
func condenseSnippet(src string) string {
	out := strings.TrimSpace(src)
	if out == "" {
		return out
	}
	out = strings.ReplaceAll(out, "\r\n", "\n")
	out = strings.ReplaceAll(out, "\n", " ")
	out = strings.Join(strings.Fields(out), " ")
	return truncateRunes(out, 140)
}
```

#### Walkthrough

The list below documents the statements inside the function body, including nested blocks and inline closures.

- **L938**: `out := strings.TrimSpace(src)`
  - **What:** Defines out.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L939**: `if out == "" { return out }`
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L940**: `return out`
      - **What:** Returns from the current function.
      - **Why:** Ends the current execution path and hands control back to the caller.
      - **How:** Executes a `return` statement (possibly returning values).
- **L942**: `out = strings.ReplaceAll(out, "\r\n", "\n")`
  - **What:** Assigns out.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L943**: `out = strings.ReplaceAll(out, "\n", " ")`
  - **What:** Assigns out.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L944**: `out = strings.Join(strings.Fields(out), " ")`
  - **What:** Assigns out.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L945**: `return truncateRunes(out, 140)`
  - **What:** Returns from the current function.
  - **Why:** Ends the current execution path and hands control back to the caller.
  - **How:** Executes a `return` statement (possibly returning values).

### `truncateRunes`

**What:** Truncates a string to a maximum rune length, adding an ellipsis when needed.

**Why:** Walkthrough code previews need a predictable size regardless of Unicode input.

**How:** Converts to `[]rune` for safe truncation and appends `…` when the string exceeds the limit.

```go title="cmd/docsgen/main.go#L948" showLineNumbers
func truncateRunes(s string, max int) string {
	if max <= 0 {
		return ""
	}
	if len(s) <= max {
		return s
	}
	r := []rune(s)
	if len(r) <= max {
		return s
	}
	if max <= 1 {
		return string(r[:max])
	}
	return string(r[:max-1]) + "…"
}
```

#### Walkthrough

The list below documents the statements inside the function body, including nested blocks and inline closures.

- **L949**: `if max <= 0 { return "" }`
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L950**: `return ""`
      - **What:** Returns from the current function.
      - **Why:** Ends the current execution path and hands control back to the caller.
      - **How:** Executes a `return` statement (possibly returning values).
- **L952**: `if len(s) <= max { return s }`
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L953**: `return s`
      - **What:** Returns from the current function.
      - **Why:** Ends the current execution path and hands control back to the caller.
      - **How:** Executes a `return` statement (possibly returning values).
- **L955**: `r := []rune(s)`
  - **What:** Defines r.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L956**: `if len(r) <= max { return s }`
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L957**: `return s`
      - **What:** Returns from the current function.
      - **Why:** Ends the current execution path and hands control back to the caller.
      - **How:** Executes a `return` statement (possibly returning values).
- **L959**: `if max <= 1 { return string(r[:max]) }`
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L960**: `return string(r[:max])`
      - **What:** Returns from the current function.
      - **Why:** Ends the current execution path and hands control back to the caller.
      - **How:** Executes a `return` statement (possibly returning values).
- **L962**: `return string(r[:max-1]) + "…"`
  - **What:** Returns from the current function.
  - **Why:** Ends the current execution path and hands control back to the caller.
  - **How:** Executes a `return` statement (possibly returning values).

### `markdownInlineCode`

**What:** Wraps arbitrary text as safe markdown inline code, even if it contains backticks.

**Why:** Walkthrough bullet items include code previews; unescaped backticks would break markdown rendering.

**How:** Finds the longest run of backticks in the source and chooses a delimiter one longer (adding spaces when needed).

```go title="cmd/docsgen/main.go#L965" showLineNumbers
func markdownInlineCode(src string) string {
	if strings.TrimSpace(src) == "" {
		return "`(empty)`"
	}
	maxRun := 0
	curRun := 0
	for _, r := range src {
		if r == '`' {
			curRun++
			if curRun > maxRun {
				maxRun = curRun
			}
		} else {
			curRun = 0
		}
	}
	delim := strings.Repeat("`", maxRun+1)
	if maxRun == 0 {
		return "`" + src + "`"
	}
	return delim + " " + src + " " + delim
}
```

#### Walkthrough

The list below documents the statements inside the function body, including nested blocks and inline closures.

- **L966**: `` if strings.TrimSpace(src) == "" { return "`(empty)`" } ``
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L967**: `` return "`(empty)`" ``
      - **What:** Returns from the current function.
      - **Why:** Ends the current execution path and hands control back to the caller.
      - **How:** Executes a `return` statement (possibly returning values).
- **L969**: `maxRun := 0`
  - **What:** Defines maxRun.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L970**: `curRun := 0`
  - **What:** Defines curRun.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L971**: `` for _, r := range src { if r == '`' { curRun++ if curRun > maxRun { maxRun = curRun } } else { curRun = 0 } } ``
  - **What:** Iterates over a collection.
  - **Why:** Processes multiple elements with the same logic.
  - **How:** Executes a `for ... range` loop.
  - **Nested steps:**
    - **L972**: `` if r == '`' { curRun++ if curRun > maxRun { maxRun = curRun } } else { curRun = 0 } ``
      - **What:** Branches conditionally.
      - **Why:** Handles different execution paths based on runtime state.
      - **How:** Evaluates the condition and executes the matching branch.
      - **Nested steps:**
        - **L973**: `curRun++`
          - **What:** Updates a counter.
          - **Why:** Maintains an index or tally used by subsequent logic.
          - **How:** Executes an increment/decrement statement.
        - **L974**: `if curRun > maxRun { maxRun = curRun }`
          - **What:** Branches conditionally.
          - **Why:** Handles different execution paths based on runtime state.
          - **How:** Evaluates the condition and executes the matching branch.
          - **Nested steps:**
            - **L975**: `maxRun = curRun`
              - **What:** Assigns maxRun.
              - **Why:** Keeps intermediate state available for later steps in the function.
              - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
        - **L978**: `curRun = 0`
          - **What:** Assigns curRun.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L981**: `` delim := strings.Repeat("`", maxRun+1) ``
  - **What:** Defines delim.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L982**: `` if maxRun == 0 { return "`" + src + "`" } ``
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L983**: `` return "`" + src + "`" ``
      - **What:** Returns from the current function.
      - **Why:** Ends the current execution path and hands control back to the caller.
      - **How:** Executes a `return` statement (possibly returning values).
- **L985**: `return delim + " " + src + " " + delim`
  - **What:** Returns from the current function.
  - **Why:** Ends the current execution path and hands control back to the caller.
  - **How:** Executes a `return` statement (possibly returning values).

### `render`

**What:** Renders a `fileDoc` plus annotations into the final MDX document bytes.

**Why:** Centralizes all MDX formatting so generated pages remain consistent across files and easy to evolve.

**How:** Writes frontmatter, source metadata, overview, grouped declaration blocks, per-symbol commentary, then function sections with snippets and walkthroughs.

```go title="cmd/docsgen/main.go#L988" showLineNumbers
func render(doc fileDoc, anns fileAnnotations, githubBase string) []byte {
	var buf bytes.Buffer

	fmt.Fprintf(&buf, "---\n")
	fmt.Fprintf(&buf, "title: %q\n", doc.Title)
	fmt.Fprintf(&buf, "---\n\n")

	fmt.Fprintf(&buf, "<!--\n")
	fmt.Fprintf(&buf, "Generated by `go run ./cmd/docsgen`.\n")
	fmt.Fprintf(&buf, "Do not edit this file directly.\n")
	fmt.Fprintf(&buf, "Edit commentary in `%s`.\n", doc.AnnotationPath)
	fmt.Fprintf(&buf, "-->\n\n")

	fmt.Fprintf(&buf, "## Source\n\n")
	fmt.Fprintf(&buf, "- Package: `%s`\n", doc.PackageName)
	fmt.Fprintf(&buf, "- File: `%s`\n", doc.SrcPath)
	fmt.Fprintf(&buf, "- GitHub: %s%s\n\n", githubBase, doc.SrcPath)

	overview := doc.Overview
	if strings.TrimSpace(overview.What) == "" && strings.TrimSpace(overview.How) == "" && strings.TrimSpace(overview.Why) == "" {
		overview.What = "This page documents the declarations in this file."
		overview.How = "Use the sections below to jump to the symbol you care about, then follow the links back to source."
		overview.Why = "These docs exist to make onboarding and code review faster by explaining intent, not just mechanics."
	}

	fmt.Fprintf(&buf, "## Overview\n\n")
	writeWhatHowWhy(&buf, overview)

	sectionOrder := []string{"Imports", "Constants", "Variables", "Types"}
	blocksBySection := map[string][]declBlock{}
	for _, block := range doc.Blocks {
		blocksBySection[block.Label] = append(blocksBySection[block.Label], block)
	}

	for _, section := range sectionOrder {
		blocks := blocksBySection[section]
		if len(blocks) == 0 {
			continue
		}
		fmt.Fprintf(&buf, "\n## %s\n\n", section)
		for i, block := range blocks {
			fmt.Fprintf(&buf, "### `%s` block %d\n\n", block.Kind, i+1)
			fmt.Fprintf(&buf, "```go title=%q showLineNumbers\n%s\n```\n\n", fmt.Sprintf("%s#L%d", doc.SrcPath, block.StartLine), block.Snippet)

			for _, sym := range block.Symbols {
				fmt.Fprintf(&buf, "#### %s\n\n", sym.Heading)
				writeWhatHowWhy(&buf, resolveSymbol(anns, sym.ID))
			}
		}
	}

	if len(doc.Funcs) > 0 {
		fmt.Fprintf(&buf, "\n## Functions and Methods\n\n")
		for _, fn := range doc.Funcs {
			fmt.Fprintf(&buf, "### %s\n\n", fn.Heading)
			writeWhatHowWhy(&buf, resolveSymbol(anns, fn.ID))
			fmt.Fprintf(&buf, "```go title=%q showLineNumbers\n%s\n```\n\n", fmt.Sprintf("%s#L%d", doc.SrcPath, fn.StartLine), fn.Snippet)
			writeWalkthrough(&buf, fn.Steps)
		}
	}

	return buf.Bytes()
}
```

#### Walkthrough

The list below documents the statements inside the function body, including nested blocks and inline closures.

- **L989**: `var buf bytes.Buffer`
  - **What:** Declares local names.
  - **Why:** Introduces variables or types used later in the function.
  - **How:** Executes a Go declaration statement inside the function body.
- **L991**: `fmt.Fprintf(&buf, "---\n")`
  - **What:** Calls fmt.Fprintf.
  - **Why:** Performs side effects or delegates work to a helper.
  - **How:** Executes the expression statement.
- **L992**: `fmt.Fprintf(&buf, "title: %q\n", doc.Title)`
  - **What:** Calls fmt.Fprintf.
  - **Why:** Performs side effects or delegates work to a helper.
  - **How:** Executes the expression statement.
- **L993**: `fmt.Fprintf(&buf, "---\n\n")`
  - **What:** Calls fmt.Fprintf.
  - **Why:** Performs side effects or delegates work to a helper.
  - **How:** Executes the expression statement.
- **L995**: `fmt.Fprintf(&buf, "<!--\n")`
  - **What:** Calls fmt.Fprintf.
  - **Why:** Performs side effects or delegates work to a helper.
  - **How:** Executes the expression statement.
- **L996**: `` fmt.Fprintf(&buf, "Generated by `go run ./cmd/docsgen`.\n") ``
  - **What:** Calls fmt.Fprintf.
  - **Why:** Performs side effects or delegates work to a helper.
  - **How:** Executes the expression statement.
- **L997**: `fmt.Fprintf(&buf, "Do not edit this file directly.\n")`
  - **What:** Calls fmt.Fprintf.
  - **Why:** Performs side effects or delegates work to a helper.
  - **How:** Executes the expression statement.
- **L998**: `` fmt.Fprintf(&buf, "Edit commentary in `%s`.\n", doc.AnnotationPath) ``
  - **What:** Calls fmt.Fprintf.
  - **Why:** Performs side effects or delegates work to a helper.
  - **How:** Executes the expression statement.
- **L999**: `fmt.Fprintf(&buf, "-->\n\n")`
  - **What:** Calls fmt.Fprintf.
  - **Why:** Performs side effects or delegates work to a helper.
  - **How:** Executes the expression statement.
- **L1001**: `fmt.Fprintf(&buf, "## Source\n\n")`
  - **What:** Calls fmt.Fprintf.
  - **Why:** Performs side effects or delegates work to a helper.
  - **How:** Executes the expression statement.
- **L1002**: `` fmt.Fprintf(&buf, "- Package: `%s`\n", doc.PackageName) ``
  - **What:** Calls fmt.Fprintf.
  - **Why:** Performs side effects or delegates work to a helper.
  - **How:** Executes the expression statement.
- **L1003**: `` fmt.Fprintf(&buf, "- File: `%s`\n", doc.SrcPath) ``
  - **What:** Calls fmt.Fprintf.
  - **Why:** Performs side effects or delegates work to a helper.
  - **How:** Executes the expression statement.
- **L1004**: `fmt.Fprintf(&buf, "- GitHub: %s%s\n\n", githubBase, doc.SrcPath)`
  - **What:** Calls fmt.Fprintf.
  - **Why:** Performs side effects or delegates work to a helper.
  - **How:** Executes the expression statement.
- **L1006**: `overview := doc.Overview`
  - **What:** Defines overview.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L1007**: `if strings.TrimSpace(overview.What) == "" && strings.TrimSpace(overview.How) == "" && strings.TrimSpace(overview.Why) == "" { overview.What…`
  - **What:** Branches conditionally.
  - **Why:** Handles different execution paths based on runtime state.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L1008**: `overview.What = "This page documents the declarations in this file."`
      - **What:** Assigns overview.What.
      - **Why:** Keeps intermediate state available for later steps in the function.
      - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
    - **L1009**: `overview.How = "Use the sections below to jump to the symbol you care about, then follow the links back to source."`
      - **What:** Assigns overview.How.
      - **Why:** Keeps intermediate state available for later steps in the function.
      - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
    - **L1010**: `overview.Why = "These docs exist to make onboarding and code review faster by explaining intent, not just mechanics."`
      - **What:** Assigns overview.Why.
      - **Why:** Keeps intermediate state available for later steps in the function.
      - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L1013**: `fmt.Fprintf(&buf, "## Overview\n\n")`
  - **What:** Calls fmt.Fprintf.
  - **Why:** Performs side effects or delegates work to a helper.
  - **How:** Executes the expression statement.
- **L1014**: `writeWhatHowWhy(&buf, overview)`
  - **What:** Calls writeWhatHowWhy.
  - **Why:** Performs side effects or delegates work to a helper.
  - **How:** Executes the expression statement.
- **L1016**: `sectionOrder := []string{"Imports", "Constants", "Variables", "Types"}`
  - **What:** Defines sectionOrder.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L1017**: `blocksBySection := map[string][]declBlock{}`
  - **What:** Defines blocksBySection.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L1018**: `for _, block := range doc.Blocks { blocksBySection[block.Label] = append(blocksBySection[block.Label], block) }`
  - **What:** Iterates over a collection.
  - **Why:** Processes multiple elements with the same logic.
  - **How:** Executes a `for ... range` loop.
  - **Nested steps:**
    - **L1019**: `blocksBySection[block.Label] = append(blocksBySection[block.Label], block)`
      - **What:** Assigns blocksBySection[block.Label].
      - **Why:** Keeps intermediate state available for later steps in the function.
      - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L1022**: `for _, section := range sectionOrder { blocks := blocksBySection[section] if len(blocks) == 0 { continue } fmt.Fprintf(&buf, "\n## %s\n\n",…`
  - **What:** Iterates over a collection.
  - **Why:** Processes multiple elements with the same logic.
  - **How:** Executes a `for ... range` loop.
  - **Nested steps:**
    - **L1023**: `blocks := blocksBySection[section]`
      - **What:** Defines blocks.
      - **Why:** Keeps intermediate state available for later steps in the function.
      - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
    - **L1024**: `if len(blocks) == 0 { continue }`
      - **What:** Branches conditionally.
      - **Why:** Handles different execution paths based on runtime state.
      - **How:** Evaluates the condition and executes the matching branch.
      - **Nested steps:**
        - **L1025**: `continue`
          - **What:** Executes a statement.
          - **Why:** Advances the function logic.
          - **How:** Runs this statement as part of the function body.
    - **L1027**: `fmt.Fprintf(&buf, "\n## %s\n\n", section)`
      - **What:** Calls fmt.Fprintf.
      - **Why:** Performs side effects or delegates work to a helper.
      - **How:** Executes the expression statement.
    - **L1028**: ```` for i, block := range blocks { fmt.Fprintf(&buf, "### `%s` block %d\n\n", block.Kind, i+1) fmt.Fprintf(&buf, "```go title=%q showLineNumber… ````
      - **What:** Iterates over a collection.
      - **Why:** Processes multiple elements with the same logic.
      - **How:** Executes a `for ... range` loop.
      - **Nested steps:**
        - **L1029**: `` fmt.Fprintf(&buf, "### `%s` block %d\n\n", block.Kind, i+1) ``
          - **What:** Calls fmt.Fprintf.
          - **Why:** Performs side effects or delegates work to a helper.
          - **How:** Executes the expression statement.
        - **L1030**: ```` fmt.Fprintf(&buf, "```go title=%q showLineNumbers\n%s\n```\n\n", fmt.Sprintf("%s#L%d", doc.SrcPath, block.StartLine), block.Snippet) ````
          - **What:** Calls fmt.Fprintf.
          - **Why:** Performs side effects or delegates work to a helper.
          - **How:** Executes the expression statement.
        - **L1032**: `for _, sym := range block.Symbols { fmt.Fprintf(&buf, "#### %s\n\n", sym.Heading) writeWhatHowWhy(&buf, resolveSymbol(anns, sym.ID)) }`
          - **What:** Iterates over a collection.
          - **Why:** Processes multiple elements with the same logic.
          - **How:** Executes a `for ... range` loop.
          - **Nested steps:**
            - **L1033**: `fmt.Fprintf(&buf, "#### %s\n\n", sym.Heading)`
              - **What:** Calls fmt.Fprintf.
              - **Why:** Performs side effects or delegates work to a helper.
              - **How:** Executes the expression statement.
            - **L1034**: `writeWhatHowWhy(&buf, resolveSymbol(anns, sym.ID))`
              - **What:** Calls writeWhatHowWhy.
              - **Why:** Performs side effects or delegates work to a helper.
              - **How:** Executes the expression statement.
- **L1039**: `if len(doc.Funcs) > 0 { fmt.Fprintf(&buf, "\n## Functions and Methods\n\n") for _, fn := range doc.Funcs { fmt.Fprintf(&buf, "### %s\n\n", …`
  - **What:** Branches conditionally.
  - **Why:** Handles different execution paths based on runtime state.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L1040**: `fmt.Fprintf(&buf, "\n## Functions and Methods\n\n")`
      - **What:** Calls fmt.Fprintf.
      - **Why:** Performs side effects or delegates work to a helper.
      - **How:** Executes the expression statement.
    - **L1041**: `for _, fn := range doc.Funcs { fmt.Fprintf(&buf, "### %s\n\n", fn.Heading) writeWhatHowWhy(&buf, resolveSymbol(anns, fn.ID)) fmt.Fprintf(&b…`
      - **What:** Iterates over a collection.
      - **Why:** Processes multiple elements with the same logic.
      - **How:** Executes a `for ... range` loop.
      - **Nested steps:**
        - **L1042**: `fmt.Fprintf(&buf, "### %s\n\n", fn.Heading)`
          - **What:** Calls fmt.Fprintf.
          - **Why:** Performs side effects or delegates work to a helper.
          - **How:** Executes the expression statement.
        - **L1043**: `writeWhatHowWhy(&buf, resolveSymbol(anns, fn.ID))`
          - **What:** Calls writeWhatHowWhy.
          - **Why:** Performs side effects or delegates work to a helper.
          - **How:** Executes the expression statement.
        - **L1044**: ```` fmt.Fprintf(&buf, "```go title=%q showLineNumbers\n%s\n```\n\n", fmt.Sprintf("%s#L%d", doc.SrcPath, fn.StartLine), fn.Snippet) ````
          - **What:** Calls fmt.Fprintf.
          - **Why:** Performs side effects or delegates work to a helper.
          - **How:** Executes the expression statement.
        - **L1045**: `writeWalkthrough(&buf, fn.Steps)`
          - **What:** Calls writeWalkthrough.
          - **Why:** Performs side effects or delegates work to a helper.
          - **How:** Executes the expression statement.
- **L1049**: `return buf.Bytes()`
  - **What:** Returns from the current function.
  - **Why:** Ends the current execution path and hands control back to the caller.
  - **How:** Executes a `return` statement (possibly returning values).

### `writeWalkthrough`

**What:** Writes the "Walkthrough" section for a function/method.

**Why:** Walkthroughs are optional; this keeps MDX output small for simple files while enabling deep dives where useful.

**How:** Emits a short introduction and delegates to `writeWalkthroughSteps` for nested bullet rendering.

```go title="cmd/docsgen/main.go#L1052" showLineNumbers
func writeWalkthrough(buf *bytes.Buffer, steps []walkStep) {
	if len(steps) == 0 {
		return
	}

	fmt.Fprintf(buf, "#### Walkthrough\n\n")
	fmt.Fprintf(buf, "The list below documents the statements inside the function body, including nested blocks and inline closures.\n\n")
	writeWalkthroughSteps(buf, steps, 0)
	fmt.Fprintf(buf, "\n")
}
```

#### Walkthrough

The list below documents the statements inside the function body, including nested blocks and inline closures.

- **L1053**: `if len(steps) == 0 { return }`
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L1054**: `return`
      - **What:** Returns from the current function.
      - **Why:** Ends the current execution path and hands control back to the caller.
      - **How:** Executes a `return` statement (possibly returning values).
- **L1057**: `fmt.Fprintf(buf, "#### Walkthrough\n\n")`
  - **What:** Calls fmt.Fprintf.
  - **Why:** Performs side effects or delegates work to a helper.
  - **How:** Executes the expression statement.
- **L1058**: `fmt.Fprintf(buf, "The list below documents the statements inside the function body, including nested blocks and inline closures.\n\n")`
  - **What:** Calls fmt.Fprintf.
  - **Why:** Performs side effects or delegates work to a helper.
  - **How:** Executes the expression statement.
- **L1059**: `writeWalkthroughSteps(buf, steps, 0)`
  - **What:** Calls writeWalkthroughSteps.
  - **Why:** Performs side effects or delegates work to a helper.
  - **How:** Executes the expression statement.
- **L1060**: `fmt.Fprintf(buf, "\n")`
  - **What:** Calls fmt.Fprintf.
  - **Why:** Performs side effects or delegates work to a helper.
  - **How:** Executes the expression statement.

### `writeWalkthroughSteps`

**What:** Recursively renders walkthrough steps as nested markdown lists.

**Why:** Nested list formatting is finicky; centralizing it avoids inconsistencies across pages and enables future formatting changes in one place.

**How:** Prints each step with line number, inline-code snippet, and What/Why/How bullets; prints children under a "Nested steps" bullet.

```go title="cmd/docsgen/main.go#L1063" showLineNumbers
func writeWalkthroughSteps(buf *bytes.Buffer, steps []walkStep, depth int) {
	indent := strings.Repeat("  ", depth)
	for _, step := range steps {
		code := strings.TrimSpace(step.Code)
		if code == "" {
			code = "(unavailable)"
		}

		fmt.Fprintf(buf, "%s- **L%d**: %s\n", indent, step.StartLine, markdownInlineCode(code))
		fmt.Fprintf(buf, "%s  - **What:** %s\n", indent, strings.TrimSpace(step.What))
		fmt.Fprintf(buf, "%s  - **Why:** %s\n", indent, strings.TrimSpace(step.Why))
		fmt.Fprintf(buf, "%s  - **How:** %s\n", indent, strings.TrimSpace(step.How))
		if len(step.Children) > 0 {
			fmt.Fprintf(buf, "%s  - **Nested steps:**\n", indent)
			writeWalkthroughSteps(buf, step.Children, depth+2)
		}
	}
}
```

#### Walkthrough

The list below documents the statements inside the function body, including nested blocks and inline closures.

- **L1064**: `indent := strings.Repeat(" ", depth)`
  - **What:** Defines indent.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L1065**: `for _, step := range steps { code := strings.TrimSpace(step.Code) if code == "" { code = "(unavailable)" } fmt.Fprintf(buf, "%s- **L%d**: %…`
  - **What:** Iterates over a collection.
  - **Why:** Processes multiple elements with the same logic.
  - **How:** Executes a `for ... range` loop.
  - **Nested steps:**
    - **L1066**: `code := strings.TrimSpace(step.Code)`
      - **What:** Defines code.
      - **Why:** Keeps intermediate state available for later steps in the function.
      - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
    - **L1067**: `if code == "" { code = "(unavailable)" }`
      - **What:** Branches conditionally.
      - **Why:** Handles different execution paths based on runtime state.
      - **How:** Evaluates the condition and executes the matching branch.
      - **Nested steps:**
        - **L1068**: `code = "(unavailable)"`
          - **What:** Assigns code.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
    - **L1071**: `fmt.Fprintf(buf, "%s- **L%d**: %s\n", indent, step.StartLine, markdownInlineCode(code))`
      - **What:** Calls fmt.Fprintf.
      - **Why:** Performs side effects or delegates work to a helper.
      - **How:** Executes the expression statement.
    - **L1072**: `fmt.Fprintf(buf, "%s - **What:** %s\n", indent, strings.TrimSpace(step.What))`
      - **What:** Calls fmt.Fprintf.
      - **Why:** Performs side effects or delegates work to a helper.
      - **How:** Executes the expression statement.
    - **L1073**: `fmt.Fprintf(buf, "%s - **Why:** %s\n", indent, strings.TrimSpace(step.Why))`
      - **What:** Calls fmt.Fprintf.
      - **Why:** Performs side effects or delegates work to a helper.
      - **How:** Executes the expression statement.
    - **L1074**: `fmt.Fprintf(buf, "%s - **How:** %s\n", indent, strings.TrimSpace(step.How))`
      - **What:** Calls fmt.Fprintf.
      - **Why:** Performs side effects or delegates work to a helper.
      - **How:** Executes the expression statement.
    - **L1075**: `if len(step.Children) > 0 { fmt.Fprintf(buf, "%s - **Nested steps:**\n", indent) writeWalkthroughSteps(buf, step.Children, depth+2) }`
      - **What:** Branches conditionally.
      - **Why:** Handles different execution paths based on runtime state.
      - **How:** Evaluates the condition and executes the matching branch.
      - **Nested steps:**
        - **L1076**: `fmt.Fprintf(buf, "%s - **Nested steps:**\n", indent)`
          - **What:** Calls fmt.Fprintf.
          - **Why:** Performs side effects or delegates work to a helper.
          - **How:** Executes the expression statement.
        - **L1077**: `writeWalkthroughSteps(buf, step.Children, depth+2)`
          - **What:** Calls writeWalkthroughSteps.
          - **Why:** Performs side effects or delegates work to a helper.
          - **How:** Executes the expression statement.

### `resolveSymbol`

**What:** Retrieves the human-authored annotation for a symbol ID, applying sensible defaults.

**Why:** Prevents pages from rendering empty sections when a symbol is new or commentary is incomplete.

**How:** Looks up `anns.Symbols[id]` and backfills missing `what/why/how` fields with generic guidance.

```go title="cmd/docsgen/main.go#L1082" showLineNumbers
func resolveSymbol(anns fileAnnotations, id string) annotationText {
	if anns.Symbols == nil {
		return annotationText{
			What: fmt.Sprintf("Declare `%s`.", id),
			How:  "See the Go snippet and the source link for behavior and usage.",
			Why:  "Centralizes behavior and avoids duplication in call sites.",
		}
	}
	if val, ok := anns.Symbols[id]; ok {
		if strings.TrimSpace(val.What) == "" {
			val.What = fmt.Sprintf("Declare `%s`.", id)
		}
		if strings.TrimSpace(val.How) == "" {
			val.How = "See the Go snippet and the source link for behavior and usage."
		}
		if strings.TrimSpace(val.Why) == "" {
			val.Why = "Centralizes behavior and avoids duplication in call sites."
		}
		return val
	}
	return annotationText{
		What: fmt.Sprintf("Declare `%s`.", id),
		How:  "See the Go snippet and the source link for behavior and usage.",
		Why:  "Centralizes behavior and avoids duplication in call sites.",
	}
}
```

#### Walkthrough

The list below documents the statements inside the function body, including nested blocks and inline closures.

- **L1083**: `` if anns.Symbols == nil { return annotationText{ What: fmt.Sprintf("Declare `%s`.", id), How: "See the Go snippet and the source link for be… ``
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L1084**: `` return annotationText{ What: fmt.Sprintf("Declare `%s`.", id), How: "See the Go snippet and the source link for behavior and usage.", Why: … ``
      - **What:** Returns from the current function.
      - **Why:** Ends the current execution path and hands control back to the caller.
      - **How:** Executes a `return` statement (possibly returning values).
- **L1090**: `` if val, ok := anns.Symbols[id]; ok { if strings.TrimSpace(val.What) == "" { val.What = fmt.Sprintf("Declare `%s`.", id) } if strings.TrimSp… ``
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L1090**: `val, ok := anns.Symbols[id]`
      - **What:** Defines val, ok.
      - **Why:** Keeps intermediate state available for later steps in the function.
      - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
    - **L1091**: `` if strings.TrimSpace(val.What) == "" { val.What = fmt.Sprintf("Declare `%s`.", id) } ``
      - **What:** Branches conditionally.
      - **Why:** Handles different execution paths based on runtime state.
      - **How:** Evaluates the condition and executes the matching branch.
      - **Nested steps:**
        - **L1092**: `` val.What = fmt.Sprintf("Declare `%s`.", id) ``
          - **What:** Assigns val.What.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
    - **L1094**: `if strings.TrimSpace(val.How) == "" { val.How = "See the Go snippet and the source link for behavior and usage." }`
      - **What:** Branches conditionally.
      - **Why:** Handles different execution paths based on runtime state.
      - **How:** Evaluates the condition and executes the matching branch.
      - **Nested steps:**
        - **L1095**: `val.How = "See the Go snippet and the source link for behavior and usage."`
          - **What:** Assigns val.How.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
    - **L1097**: `if strings.TrimSpace(val.Why) == "" { val.Why = "Centralizes behavior and avoids duplication in call sites." }`
      - **What:** Branches conditionally.
      - **Why:** Handles different execution paths based on runtime state.
      - **How:** Evaluates the condition and executes the matching branch.
      - **Nested steps:**
        - **L1098**: `val.Why = "Centralizes behavior and avoids duplication in call sites."`
          - **What:** Assigns val.Why.
          - **Why:** Keeps intermediate state available for later steps in the function.
          - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
    - **L1100**: `return val`
      - **What:** Returns from the current function.
      - **Why:** Ends the current execution path and hands control back to the caller.
      - **How:** Executes a `return` statement (possibly returning values).
- **L1102**: `` return annotationText{ What: fmt.Sprintf("Declare `%s`.", id), How: "See the Go snippet and the source link for behavior and usage.", Why: … ``
  - **What:** Returns from the current function.
  - **Why:** Ends the current execution path and hands control back to the caller.
  - **How:** Executes a `return` statement (possibly returning values).

### `writeWhatHowWhy`

**What:** Writes the standard "What / Why / How" (and optional Notes) block for an annotation.

**Why:** Keeps pages consistent and makes it easy to visually scan intent for every symbol.

**How:** Delegates each field to `writeLabeledText` and conditionally includes Notes when non-empty.

```go title="cmd/docsgen/main.go#L1109" showLineNumbers
func writeWhatHowWhy(buf *bytes.Buffer, t annotationText) {
	writeLabeledText(buf, "What", t.What)
	writeLabeledText(buf, "Why", t.Why)
	writeLabeledText(buf, "How", t.How)
	if strings.TrimSpace(t.Notes) != "" {
		writeLabeledText(buf, "Notes", t.Notes)
	}
}
```

#### Walkthrough

The list below documents the statements inside the function body, including nested blocks and inline closures.

- **L1110**: `writeLabeledText(buf, "What", t.What)`
  - **What:** Calls writeLabeledText.
  - **Why:** Performs side effects or delegates work to a helper.
  - **How:** Executes the expression statement.
- **L1111**: `writeLabeledText(buf, "Why", t.Why)`
  - **What:** Calls writeLabeledText.
  - **Why:** Performs side effects or delegates work to a helper.
  - **How:** Executes the expression statement.
- **L1112**: `writeLabeledText(buf, "How", t.How)`
  - **What:** Calls writeLabeledText.
  - **Why:** Performs side effects or delegates work to a helper.
  - **How:** Executes the expression statement.
- **L1113**: `if strings.TrimSpace(t.Notes) != "" { writeLabeledText(buf, "Notes", t.Notes) }`
  - **What:** Branches conditionally.
  - **Why:** Handles different execution paths based on runtime state.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L1114**: `writeLabeledText(buf, "Notes", t.Notes)`
      - **What:** Calls writeLabeledText.
      - **Why:** Performs side effects or delegates work to a helper.
      - **How:** Executes the expression statement.

### `writeLabeledText`

**What:** Writes a labeled markdown paragraph (or block) for a `What/Why/How/Notes` field.

**Why:** Improves MDX rendering for multi-paragraph text and lists by placing labels on their own line when needed.

**How:** Detects multiline/list-looking values and chooses either `**Label:** value` or a block form with blank lines.

```go title="cmd/docsgen/main.go#L1118" showLineNumbers
func writeLabeledText(buf *bytes.Buffer, label string, value string) {
	value = strings.TrimSpace(value)
	if value == "" {
		fmt.Fprintf(buf, "**%s:**\n\n\n", label)
		return
	}

	// When the value contains lists or multiple paragraphs, keep the label on its own line
	// so markdown list markers can render correctly.
	if strings.Contains(value, "\n") || strings.HasPrefix(value, "- ") || strings.HasPrefix(value, "* ") || looksLikeOrderedList(value) {
		fmt.Fprintf(buf, "**%s:**\n\n%s\n\n", label, value)
		return
	}
	fmt.Fprintf(buf, "**%s:** %s\n\n", label, value)
}
```

#### Walkthrough

The list below documents the statements inside the function body, including nested blocks and inline closures.

- **L1119**: `value = strings.TrimSpace(value)`
  - **What:** Assigns value.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L1120**: `if value == "" { fmt.Fprintf(buf, "**%s:**\n\n\n", label) return }`
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L1121**: `fmt.Fprintf(buf, "**%s:**\n\n\n", label)`
      - **What:** Calls fmt.Fprintf.
      - **Why:** Performs side effects or delegates work to a helper.
      - **How:** Executes the expression statement.
    - **L1122**: `return`
      - **What:** Returns from the current function.
      - **Why:** Ends the current execution path and hands control back to the caller.
      - **How:** Executes a `return` statement (possibly returning values).
- **L1127**: `if strings.Contains(value, "\n") || strings.HasPrefix(value, "- ") || strings.HasPrefix(value, "* ") || looksLikeOrderedList(value) { fmt.F…`
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L1128**: `fmt.Fprintf(buf, "**%s:**\n\n%s\n\n", label, value)`
      - **What:** Calls fmt.Fprintf.
      - **Why:** Performs side effects or delegates work to a helper.
      - **How:** Executes the expression statement.
    - **L1129**: `return`
      - **What:** Returns from the current function.
      - **Why:** Ends the current execution path and hands control back to the caller.
      - **How:** Executes a `return` statement (possibly returning values).
- **L1131**: `fmt.Fprintf(buf, "**%s:** %s\n\n", label, value)`
  - **What:** Calls fmt.Fprintf.
  - **Why:** Performs side effects or delegates work to a helper.
  - **How:** Executes the expression statement.

### `looksLikeOrderedList`

**What:** Heuristically detects whether a string begins with an ordered-list marker.

**Why:** Markdown ordered lists can break when rendered inline on the same line as a label.

**How:** Checks for a run of digits followed by `.` and then whitespace.

```go title="cmd/docsgen/main.go#L1134" showLineNumbers
func looksLikeOrderedList(value string) bool {
	if value == "" {
		return false
	}
	i := 0
	for i < len(value) && value[i] >= '0' && value[i] <= '9' {
		i++
	}
	if i == 0 || i >= len(value) {
		return false
	}
	if value[i] != '.' {
		return false
	}
	if i+1 >= len(value) {
		return false
	}
	return value[i+1] == ' ' || value[i+1] == '\t'
}
```

#### Walkthrough

The list below documents the statements inside the function body, including nested blocks and inline closures.

- **L1135**: `if value == "" { return false }`
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L1136**: `return false`
      - **What:** Returns from the current function.
      - **Why:** Ends the current execution path and hands control back to the caller.
      - **How:** Executes a `return` statement (possibly returning values).
- **L1138**: `i := 0`
  - **What:** Defines i.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L1139**: `for i < len(value) && value[i] >= '0' && value[i] <= '9' { i++ }`
  - **What:** Runs a loop.
  - **Why:** Repeats logic until a condition is met or the loop terminates.
  - **How:** Executes a `for` loop statement.
  - **Nested steps:**
    - **L1140**: `i++`
      - **What:** Updates a counter.
      - **Why:** Maintains an index or tally used by subsequent logic.
      - **How:** Executes an increment/decrement statement.
- **L1142**: `if i == 0 || i >= len(value) { return false }`
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L1143**: `return false`
      - **What:** Returns from the current function.
      - **Why:** Ends the current execution path and hands control back to the caller.
      - **How:** Executes a `return` statement (possibly returning values).
- **L1145**: `if value[i] != '.' { return false }`
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L1146**: `return false`
      - **What:** Returns from the current function.
      - **Why:** Ends the current execution path and hands control back to the caller.
      - **How:** Executes a `return` statement (possibly returning values).
- **L1148**: `if i+1 >= len(value) { return false }`
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L1149**: `return false`
      - **What:** Returns from the current function.
      - **Why:** Ends the current execution path and hands control back to the caller.
      - **How:** Executes a `return` statement (possibly returning values).
- **L1151**: `return value[i+1] == ' ' || value[i+1] == '\t'`
  - **What:** Returns from the current function.
  - **Why:** Ends the current execution path and hands control back to the caller.
  - **How:** Executes a `return` statement (possibly returning values).

