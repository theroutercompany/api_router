---
title: "examples/basic/main.go"
---

<!--
Generated by `go run ./cmd/docsgen`.
Do not edit this file directly.
Edit commentary in `docs/annotations/examples/basic/main.yaml`.
-->

## Source

- Package: `main`
- File: `examples/basic/main.go`
- GitHub: https://github.com/theroutercompany/api_router/blob/main/examples/basic/main.go

## Overview

**What:** A minimal example program that runs the gateway runtime programmatically (without the `apigw` CLI).

**Why:**

This repo exposes a reusable SDK surface under `pkg/gateway/*`.

When embedding the gateway into another Go process (or when writing custom tooling),
you often want to:
- build a config struct in code (instead of loading YAML)
- construct the runtime directly
- run with a context that responds to OS signals

**How:**

The example:
- starts from `gatewayconfig.Default()`
- overrides a few fields to make local usage obvious (port, readiness upstreams, auth secret)
- builds a runtime via `gatewayruntime.New(cfg)`
- runs it under a SIGINT/SIGTERM context
- flushes logs on shutdown via `pkglog.Sync()`

**Notes:**

This is an example, not a hardened production entrypoint.
In production, secrets should not be hard-coded and readiness upstreams should be configured via YAML/env.


## Imports

### `import` block 1

```go title="examples/basic/main.go#L3" showLineNumbers
import (
	"context"
	"log"
	"os/signal"
	"syscall"

	gatewayconfig "github.com/theroutercompany/api_router/pkg/gateway/config"
	gatewayruntime "github.com/theroutercompany/api_router/pkg/gateway/runtime"
	pkglog "github.com/theroutercompany/api_router/pkg/log"
)
```


## Functions and Methods

### `main`

**What:** Demonstrates how to construct and run the gateway runtime from Go code.

**Why:** Provides a concrete reference for engineers embedding the gateway or writing a custom entrypoint.

**How:** Builds a config, creates a runtime, runs it under a signal-aware context, and flushes logs at the end.

**Notes:** The example uses fixed URLs and a fixed secret for clarity; treat those values as placeholders.

```go title="examples/basic/main.go#L14" showLineNumbers
func main() {
	cfg := gatewayconfig.Default()
	cfg.HTTP.Port = 8090
	cfg.Readiness.Upstreams[0].BaseURL = "http://127.0.0.1:9001"
	cfg.Readiness.Upstreams[1].BaseURL = "http://127.0.0.1:9002"
	cfg.Auth.Secret = "local-dev-secret"

	rt, err := gatewayruntime.New(cfg)
	if err != nil {
		log.Fatalf("build runtime: %v", err)
	}

	ctx, cancel := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)
	defer cancel()

	if err := rt.Run(ctx); err != nil {
		log.Printf("runtime stopped: %v", err)
	}

	if err := pkglog.Sync(); err != nil {
		log.Printf("sync logs: %v", err)
	}
}
```

#### Walkthrough

The list below documents the statements inside the function body, including nested blocks and inline closures.

- **L15**: `cfg := gatewayconfig.Default()`
  - **What:** Defines cfg.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L16**: `cfg.HTTP.Port = 8090`
  - **What:** Assigns cfg.HTTP.Port.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L17**: `cfg.Readiness.Upstreams[0].BaseURL = "http://127.0.0.1:9001"`
  - **What:** Assigns cfg.Readiness.Upstreams[0].BaseURL.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L18**: `cfg.Readiness.Upstreams[1].BaseURL = "http://127.0.0.1:9002"`
  - **What:** Assigns cfg.Readiness.Upstreams[1].BaseURL.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L19**: `cfg.Auth.Secret = "local-dev-secret"`
  - **What:** Assigns cfg.Auth.Secret.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L21**: `rt, err := gatewayruntime.New(cfg)`
  - **What:** Defines rt, err.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L22**: `if err != nil { log.Fatalf("build runtime: %v", err) }`
  - **What:** Branches conditionally.
  - **Why:** Handles different execution paths based on runtime state.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L23**: `log.Fatalf("build runtime: %v", err)`
      - **What:** Calls log.Fatalf.
      - **Why:** Performs side effects or delegates work to a helper.
      - **How:** Executes the expression statement.
- **L26**: `ctx, cancel := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)`
  - **What:** Defines ctx, cancel.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L27**: `defer cancel()`
  - **What:** Defers a call for cleanup.
  - **Why:** Ensures the deferred action runs even on early returns.
  - **How:** Schedules the call to run when the surrounding function returns.
- **L29**: `if err := rt.Run(ctx); err != nil { log.Printf("runtime stopped: %v", err) }`
  - **What:** Branches conditionally.
  - **Why:** Handles different execution paths based on runtime state.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L29**: `err := rt.Run(ctx)`
      - **What:** Defines err.
      - **Why:** Keeps intermediate state available for later steps in the function.
      - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
    - **L30**: `log.Printf("runtime stopped: %v", err)`
      - **What:** Calls log.Printf.
      - **Why:** Performs side effects or delegates work to a helper.
      - **How:** Executes the expression statement.
- **L33**: `if err := pkglog.Sync(); err != nil { log.Printf("sync logs: %v", err) }`
  - **What:** Branches conditionally.
  - **Why:** Handles different execution paths based on runtime state.
  - **How:** Evaluates the condition and executes the matching branch.
  - **Nested steps:**
    - **L33**: `err := pkglog.Sync()`
      - **What:** Defines err.
      - **Why:** Keeps intermediate state available for later steps in the function.
      - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
    - **L34**: `log.Printf("sync logs: %v", err)`
      - **What:** Calls log.Printf.
      - **Why:** Performs side effects or delegates work to a helper.
      - **How:** Executes the expression statement.

