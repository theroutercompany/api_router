---
title: "internal/shadowdiff/normalize.go"
---

<!--
Generated by `go run ./cmd/docsgen`.
Do not edit this file directly.
Edit commentary in `docs/annotations/internal/shadowdiff/normalize.yaml`.
-->

## Source

- Package: `shadowdiff`
- File: `internal/shadowdiff/normalize.go`
- GitHub: https://github.com/theroutercompany/api_router/blob/main/internal/shadowdiff/normalize.go

## Overview

**What:**

Implements response-body normalization helpers for shadowdiff.

Normalizers transform raw response bytes into a canonical form before comparison.

**Why:**

Many responses contain volatile fields that are expected to differ between runs or implementations,
such as timestamps, uptime counters, and measured latencies.

Without normalization, those expected differences would drown out real regressions.

**How:**

`StripJSONKeys` builds a normalizer function that:
- parses a JSON response into an interface{} tree
- recursively removes selected keys from all nested objects
- re-marshals the JSON to bytes for comparison

**Notes:** Normalizers should be conservative. Only strip fields that are genuinely volatile and do not change semantics.


## Imports

### `import` block 1

```go title="internal/shadowdiff/normalize.go#L3" showLineNumbers
import "encoding/json"
```


## Functions and Methods

### `StripJSONKeys`

**What:** Constructs a normalizer that removes a set of keys from JSON objects.

**Why:** Helps shadowdiff ignore volatile response fields that are not meaningful for semantic comparisons.

**How:** Builds a key set, returns a function that parses JSON, calls `stripKeys` recursively, and marshals back to JSON bytes (returning the original bytes on any error).

**Notes:** If no keys are provided, it returns a no-op normalizer.

```go title="internal/shadowdiff/normalize.go#L7" showLineNumbers
func StripJSONKeys(keys ...string) func([]byte) []byte {
	if len(keys) == 0 {
		return func(b []byte) []byte { return b }
	}

	keySet := make(map[string]struct{}, len(keys))
	for _, key := range keys {
		keySet[key] = struct{}{}
	}

	return func(b []byte) []byte {
		if len(b) == 0 {
			return b
		}

		var payload interface{}
		if err := json.Unmarshal(b, &payload); err != nil {
			return b
		}

		stripKeys(payload, keySet)

		result, err := json.Marshal(payload)
		if err != nil {
			return b
		}
		return result
	}
}
```

#### Walkthrough

The list below documents the top-level statements inside the function body.

- **L8**: `if len(keys) == 0 { return func(b []byte) []byte { return b } }`
  - **What:** Branches conditionally.
  - **Why:** Short-circuits early when a precondition is not met or an error/edge case is detected.
  - **How:** Evaluates the condition and executes the matching branch.
- **L12**: `keySet := make(map[string]struct{}, len(keys))`
  - **What:** Defines keySet.
  - **Why:** Keeps intermediate state available for later steps in the function.
  - **How:** Evaluates the right-hand side expressions and stores results in the left-hand variables.
- **L13**: `for _, key := range keys { keySet[key] = struct{}{} }`
  - **What:** Iterates over a collection.
  - **Why:** Processes multiple elements with the same logic.
  - **How:** Executes a `for ... range` loop.
- **L17**: `return func(b []byte) []byte { if len(b) == 0 { return b } var payload interface{} if err := json.Unmarshal(b, &payload); err != nil { retu…`
  - **What:** Returns from the current function.
  - **Why:** Ends the current execution path and hands control back to the caller.
  - **How:** Executes a `return` statement (possibly returning values).

### `stripKeys`

**What:** Recursively deletes keys from JSON objects and traverses arrays/objects.

**Why:** Volatile fields can appear at any nesting level, especially inside arrays of objects.

**How:** Walks the decoded JSON structure, deletes matching keys from maps, and recurses into child values.

**Notes:** Only handles JSON structures produced by `encoding/json` unmarshalling (maps and slices).

```go title="internal/shadowdiff/normalize.go#L37" showLineNumbers
func stripKeys(value interface{}, keySet map[string]struct{}) {
	switch v := value.(type) {
	case map[string]interface{}:
		for key := range keySet {
			delete(v, key)
		}
		for _, child := range v {
			stripKeys(child, keySet)
		}
	case []interface{}:
		for _, elem := range v {
			stripKeys(elem, keySet)
		}
	}
}
```

#### Walkthrough

The list below documents the top-level statements inside the function body.

- **L38**: `switch v := value.(type) { case map[string]interface{}: for key := range keySet { delete(v, key) } for _, child := range v { stripKeys(chil…`
  - **What:** Selects a branch based on dynamic type.
  - **Why:** Handles multiple concrete types cleanly.
  - **How:** Executes a type switch statement.

