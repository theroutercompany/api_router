---
title: "internal/openapi/service.go"
---

<!--
Generated by `go run ./cmd/docsgen`.
Do not edit this file directly.
Edit commentary in `docs/annotations/internal/openapi/service.yaml`.
-->

## Source

- Package: `openapi`
- File: `internal/openapi/service.go`
- GitHub: https://github.com/theroutercompany/api_router/blob/main/internal/openapi/service.go

## Overview

**What:** Merges multiple OpenAPI fragments into a single OpenAPI document and exposes it as JSON bytes.

The merge inputs are described by a small JSON config file (default `openapi-merge.config.json`).
The merged output is typically persisted to `dist/openapi.json` and also cached in memory for reuse.

**Why:** The project keeps OpenAPI definitions in fragments under `specs/` and other locations to keep
the spec maintainable as the gateway grows.

This service provides a repeatable, deterministic merge step that:
- errors on duplicate paths/components (instead of silently overwriting)
- supports external references via kin-openapi's loader
- avoids repeated merge work via caching and persisted artifacts

The generated `dist/openapi.json` can be served by the gateway and used by tooling (clients, docs, validation).

**How:** - `NewService(...)` constructs a service with default config/dist paths (both overridable via options).
- `(*Service).Document(ctx)` is the main entrypoint:
  1) returns an in-memory cached copy when the on-disk dist file is unchanged
  2) otherwise tries to read the dist file and caches it
  3) otherwise loads fragment files, merges them into one `openapi3.T`, marshals JSON, and persists it

Merge behaviour is implemented by `mergeDocuments` and helpers that merge paths, components, tags, servers, and security.

**Notes:** `mergeDocuments` mutates the first document in the slice (it becomes the merge base).
Ensure your first input represents the canonical root document (info/servers) and treat it as owned by the merge.


## Imports

### `import` block 1

```go title="internal/openapi/service.go#L3" showLineNumbers
import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"sync"
	"time"

	"github.com/getkin/kin-openapi/openapi3"

	pkglog "github.com/theroutercompany/api_router/pkg/log"
)
```


## Constants

### `const` block 1

```go title="internal/openapi/service.go#L18" showLineNumbers
const (
	defaultConfigFile = "openapi-merge.config.json"
	defaultDistFile   = "dist/openapi.json"
)
```

#### `defaultConfigFile`

**What:** Default filename for the OpenAPI merge configuration.

**Why:** Provides a convention so tooling can run without always specifying flags or env vars.

**How:** Used by `resolveConfigPath()` when `OPENAPI_MERGE_CONFIG_PATH` is unset.

#### `defaultDistFile`

**What:** Default output path for the merged OpenAPI JSON.

**Why:** The repo expects a stable artifact location for serving and tooling.

**How:** Used by `NewService()` (converted via `filepath.FromSlash` for OS portability).


## Types

### `type` block 1

```go title="internal/openapi/service.go#L24" showLineNumbers
type DocumentProvider interface {
	Document(ctx context.Context) ([]byte, error)
}
```

#### `DocumentProvider`

**What:** Interface that exposes the merged document bytes.

**Why:** Lets other components depend on "document provider" without depending on the concrete service implementation.

**How:** Implemented by `*Service` via its `Document` method.

### `type` block 2

```go title="internal/openapi/service.go#L29" showLineNumbers
type Service struct {
	configPath string
	distPath   string

	mu    sync.Mutex
	cache *cacheEntry
}
```

#### `Service`

**What:** Service that merges OpenAPI fragments and caches/persists the result.

**Why:** Provides a reusable component for both CLI tooling and runtime endpoints that need the merged OpenAPI.

**How:** Holds config/dist paths, a mutex, and an in-memory cache entry keyed by dist file modtime.

**Notes:** All public access goes through `Document` to ensure concurrency safety.

### `type` block 3

```go title="internal/openapi/service.go#L37" showLineNumbers
type cacheEntry struct {
	raw     []byte
	modTime time.Time
}
```

#### `cacheEntry`

**What:** In-memory cache of merged document bytes plus the dist file modtime they correspond to.

**Why:** Allows `cachedIfCurrent` to determine if the cached bytes are still valid.

**How:** Populated by reading the dist file or by building a new document.

**Notes:** The `raw` bytes are copied on both write and read to avoid external mutation.

### `type` block 4

```go title="internal/openapi/service.go#L43" showLineNumbers
type Option func(*Service)
```

#### `Option`

**What:** Functional option for customizing a `Service`.

**Why:** Keeps the constructor stable while allowing overrides for paths and future settings.

**How:** Applied by `NewService` to mutate the constructed `Service`.

### `type` block 5

```go title="internal/openapi/service.go#L216" showLineNumbers
type mergeConfig struct {
	Inputs []mergeInput `json:"inputs"`
}
```

#### `mergeConfig`

**What:** JSON schema for the OpenAPI merge configuration file.

**Why:** Provides a stable format for listing fragment inputs without hardcoding paths in code.

**How:** Contains an `inputs` array of `mergeInput` objects.

### `type` block 6

```go title="internal/openapi/service.go#L220" showLineNumbers
type mergeInput struct {
	InputFile string `json:"inputFile"`
}
```

#### `mergeInput`

**What:** Single merge input entry describing one OpenAPI fragment file.

**Why:** Allows the config to evolve (additional fields) without changing the top-level structure.

**How:** The `InputFile` field is the path to a fragment; relative paths are resolved relative to the config file directory.


## Functions and Methods

### `WithConfigPath`

**What:** Option that overrides the merge configuration file path.

**Why:** Allows tooling and deployments to point at a different merge config without changing code.

**How:** When the provided path is non-empty, stores it into `Service.configPath`.

```go title="internal/openapi/service.go#L46" showLineNumbers
func WithConfigPath(path string) Option {
	return func(s *Service) {
		if path != "" {
			s.configPath = path
		}
	}
}
```

### `WithDistPath`

**What:** Option that overrides where the merged OpenAPI JSON is persisted.

**Why:** Some environments may want a different artifact location (e.g., writable temp dir).

**How:** When the provided path is non-empty, stores it into `Service.distPath`.

```go title="internal/openapi/service.go#L55" showLineNumbers
func WithDistPath(path string) Option {
	return func(s *Service) {
		if path != "" {
			s.distPath = path
		}
	}
}
```

### `NewService`

**What:** Constructs a new OpenAPI merge service.

**Why:** Centralizes default path selection and allows callers to override config/dist paths via functional options.

**How:** Sets `configPath` to `resolveConfigPath()` and `distPath` to the default dist file, then applies any provided options.

```go title="internal/openapi/service.go#L64" showLineNumbers
func NewService(opts ...Option) *Service {
	s := &Service{
		configPath: resolveConfigPath(),
		distPath:   filepath.FromSlash(defaultDistFile),
	}

	for _, opt := range opts {
		opt(s)
	}

	return s
}
```

### `(*Service).Document`

**What:** Returns the merged OpenAPI document as JSON bytes.

**Why:** Provides a single API to obtain the current merged spec for serving and tooling.

**How:** Under a mutex, checks whether the cached bytes are still current (based on dist file modtime), otherwise reads the dist file, otherwise rebuilds by loading and merging fragments, marshals pretty JSON, persists, caches, and returns a defensive copy.

**Notes:** When persisting fails, the service still returns the merged document but logs a warning and does not rely on modtime caching.

```go title="internal/openapi/service.go#L78" showLineNumbers
func (s *Service) Document(ctx context.Context) ([]byte, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	if data, ok := s.cachedIfCurrent(); ok {
		return data, nil
	}

	if data, modTime, err := s.readDist(); err == nil {
		s.cache = &cacheEntry{raw: data, modTime: modTime}
		return clone(data), nil
	} else if !errors.Is(err, os.ErrNotExist) {
		return nil, fmt.Errorf("read dist: %w", err)
	}

	doc, err := s.buildDocument(ctx)
	if err != nil {
		return nil, err
	}

	raw, err := json.MarshalIndent(doc, "", "  ")
	if err != nil {
		return nil, fmt.Errorf("encode document: %w", err)
	}

	if err := s.persist(raw); err != nil {
		pkglog.Shared().Warnw("failed to persist merged openapi document", "error", err, "path", s.distPath)
		s.cache = &cacheEntry{raw: clone(raw), modTime: time.Time{}}
		return clone(raw), nil
	}

	modTime := fileModTime(s.distPath)
	s.cache = &cacheEntry{raw: clone(raw), modTime: modTime}

	return clone(raw), nil
}
```

### `(*Service).cachedIfCurrent`

**What:** Returns cached document bytes when the on-disk dist file is unchanged.

**Why:** Avoids re-reading/re-merging when nothing has changed and supports external regeneration of the dist file.

**How:** Stats the dist path and compares `info.ModTime()` with the cached modtime; returns a defensive copy on match.

**Notes:** If stat fails, this returns false and the caller falls back to reading or rebuilding.

```go title="internal/openapi/service.go#L115" showLineNumbers
func (s *Service) cachedIfCurrent() ([]byte, bool) {
	if s.cache == nil {
		return nil, false
	}
	info, err := os.Stat(s.distPath)
	if err != nil {
		return nil, false
	}
	if info.ModTime().Equal(s.cache.modTime) {
		return clone(s.cache.raw), true
	}
	return nil, false
}
```

### `(*Service).readDist`

**What:** Reads the dist file and returns its bytes plus modification time.

**Why:** Allows `Document()` to reuse pre-generated artifacts and cache them in memory.

**How:** Stats the file for modtime, reads its contents, and returns both.

**Notes:** When the file is missing, callers treat it as a cache miss and rebuild.

```go title="internal/openapi/service.go#L129" showLineNumbers
func (s *Service) readDist() ([]byte, time.Time, error) {
	info, err := os.Stat(s.distPath)
	if err != nil {
		return nil, time.Time{}, err
	}

	data, err := os.ReadFile(s.distPath)
	if err != nil {
		return nil, time.Time{}, err
	}

	return data, info.ModTime(), nil
}
```

### `(*Service).buildDocument`

**What:** Loads OpenAPI fragment files and merges them into a single `openapi3.T`.

**Why:** Separates "build" logic from caching/persistence concerns.

**How:** Loads merge config, creates an `openapi3.Loader` with external refs allowed, resolves input file paths relative to the config directory, loads each fragment, and passes them to `mergeDocuments`.

**Notes:** The `ctx` is checked between loads so callers can cancel long merges.

```go title="internal/openapi/service.go#L143" showLineNumbers
func (s *Service) buildDocument(ctx context.Context) (*openapi3.T, error) {
	cfg, baseDir, err := s.loadConfig()
	if err != nil {
		return nil, err
	}

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true

	docs := make([]*openapi3.T, 0, len(cfg.Inputs))
	for _, input := range cfg.Inputs {
		select {
		case <-ctx.Done():
			return nil, ctx.Err()
		default:
		}

		path := input.InputFile
		if !filepath.IsAbs(path) {
			path = filepath.Join(baseDir, path)
		}

		doc, err := loader.LoadFromFile(path)
		if err != nil {
			return nil, fmt.Errorf("load openapi fragment %s: %w", path, err)
		}
		docs = append(docs, doc)
	}

	merged, err := mergeDocuments(docs)
	if err != nil {
		return nil, err
	}

	return merged, nil
}
```

### `(*Service).persist`

**What:** Persists merged JSON bytes to the configured dist path.

**Why:** Creates a stable artifact (`dist/openapi.json`) that can be served and used by tooling without re-running merges.

**How:** Validates that `distPath` is set, ensures the parent directory exists, and writes the file with standard permissions.

**Notes:** Failures are non-fatal to `Document()` (it will log and still return bytes).

```go title="internal/openapi/service.go#L180" showLineNumbers
func (s *Service) persist(raw []byte) error {
	if s.distPath == "" {
		return errors.New("dist path not configured")
	}
	dir := filepath.Dir(s.distPath)
	if err := os.MkdirAll(dir, 0o755); err != nil {
		return err
	}
	if err := os.WriteFile(s.distPath, raw, 0o644); err != nil {
		return err
	}
	return nil
}
```

### `(*Service).loadConfig`

**What:** Reads and parses the merge configuration JSON file.

**Why:** The service needs an explicit input list to know which fragments to load.

**How:** Reads the config file, unmarshals into `mergeConfig`, validates that inputs are present, and returns the config plus the config directory for resolving relative paths.

**Notes:** Returns a user-facing error when the configuration has no inputs.

```go title="internal/openapi/service.go#L194" showLineNumbers
func (s *Service) loadConfig() (*mergeConfig, string, error) {
	if s.configPath == "" {
		return nil, "", errors.New("config path not configured")
	}

	raw, err := os.ReadFile(s.configPath)
	if err != nil {
		return nil, "", fmt.Errorf("read config: %w", err)
	}

	var cfg mergeConfig
	if err := json.Unmarshal(raw, &cfg); err != nil {
		return nil, "", fmt.Errorf("parse config: %w", err)
	}

	if len(cfg.Inputs) == 0 {
		return nil, "", errors.New("openapi merge configuration has no inputs")
	}

	return &cfg, filepath.Dir(s.configPath), nil
}
```

### `mergeDocuments`

**What:** Merges multiple `openapi3.T` documents into a single document.

**Why:** Allows the OpenAPI spec to be maintained in smaller, focused fragments.

**How:** Uses the first document as the merge base, ensures base `Paths`/`Components` are initialized, then merges each subsequent document's paths/components and appends tags/servers/security.

**Notes:** The base document is mutated in place and returned.

```go title="internal/openapi/service.go#L224" showLineNumbers
func mergeDocuments(docs []*openapi3.T) (*openapi3.T, error) {
	if len(docs) == 0 {
		return nil, errors.New("no openapi documents to merge")
	}

	base := docs[0]

	if base.Paths == nil {
		base.Paths = openapi3.NewPaths()
	}
	if base.Components == nil {
		components := openapi3.NewComponents()
		base.Components = &components
	}

	for _, doc := range docs[1:] {
		if err := mergePaths(base.Paths, doc.Paths); err != nil {
			return nil, err
		}
		if err := mergeComponents(base.Components, doc.Components); err != nil {
			return nil, err
		}
		base.Tags = mergeTags(base.Tags, doc.Tags)
		base.Servers = mergeServers(base.Servers, doc.Servers)
		base.Security = mergeSecurity(base.Security, doc.Security)
	}

	return base, nil
}
```

### `mergePaths`

**What:** Merges OpenAPI path items and path extensions from one document into another.

**Why:** Duplicate paths are almost always accidental and should fail fast rather than silently overriding routes in the published spec.

**How:** Iterates source paths and inserts them into destination paths, returning an error if a path already exists; does the same for `Paths.Extensions`.

**Notes:** A nil source is treated as empty; a nil destination is treated as a programming error.

```go title="internal/openapi/service.go#L254" showLineNumbers
func mergePaths(dst, src *openapi3.Paths) error {
	if src == nil {
		return nil
	}
	if dst == nil {
		return errors.New("destination paths not initialised")
	}

	dstMap := dst.Map()
	for path, item := range src.Map() {
		if _, exists := dstMap[path]; exists {
			return fmt.Errorf("duplicate path detected: %s", path)
		}
		dst.Set(path, item)
	}

	if len(src.Extensions) > 0 {
		if dst.Extensions == nil {
			dst.Extensions = make(map[string]interface{}, len(src.Extensions))
		}
		for key, value := range src.Extensions {
			if _, exists := dst.Extensions[key]; exists {
				return fmt.Errorf("duplicate path extension detected: %s", key)
			}
			dst.Extensions[key] = value
		}
	}

	return nil
}
```

### `mergeComponents`

**What:** Merges OpenAPI Components blocks (schemas, responses, security schemes, and more).

**Why:** Component definitions must be unique across fragments to avoid ambiguous references.

**How:** Calls `mergeComponentMap` for each supported component category and returns an error on the first duplicate.

**Notes:** A nil source is treated as empty; a nil destination is treated as a programming error.

```go title="internal/openapi/service.go#L285" showLineNumbers
func mergeComponents(dst, src *openapi3.Components) error {
	if src == nil {
		return nil
	}
	if dst == nil {
		return errors.New("destination components not initialised")
	}

	if err := mergeComponentMap(&dst.Schemas, src.Schemas, "schema"); err != nil {
		return err
	}
	if err := mergeComponentMap(&dst.Parameters, src.Parameters, "parameter"); err != nil {
		return err
	}
	if err := mergeComponentMap(&dst.Headers, src.Headers, "header"); err != nil {
		return err
	}
	if err := mergeComponentMap(&dst.RequestBodies, src.RequestBodies, "request body"); err != nil {
		return err
	}
	if err := mergeComponentMap(&dst.Responses, src.Responses, "response"); err != nil {
		return err
	}
	if err := mergeComponentMap(&dst.Examples, src.Examples, "example"); err != nil {
		return err
	}
	if err := mergeComponentMap(&dst.SecuritySchemes, src.SecuritySchemes, "security scheme"); err != nil {
		return err
	}
	if err := mergeComponentMap(&dst.Links, src.Links, "link"); err != nil {
		return err
	}
	if err := mergeComponentMap(&dst.Callbacks, src.Callbacks, "callback"); err != nil {
		return err
	}
	if err := mergeComponentMap(&dst.Extensions, src.Extensions, "extension"); err != nil {
		return err
	}

	return nil
}
```

### `mergeComponentMap`

**What:** Generic helper to merge OpenAPI component maps while rejecting duplicates.

**Why:** Component maps share the same semantics across categories (schemas, responses, headers, etc).

**How:** Ensures the destination map is initialized, then copies entries from src into dst, returning an error when a key already exists.

**Notes:** The `label` string is used only to make duplicate errors easier to interpret.

```go title="internal/openapi/service.go#L327" showLineNumbers
func mergeComponentMap[M ~map[string]V, V any](dst *M, src M, label string) error {
	if len(src) == 0 {
		return nil
	}
	if *dst == nil {
		*dst = make(M, len(src))
	}
	for key, value := range src {
		if _, exists := (*dst)[key]; exists {
			return fmt.Errorf("duplicate %s detected: %s", label, key)
		}
		(*dst)[key] = value
	}
	return nil
}
```

### `mergeTags`

**What:** Merges OpenAPI tag entries while avoiding duplicates.

**Why:** Tags are used for grouping and documentation; duplicates reduce readability.

**How:** Builds a set of existing tag names and appends only new names from the source list.

**Notes:** Nil tag entries are ignored.

```go title="internal/openapi/service.go#L343" showLineNumbers
func mergeTags(dst, src openapi3.Tags) openapi3.Tags {
	if len(src) == 0 {
		return dst
	}

	existing := make(map[string]struct{}, len(dst))
	for _, tag := range dst {
		if tag != nil {
			existing[tag.Name] = struct{}{}
		}
	}

	for _, tag := range src {
		if tag == nil {
			continue
		}
		if _, ok := existing[tag.Name]; ok {
			continue
		}
		dst = append(dst, tag)
		existing[tag.Name] = struct{}{}
	}
	return dst
}
```

### `mergeServers`

**What:** Merges OpenAPI server entries while avoiding duplicates.

**Why:** Servers may be defined in multiple fragments; duplicates are noise and can confuse readers.

**How:** Builds a set of existing server URLs and appends only new URLs from the source list.

**Notes:** Nil server entries are ignored.

```go title="internal/openapi/service.go#L368" showLineNumbers
func mergeServers(dst, src openapi3.Servers) openapi3.Servers {
	if len(src) == 0 {
		return dst
	}

	existing := make(map[string]struct{}, len(dst))
	for _, server := range dst {
		if server != nil {
			existing[server.URL] = struct{}{}
		}
	}

	for _, server := range src {
		if server == nil {
			continue
		}
		if _, ok := existing[server.URL]; ok {
			continue
		}
		dst = append(dst, server)
		existing[server.URL] = struct{}{}
	}
	return dst
}
```

### `mergeSecurity`

**What:** Merges OpenAPI security requirements slices.

**Why:** Security requirements are additive across fragments.

**How:** Appends the source requirements to the destination slice when source is non-empty.

**Notes:** This helper does not deduplicate requirements.

```go title="internal/openapi/service.go#L393" showLineNumbers
func mergeSecurity(dst, src openapi3.SecurityRequirements) openapi3.SecurityRequirements {
	if len(src) == 0 {
		return dst
	}
	return append(dst, src...)
}
```

### `resolveConfigPath`

**What:** Resolves the merge configuration path from environment or default.

**Why:** Lets operators override config location without rebuilding the binary.

**How:** Returns `OPENAPI_MERGE_CONFIG_PATH` when set; otherwise returns the default filename converted with `filepath.FromSlash`.

```go title="internal/openapi/service.go#L400" showLineNumbers
func resolveConfigPath() string {
	if path := os.Getenv("OPENAPI_MERGE_CONFIG_PATH"); path != "" {
		return path
	}
	return filepath.FromSlash(defaultConfigFile)
}
```

### `fileModTime`

**What:** Returns a file's modification time (or zero).

**Why:** Used to associate cached bytes with the on-disk dist file for freshness checks.

**How:** Stats the path and returns `info.ModTime()`; returns `time.Time{}` on stat failure.

```go title="internal/openapi/service.go#L407" showLineNumbers
func fileModTime(path string) time.Time {
	info, err := os.Stat(path)
	if err != nil {
		return time.Time{}
	}
	return info.ModTime()
}
```

### `clone`

**What:** Creates a defensive copy of a byte slice.

**Why:** Prevents callers from mutating cached document bytes returned by `Document()`.

**How:** Allocates a new slice of the same length and copies the contents.

**Notes:** Returns nil for a nil input slice.

```go title="internal/openapi/service.go#L415" showLineNumbers
func clone(src []byte) []byte {
	if src == nil {
		return nil
	}
	dst := make([]byte, len(src))
	copy(dst, src)
	return dst
}
```

