---
title: "pkg/gateway/daemon/daemon.go"
---

<!--
Generated by `go run ./cmd/docsgen`.
Do not edit this file directly.
Edit commentary in `docs/annotations/pkg/gateway/daemon/daemon.yaml`.
-->

## Source

- Package: `daemon`
- File: `pkg/gateway/daemon/daemon.go`
- GitHub: https://github.com/theroutercompany/api_router/blob/main/pkg/gateway/daemon/daemon.go

## Overview

**What:** Implements the managed "daemon" lifecycle used by the `cmd/apigw daemon` subcommands.

This package provides:
- helpers to write/read a PID file for the running process
- optional redirection of logs to a file via `APIGW_LOG_PATH`
- `Run/Status/Stop` entrypoints that the CLI can call

**Why:** The gateway supports both foreground execution and a "managed" mode that behaves like a lightweight daemon.
Operators often want:
- a deterministic PID file location for stop/status scripts
- logs written to a file for background runs
- basic safety checks (avoid overwriting an existing PID file)

Keeping this logic in a dedicated package makes the CLI implementation thin and avoids duplicating OS/process logic.

**How:** `Run()`:
- optionally writes the PID file
- optionally sets up log output by setting `APIGW_LOG_PATH`
- loads config, builds runtime, starts it, then blocks in `Wait()`

`Status()`:
- reads the PID file (if present)
- probes the process via `signal 0` to determine if it is running

`Stop()`:
- looks up the PID, sends a signal (default SIGTERM)
- waits briefly for exit, then escalates to SIGKILL if needed
- removes the PID file when the process is gone

**Notes:** PID files are best-effort. If the process is killed abruptly, the PID file may remain and `Status()`/`Stop()` handle that case.


## Imports

### `import` block 1

```go title="pkg/gateway/daemon/daemon.go#L3" showLineNumbers
import (
	"context"
	"errors"
	"fmt"
	"os"
	"os/signal"
	"path/filepath"
	"strconv"
	"strings"
	"syscall"
	"time"

	gatewayconfig "github.com/theroutercompany/api_router/pkg/gateway/config"
	gatewayruntime "github.com/theroutercompany/api_router/pkg/gateway/runtime"
)
```


## Types

### `type` block 1

```go title="pkg/gateway/daemon/daemon.go#L20" showLineNumbers
type Options struct {
	ConfigPath string
	PIDFile    string
	LogFile    string
}
```

#### `Options`

**What:** Configuration knobs for daemon lifecycle behaviour.

**Why:** Makes daemon paths explicit and keeps `Run`/`Stop` free of global configuration.

**How:** Passed from the CLI layer into `Run` (and PID/log paths into `Status`/`Stop`).

**Notes:** Empty PID/log paths disable PID/log file behaviour.

### `type` block 2

```go title="pkg/gateway/daemon/daemon.go#L27" showLineNumbers
type ProcessStatus struct {
	PID     int
	Running bool
}
```

#### `ProcessStatus`

**What:** Result type representing the daemon PID and whether it is running.

**Why:** Consolidates status checks into a single return value for the CLI and callers.

**How:** The `Status` and `Stop` functions populate this struct based on PID file contents and process probing.

**Notes:** PID can be non-zero even when `Running` is false if the PID file exists but the process is gone.


## Functions and Methods

### `Run`

**What:** Boots the gateway runtime in managed "daemon" mode.

**Why:** Provides a CLI-friendly entrypoint that handles PID/log file setup and then runs the normal runtime.

**How:** Writes the PID file, sets up the log file (if configured), loads config from `opts.ConfigPath`, constructs the runtime, starts it, and blocks on `rt.Wait()`.

**Notes:** The returned cleanup closures run only on graceful returns; hard kills can leave PID files behind.

```go title="pkg/gateway/daemon/daemon.go#L33" showLineNumbers
func Run(ctx context.Context, opts Options) error {
	cleanupPID, err := writePIDFile(opts.PIDFile)
	if err != nil {
		return err
	}
	defer cleanupPID()

	logCloser, err := setupLogFile(opts.LogFile)
	if err != nil {
		return err
	}
	defer logCloser()

	loadOpts := []gatewayconfig.Option{}
	if strings.TrimSpace(opts.ConfigPath) != "" {
		loadOpts = append(loadOpts, gatewayconfig.WithPath(opts.ConfigPath))
	}

	cfg, err := gatewayconfig.Load(loadOpts...)
	if err != nil {
		return fmt.Errorf("load config: %w", err)
	}

	rt, err := gatewayruntime.New(cfg)
	if err != nil {
		return fmt.Errorf("build runtime: %w", err)
	}

	if err := rt.Start(ctx); err != nil {
		return err
	}
	return rt.Wait()
}
```

### `Status`

**What:** Returns the current daemon PID and whether the process appears to be running.

**Why:** Enables `apigw daemon status` and shell scripts to determine if the gateway is alive.

**How:** Reads the PID file and sends `signal 0` to the process to test for existence; missing PID file returns an empty status and nil error.

**Notes:** A stale PID file (PID reused by another process) can produce false positives; this is a common PID-file limitation.

```go title="pkg/gateway/daemon/daemon.go#L68" showLineNumbers
func Status(pidPath string) (ProcessStatus, error) {
	pid, err := readPIDFile(pidPath)
	if errors.Is(err, os.ErrNotExist) {
		return ProcessStatus{}, nil
	}
	if err != nil {
		return ProcessStatus{}, err
	}

	status := ProcessStatus{PID: pid}
	proc, err := os.FindProcess(pid)
	if err != nil {
		return status, fmt.Errorf("find process: %w", err)
	}
	if err := proc.Signal(syscall.Signal(0)); err == nil {
		status.Running = true
	} else {
		status.Running = false
	}
	return status, nil
}
```

### `Stop`

**What:** Stops the daemon process referenced by the PID file.

**Why:** Enables `apigw daemon stop` and ensures PID cleanup occurs when the process is gone.

**How:** Resolves status, sends the configured signal (default SIGTERM), polls for up to ~5s, escalates to SIGKILL if still running, and removes the PID file.

**Notes:** If the process is already dead, `Stop` removes the PID file and returns without error.

```go title="pkg/gateway/daemon/daemon.go#L91" showLineNumbers
func Stop(pidPath string, sig syscall.Signal) (ProcessStatus, error) {
	if sig == 0 {
		sig = syscall.SIGTERM
	}

	status, err := Status(pidPath)
	if err != nil {
		return status, err
	}
	if status.PID == 0 {
		return status, os.ErrNotExist
	}
	if !status.Running {
		_ = os.Remove(pidPath)
		return status, nil
	}

	proc, err := os.FindProcess(status.PID)
	if err != nil {
		return status, fmt.Errorf("find process: %w", err)
	}
	if err := proc.Signal(sig); err != nil {
		return status, fmt.Errorf("signal process: %w", err)
	}

	deadline := time.Now().Add(5 * time.Second)
	for time.Now().Before(deadline) {
		time.Sleep(200 * time.Millisecond)
		st, err := Status(pidPath)
		if errors.Is(err, os.ErrNotExist) || (err == nil && !st.Running) {
			_ = os.Remove(pidPath)
			return st, nil
		}
		if err != nil {
			return status, err
		}
	}

	if sig != syscall.SIGKILL {
		if err := proc.Signal(syscall.SIGKILL); err != nil {
			return status, fmt.Errorf("force kill process: %w", err)
		}
		time.Sleep(200 * time.Millisecond)
	}
	_ = os.Remove(pidPath)
	return status, nil
}
```

### `writePIDFile`

**What:** Writes the current process PID to a file and returns a cleanup function.

**Why:** PID files are the simplest interoperability mechanism for stop/status scripts and CLI subcommands.

**How:** Ensures the directory exists, errors if the PID file already exists, writes the current PID, and returns a cleanup function that removes the file.

**Notes:** The existence check is a safety guard but cannot prevent all races across processes.

```go title="pkg/gateway/daemon/daemon.go#L139" showLineNumbers
func writePIDFile(path string) (func(), error) {
	path = strings.TrimSpace(path)
	if path == "" {
		return func() {}, nil
	}

	if err := os.MkdirAll(filepath.Dir(path), 0o755); err != nil {
		return func() {}, fmt.Errorf("ensure pid directory: %w", err)
	}

	if _, err := readPIDFile(path); err == nil {
		return func() {}, fmt.Errorf("pid file %s already exists", path)
	}

	tmp := []byte(fmt.Sprintf("%d\n", os.Getpid()))
	if err := os.WriteFile(path, tmp, 0o644); err != nil {
		return func() {}, fmt.Errorf("write pid file: %w", err)
	}

	return func() {
		_ = os.Remove(path)
	}, nil
}
```

### `readPIDFile`

**What:** Reads and parses a PID file into an integer PID.

**Why:** Centralizes PID parsing and validation so `Status` and `Stop` behave consistently.

**How:** Reads the file, trims whitespace, parses an integer, and validates the PID is positive.

**Notes:** Returns `os.ErrNotExist` when the file is missing so callers can treat "not running" as non-fatal.

```go title="pkg/gateway/daemon/daemon.go#L163" showLineNumbers
func readPIDFile(path string) (int, error) {
	path = strings.TrimSpace(path)
	if path == "" {
		return 0, fmt.Errorf("pid file path is required")
	}

	data, err := os.ReadFile(path)
	if err != nil {
		if errors.Is(err, os.ErrNotExist) {
			return 0, os.ErrNotExist
		}
		return 0, fmt.Errorf("read pid file: %w", err)
	}

	pid, err := strconv.Atoi(strings.TrimSpace(string(data)))
	if err != nil {
		return 0, fmt.Errorf("parse pid: %w", err)
	}
	if pid <= 0 {
		return 0, fmt.Errorf("invalid pid value %d", pid)
	}
	return pid, nil
}
```

### `setupLogFile`

**What:** Prepares a log file path for the process and sets the `APIGW_LOG_PATH` environment variable.

**Why:** The default logger reads `APIGW_LOG_PATH` to decide where to write logs for daemon runs.

**How:** Ensures the directory exists, opens the file for append/create, sets `APIGW_LOG_PATH`, and returns a cleanup function that closes the file.

**Notes:** Setting the env var must happen before the logger is initialised to take effect.

```go title="pkg/gateway/daemon/daemon.go#L187" showLineNumbers
func setupLogFile(path string) (func(), error) {
	path = strings.TrimSpace(path)
	if path == "" {
		return func() {}, nil
	}

	if err := os.MkdirAll(filepath.Dir(path), 0o755); err != nil {
		return func() {}, fmt.Errorf("ensure log directory: %w", err)
	}

	file, err := os.OpenFile(path, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0o644)
	if err != nil {
		return func() {}, fmt.Errorf("open log file: %w", err)
	}

	if err := os.Setenv("APIGW_LOG_PATH", path); err != nil {
		_ = file.Close()
		return func() {}, fmt.Errorf("set log env: %w", err)
	}

	return func() {
		_ = file.Close()
	}, nil
}
```

### `WaitSignal`

**What:** Blocks until a termination signal is received or the context is done.

**Why:** Allows callers to coordinate graceful shutdown on SIGTERM/SIGINT while still supporting context cancellation.

**How:** Uses `signal.Notify` for SIGTERM and SIGINT and waits for either the signal channel or `ctx.Done()`.

**Notes:** The process typically exits shortly after this returns by cancelling the runtime context.

```go title="pkg/gateway/daemon/daemon.go#L213" showLineNumbers
func WaitSignal(ctx context.Context) {
	sigCh := make(chan os.Signal, 1)
	signal.Notify(sigCh, syscall.SIGTERM, syscall.SIGINT)
	select {
	case <-ctx.Done():
	case <-sigCh:
	}
}
```

