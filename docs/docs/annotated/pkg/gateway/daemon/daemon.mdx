---
title: "pkg/gateway/daemon/daemon.go"
---

<!--
Generated by `go run ./cmd/docsgen`.
Do not edit this file directly.
Edit commentary in `docs/annotations/pkg/gateway/daemon/daemon.yaml`.
-->

## Source

- Package: `daemon`
- File: `pkg/gateway/daemon/daemon.go`
- GitHub: https://github.com/theroutercompany/api_router/blob/main/pkg/gateway/daemon/daemon.go

## Overview

**What:** This page documents the declarations in this file.

**Why:** These docs exist to make onboarding and code review faster by explaining intent, not just mechanics.

**How:** Use the sections below to jump to the symbol you care about, then follow the links back to source.


## Imports

### `import` block 1

```go title="pkg/gateway/daemon/daemon.go#L3" showLineNumbers
import (
	"context"
	"errors"
	"fmt"
	"os"
	"os/signal"
	"path/filepath"
	"strconv"
	"strings"
	"syscall"
	"time"

	gatewayconfig "github.com/theroutercompany/api_router/pkg/gateway/config"
	gatewayruntime "github.com/theroutercompany/api_router/pkg/gateway/runtime"
)
```


## Types

### `type` block 1

```go title="pkg/gateway/daemon/daemon.go#L20" showLineNumbers
type Options struct {
	ConfigPath string
	PIDFile    string
	LogFile    string
}
```

#### `Options`

**What:** Declare `type Options`.

**Why:** Centralizes behavior and avoids duplication in call sites.

**How:** See the Go snippet and the source link for behavior and usage.

### `type` block 2

```go title="pkg/gateway/daemon/daemon.go#L27" showLineNumbers
type ProcessStatus struct {
	PID     int
	Running bool
}
```

#### `ProcessStatus`

**What:** Declare `type ProcessStatus`.

**Why:** Centralizes behavior and avoids duplication in call sites.

**How:** See the Go snippet and the source link for behavior and usage.


## Functions and Methods

### `Run`

**What:** Declare `func Run`.

**Why:** Centralizes behavior and avoids duplication in call sites.

**How:** See the Go snippet and the source link for behavior and usage.

```go title="pkg/gateway/daemon/daemon.go#L33" showLineNumbers
func Run(ctx context.Context, opts Options) error {
	cleanupPID, err := writePIDFile(opts.PIDFile)
	if err != nil {
		return err
	}
	defer cleanupPID()

	logCloser, err := setupLogFile(opts.LogFile)
	if err != nil {
		return err
	}
	defer logCloser()

	loadOpts := []gatewayconfig.Option{}
	if strings.TrimSpace(opts.ConfigPath) != "" {
		loadOpts = append(loadOpts, gatewayconfig.WithPath(opts.ConfigPath))
	}

	cfg, err := gatewayconfig.Load(loadOpts...)
	if err != nil {
		return fmt.Errorf("load config: %w", err)
	}

	rt, err := gatewayruntime.New(cfg)
	if err != nil {
		return fmt.Errorf("build runtime: %w", err)
	}

	if err := rt.Start(ctx); err != nil {
		return err
	}
	return rt.Wait()
}
```

### `Status`

**What:** Declare `func Status`.

**Why:** Centralizes behavior and avoids duplication in call sites.

**How:** See the Go snippet and the source link for behavior and usage.

```go title="pkg/gateway/daemon/daemon.go#L68" showLineNumbers
func Status(pidPath string) (ProcessStatus, error) {
	pid, err := readPIDFile(pidPath)
	if errors.Is(err, os.ErrNotExist) {
		return ProcessStatus{}, nil
	}
	if err != nil {
		return ProcessStatus{}, err
	}

	status := ProcessStatus{PID: pid}
	proc, err := os.FindProcess(pid)
	if err != nil {
		return status, fmt.Errorf("find process: %w", err)
	}
	if err := proc.Signal(syscall.Signal(0)); err == nil {
		status.Running = true
	} else {
		status.Running = false
	}
	return status, nil
}
```

### `Stop`

**What:** Declare `func Stop`.

**Why:** Centralizes behavior and avoids duplication in call sites.

**How:** See the Go snippet and the source link for behavior and usage.

```go title="pkg/gateway/daemon/daemon.go#L91" showLineNumbers
func Stop(pidPath string, sig syscall.Signal) (ProcessStatus, error) {
	if sig == 0 {
		sig = syscall.SIGTERM
	}

	status, err := Status(pidPath)
	if err != nil {
		return status, err
	}
	if status.PID == 0 {
		return status, os.ErrNotExist
	}
	if !status.Running {
		_ = os.Remove(pidPath)
		return status, nil
	}

	proc, err := os.FindProcess(status.PID)
	if err != nil {
		return status, fmt.Errorf("find process: %w", err)
	}
	if err := proc.Signal(sig); err != nil {
		return status, fmt.Errorf("signal process: %w", err)
	}

	deadline := time.Now().Add(5 * time.Second)
	for time.Now().Before(deadline) {
		time.Sleep(200 * time.Millisecond)
		st, err := Status(pidPath)
		if errors.Is(err, os.ErrNotExist) || (err == nil && !st.Running) {
			_ = os.Remove(pidPath)
			return st, nil
		}
		if err != nil {
			return status, err
		}
	}

	if sig != syscall.SIGKILL {
		if err := proc.Signal(syscall.SIGKILL); err != nil {
			return status, fmt.Errorf("force kill process: %w", err)
		}
		time.Sleep(200 * time.Millisecond)
	}
	_ = os.Remove(pidPath)
	return status, nil
}
```

### `writePIDFile`

**What:** Declare `func writePIDFile`.

**Why:** Centralizes behavior and avoids duplication in call sites.

**How:** See the Go snippet and the source link for behavior and usage.

```go title="pkg/gateway/daemon/daemon.go#L139" showLineNumbers
func writePIDFile(path string) (func(), error) {
	path = strings.TrimSpace(path)
	if path == "" {
		return func() {}, nil
	}

	if err := os.MkdirAll(filepath.Dir(path), 0o755); err != nil {
		return func() {}, fmt.Errorf("ensure pid directory: %w", err)
	}

	if _, err := readPIDFile(path); err == nil {
		return func() {}, fmt.Errorf("pid file %s already exists", path)
	}

	tmp := []byte(fmt.Sprintf("%d\n", os.Getpid()))
	if err := os.WriteFile(path, tmp, 0o644); err != nil {
		return func() {}, fmt.Errorf("write pid file: %w", err)
	}

	return func() {
		_ = os.Remove(path)
	}, nil
}
```

### `readPIDFile`

**What:** Declare `func readPIDFile`.

**Why:** Centralizes behavior and avoids duplication in call sites.

**How:** See the Go snippet and the source link for behavior and usage.

```go title="pkg/gateway/daemon/daemon.go#L163" showLineNumbers
func readPIDFile(path string) (int, error) {
	path = strings.TrimSpace(path)
	if path == "" {
		return 0, fmt.Errorf("pid file path is required")
	}

	data, err := os.ReadFile(path)
	if err != nil {
		if errors.Is(err, os.ErrNotExist) {
			return 0, os.ErrNotExist
		}
		return 0, fmt.Errorf("read pid file: %w", err)
	}

	pid, err := strconv.Atoi(strings.TrimSpace(string(data)))
	if err != nil {
		return 0, fmt.Errorf("parse pid: %w", err)
	}
	if pid <= 0 {
		return 0, fmt.Errorf("invalid pid value %d", pid)
	}
	return pid, nil
}
```

### `setupLogFile`

**What:** Declare `func setupLogFile`.

**Why:** Centralizes behavior and avoids duplication in call sites.

**How:** See the Go snippet and the source link for behavior and usage.

```go title="pkg/gateway/daemon/daemon.go#L187" showLineNumbers
func setupLogFile(path string) (func(), error) {
	path = strings.TrimSpace(path)
	if path == "" {
		return func() {}, nil
	}

	if err := os.MkdirAll(filepath.Dir(path), 0o755); err != nil {
		return func() {}, fmt.Errorf("ensure log directory: %w", err)
	}

	file, err := os.OpenFile(path, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0o644)
	if err != nil {
		return func() {}, fmt.Errorf("open log file: %w", err)
	}

	if err := os.Setenv("APIGW_LOG_PATH", path); err != nil {
		_ = file.Close()
		return func() {}, fmt.Errorf("set log env: %w", err)
	}

	return func() {
		_ = file.Close()
	}, nil
}
```

### `WaitSignal`

**What:** Declare `func WaitSignal`.

**Why:** Centralizes behavior and avoids duplication in call sites.

**How:** See the Go snippet and the source link for behavior and usage.

```go title="pkg/gateway/daemon/daemon.go#L213" showLineNumbers
func WaitSignal(ctx context.Context) {
	sigCh := make(chan os.Signal, 1)
	signal.Notify(sigCh, syscall.SIGTERM, syscall.SIGINT)
	select {
	case <-ctx.Done():
	case <-sigCh:
	}
}
```

