---
title: "pkg/gateway/server/middleware/middleware.go"
---

<!--
Generated by `go run ./cmd/docsgen`.
Do not edit this file directly.
Edit commentary in `docs/annotations/pkg/gateway/server/middleware/middleware.yaml`.
-->

## Source

- Package: `middleware`
- File: `pkg/gateway/server/middleware/middleware.go`
- GitHub: https://github.com/theroutercompany/api_router/blob/main/pkg/gateway/server/middleware/middleware.go

## Overview

**What:** A collection of HTTP middleware functions used by the gateway server.

The middleware in this file covers common cross-cutting concerns:
- request/trace ID propagation to responses
- baseline security headers
- request body size limits
- per-client rate limiting
- CORS enforcement
- structured request logging and protocol metrics integration (including upgraded connections)

**Why:** Middleware is the "seam" where the gateway enforces platform policy consistently for every request.

This package keeps the middleware logic decoupled from specific implementations by expressing its
dependencies as small interfaces and function types (logger, problem writer, ID generators,
rate-limit allow/key functions, protocol metric callbacks).

That design makes it easier to:
- unit test the middleware in isolation
- swap implementations (e.g., different logging backend)
- compose a server pipeline without creating import cycles

**How:** Each exported middleware constructor returns a standard wrapper:
`func(http.Handler) http.Handler`.

Callers (typically `pkg/gateway/server`) build a chain by composing these wrappers.
Many middleware functions are intentionally nil-safe: if a required dependency is not provided,
they return an identity wrapper (or the next handler) to keep server wiring simple.

The `Logging` middleware uses a custom `ResponseWriter` wrapper to:
- capture status code and bytes written
- support `Flush`/`Push` passthrough
- intercept `Hijack()` so upgraded connections can be wrapped and tracked on close

**Notes:** Be careful about logging sensitive data. This middleware logs request path and metadata, not bodies.
Body size limits use both `Content-Length` checks and `http.MaxBytesReader` for enforcement.


## Imports

### `import` block 1

```go title="pkg/gateway/server/middleware/middleware.go#L3" showLineNumbers
import (
	"bufio"
	"context"
	"errors"
	"fmt"
	"net"
	"net/http"
	"strings"
	"sync"
	"time"

	"github.com/rs/cors"
)
```


## Types

### `type` block 1

```go title="pkg/gateway/server/middleware/middleware.go#L18" showLineNumbers
type Logger interface {
	Infow(msg string, keysAndValues ...any)
	Warnw(msg string, keysAndValues ...any)
	Errorw(msg string, keysAndValues ...any)
}
```

#### `Logger`

**What:** Minimal logger interface required by middleware.

**Why:** Avoids importing the full logging package and prevents dependency cycles.

**How:** Implemented by `pkg/log.Logger` adapters and passed into `Logging`.

**Notes:** Uses Zap-style `*w` methods (message plus key/value fields).

### `type` block 2

```go title="pkg/gateway/server/middleware/middleware.go#L25" showLineNumbers
type ProblemWriter func(w http.ResponseWriter, status int, title, detail, traceID, instance string)
```

#### `ProblemWriter`

**What:** Function that writes a problem+json response.

**Why:** Centralizes error response formatting so middleware can emit consistent error bodies.

**How:** Called by `BodyLimit`, `RateLimit`, and `CORS` when provided; otherwise those middleware fall back to `http.Error`.

### `type` block 3

```go title="pkg/gateway/server/middleware/middleware.go#L28" showLineNumbers
type EnsureIDs func(*http.Request) (*http.Request, string, string)
```

#### `EnsureIDs`

**What:** Function type that ensures a request has request/trace identifiers.

**Why:** ID generation/extraction is owned by higher-level middleware or tracing systems, not by this package.

**How:** Returns an updated request (if needed) plus request ID and trace ID strings.

### `type` block 4

```go title="pkg/gateway/server/middleware/middleware.go#L31" showLineNumbers
type TraceIDFromContext func(context.Context) string
```

#### `TraceIDFromContext`

**What:** Extractor that reads a trace ID from a context.

**Why:** Logging and problem responses often want trace IDs for correlation, but the storage mechanism is owned elsewhere.

**How:** Called by `Logging` and by error middleware to include trace IDs when available.

### `type` block 5

```go title="pkg/gateway/server/middleware/middleware.go#L34" showLineNumbers
type RequestIDFromContext func(context.Context) string
```

#### `RequestIDFromContext`

**What:** Extractor that reads a request ID from a context.

**Why:** Logging should not know how IDs are stored in context.

**How:** Called by `Logging` to add `requestId` field when non-empty.

### `type` block 6

```go title="pkg/gateway/server/middleware/middleware.go#L37" showLineNumbers
type ClientAddress func(*http.Request) string
```

#### `ClientAddress`

**What:** Extractor that resolves a client address string from an HTTP request.

**Why:** Logging should record a stable client identifier without hardcoding a specific proxy/header strategy.

**How:** Used by `Logging` to optionally append a `remoteAddr` field.

**Notes:** Implementations typically consult `X-Forwarded-For` and `X-Real-IP` in addition to `RemoteAddr`.

### `type` block 7

```go title="pkg/gateway/server/middleware/middleware.go#L40" showLineNumbers
type TrackFunc func(*http.Request) func(status int, elapsed time.Duration)
```

#### `TrackFunc`

**What:** Callback that returns a per-request metric recording function.

**Why:** Allows middleware to time requests and record metrics without importing Prometheus packages.

**How:** Called at request start; the returned function is called at request end with status and elapsed duration.

### `type` block 8

```go title="pkg/gateway/server/middleware/middleware.go#L43" showLineNumbers
type HijackedFunc func(*http.Request) (func(), func(net.Conn) net.Conn)
```

#### `HijackedFunc`

**What:** Callback used to integrate upgraded-connection tracking and wrapping into the logging middleware.

**Why:** Upgraded connections need lifetime hooks (close callbacks) and sometimes need connection wrapping (timeouts, tracking, limits).

**How:** Called from `loggingResponseWriter.Hijack()` and returns an on-close callback plus an optional `net.Conn` wrapper.

**Notes:** The wrapper is applied before the on-close tracking wrapper.

### `type` block 9

```go title="pkg/gateway/server/middleware/middleware.go#L46" showLineNumbers
type AllowFunc func(key string, now time.Time) bool
```

#### `AllowFunc`

**What:** Function type that decides whether a rate-limit key is allowed at a given time.

**Why:** Decouples middleware from any specific rate limiter implementation.

**How:** Called by `RateLimit` with a derived key and a timestamp.

### `type` block 10

```go title="pkg/gateway/server/middleware/middleware.go#L49" showLineNumbers
type ClientKey func(*http.Request) string
```

#### `ClientKey`

**What:** Function type that derives a rate-limit key from a request.

**Why:** Allows the rate limiting policy to choose between IP-based keys, API keys, JWT subjects, etc.

**How:** Used by `RateLimit` before calling `AllowFunc`.

### `type` block 11

```go title="pkg/gateway/server/middleware/middleware.go#L249" showLineNumbers
type loggingResponseWriter struct {
	http.ResponseWriter
	status        int
	bytes         int
	hijackTracker func() (func(), func(net.Conn) net.Conn)
	hijackOnce    sync.Once
}
```

#### `loggingResponseWriter`

**What:** An `http.ResponseWriter` wrapper that captures status/bytes and supports hijack tracking.

**Why:** The standard interface does not expose status codes or byte counts, and upgraded connections need lifecycle hooks.

**How:** Embeds the underlying writer and intercepts `WriteHeader`, `Write`, and `Hijack`.

### `type` block 12

```go title="pkg/gateway/server/middleware/middleware.go#L319" showLineNumbers
type trackingConn struct {
	net.Conn
	onClose func()
	once    sync.Once
	timeout time.Duration
}
```

#### `trackingConn`

**What:** Connection wrapper used to invoke an on-close callback once.

**Why:** Connection lifetime metrics and accounting require a reliable "closed" signal.

**How:** Wraps a `net.Conn`, delegates most operations, and calls `onClose` via `sync.Once` in `Close()`.

**Notes:** Also includes optional read/write deadline enforcement when `timeout` is set.


## Functions and Methods

### `RequestMetadata`

**What:** Ensures every request has stable IDs and echoes them back in response headers.

**Why:** Request/trace IDs are foundational for debugging, log correlation, and distributed tracing.

**How:** Calls the injected `EnsureIDs` function to obtain a possibly-updated request and IDs, then sets `X-Request-Id` and `X-Trace-Id` headers before calling the next handler.

**Notes:** If `ensure` is nil, this middleware becomes a no-op wrapper.

```go title="pkg/gateway/server/middleware/middleware.go#L52" showLineNumbers
func RequestMetadata(ensure EnsureIDs) func(http.Handler) http.Handler {
	if ensure == nil {
		return func(next http.Handler) http.Handler { return next }
	}

	return func(next http.Handler) http.Handler {
		if next == nil {
			return http.HandlerFunc(func(http.ResponseWriter, *http.Request) {})
		}
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			req, requestID, traceID := ensure(r)
			w.Header().Set("X-Request-Id", requestID)
			if traceID != "" {
				w.Header().Set("X-Trace-Id", traceID)
			}
			next.ServeHTTP(w, req)
		})
	}
}
```

### `SecurityHeaders`

**What:** Adds baseline security hardening headers to all responses.

**Why:** Many responses are proxied, but the gateway still acts as the edge and should provide consistent browser hardening defaults.

**How:** Sets headers like `X-Content-Type-Options`, `X-Frame-Options`, `Referrer-Policy`, and `Permissions-Policy` before calling the next handler.

**Notes:** These headers are conservative defaults. If you need CSP/HSTS, add them at a higher layer with environment-specific configuration.

```go title="pkg/gateway/server/middleware/middleware.go#L73" showLineNumbers
func SecurityHeaders() func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		if next == nil {
			return http.HandlerFunc(func(http.ResponseWriter, *http.Request) {})
		}
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			headers := w.Header()
			headers.Set("X-Content-Type-Options", "nosniff")
			headers.Set("X-Frame-Options", "DENY")
			headers.Set("Referrer-Policy", "no-referrer")
			headers.Set("Permissions-Policy", "geolocation=(), microphone=(), camera=()")
			next.ServeHTTP(w, r)
		})
	}
}
```

### `BodyLimit`

**What:** Enforces a maximum request body size.

**Why:** Protects the gateway from accidental or malicious large payloads that can consume memory and upstream bandwidth.

**How:** Rejects requests with `Content-Length` above the limit with 413; otherwise wraps `r.Body` with `http.MaxBytesReader` so reads cannot exceed the limit.

**Notes:** If `Content-Length` is unknown (`-1`), the MaxBytesReader path is the enforcement mechanism.

```go title="pkg/gateway/server/middleware/middleware.go#L90" showLineNumbers
func BodyLimit(limit int64, trace TraceIDFromContext, write ProblemWriter) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		if next == nil {
			return http.HandlerFunc(func(http.ResponseWriter, *http.Request) {})
		}
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			if r.ContentLength > limit {
				tid := ""
				if trace != nil {
					tid = trace(r.Context())
				}
				if write != nil {
					write(w, http.StatusRequestEntityTooLarge, "Payload Too Large", fmt.Sprintf("Request body exceeds %d bytes", limit), tid, r.URL.Path)
					return
				}
				http.Error(w, http.StatusText(http.StatusRequestEntityTooLarge), http.StatusRequestEntityTooLarge)
				return
			}
			if r.Body != nil {
				r.Body = http.MaxBytesReader(w, r.Body, limit)
			}
			next.ServeHTTP(w, r)
		})
	}
}
```

### `RateLimit`

**What:** Enforces per-client rate limiting.

**Why:** Provides a safety valve against abusive clients and protects upstream services from burst load.

**How:** Uses a provided `AllowFunc` (rate-limit decision) and `ClientKey` (key derivation). OPTIONS requests bypass the limiter. Exceeded limits return 429 with a problem response when available.

**Notes:** The middleware is deliberately generic; the actual limiter implementation lives elsewhere.

```go title="pkg/gateway/server/middleware/middleware.go#L117" showLineNumbers
func RateLimit(allow AllowFunc, key ClientKey, now func() time.Time, trace TraceIDFromContext, write ProblemWriter) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		if next == nil || allow == nil || key == nil || now == nil {
			return next
		}
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			if r.Method == http.MethodOptions {
				next.ServeHTTP(w, r)
				return
			}
			client := key(r)
			if allow(client, now()) {
				next.ServeHTTP(w, r)
				return
			}
			if write != nil {
				tid := ""
				if trace != nil {
					tid = trace(r.Context())
				}
				write(w, http.StatusTooManyRequests, "Too Many Requests", "Rate limit exceeded", tid, r.URL.Path)
			} else {
				http.Error(w, http.StatusText(http.StatusTooManyRequests), http.StatusTooManyRequests)
			}
		})
	}
}
```

### `CORS`

**What:** Applies CORS policy using the provided `*cors.Cors` configuration.

**Why:** Browsers enforce CORS, and the gateway needs to provide a centralized origin policy across all proxied endpoints.

**How:** Wraps the next handler with `handler.Handler(next)` and pre-checks `OriginAllowed` so disallowed origins can return a consistent 403 problem response.

**Notes:** The explicit origin check exists so operators get clear feedback instead of relying on default cors library behaviour.

```go title="pkg/gateway/server/middleware/middleware.go#L146" showLineNumbers
func CORS(handler *cors.Cors, trace TraceIDFromContext, write ProblemWriter) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		if handler == nil || next == nil {
			return next
		}
		corsHandler := handler.Handler(next)
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			origin := strings.TrimSpace(r.Header.Get("Origin"))
			if origin != "" && !handler.OriginAllowed(r) {
				if write != nil {
					tid := ""
					if trace != nil {
						tid = trace(r.Context())
					}
					write(w, http.StatusForbidden, "Not allowed by CORS", fmt.Sprintf("Origin %s is not allowed", origin), tid, r.URL.Path)
				} else {
					http.Error(w, http.StatusText(http.StatusForbidden), http.StatusForbidden)
				}
				return
			}
			corsHandler.ServeHTTP(w, r)
		})
	}
}
```

### `Logging`

**What:** Emits structured logs for each HTTP request and optionally integrates protocol metrics tracking.

**Why:** Request logs are the primary operational visibility mechanism for the gateway.
Integrating protocol metrics here keeps metrics emission aligned with request lifecycle and avoids duplicating timing logic.

**How:** - Records start time and builds a `trackFn` by calling `track(r)` (if provided).
- Wraps the `ResponseWriter` with `loggingResponseWriter` to capture status and bytes.
- Calls `next.ServeHTTP`.
- Computes elapsed duration and calls `trackFn(status, duration)`.
- Logs a message with standard fields (method, path, status, durationMs, bytesWritten) and optional requestId/traceId/remoteAddr.

When `hijacked` is provided, the response writer's `Hijack()` path calls it to obtain:
- an on-close callback (for metrics)
- an optional `net.Conn` wrapper (for deadline enforcement or additional tracking)

**Notes:** Logging level is chosen by status code (5xx error, 4xx warn, otherwise info).
Avoid adding headers or bodies to logs unless they are explicitly scrubbed.

```go title="pkg/gateway/server/middleware/middleware.go#L172" showLineNumbers
func Logging(
	logger Logger,
	track TrackFunc,
	hijacked HijackedFunc,
	requestID RequestIDFromContext,
	traceID TraceIDFromContext,
	clientAddr ClientAddress,
) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		if next == nil || logger == nil {
			return next
		}

		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			start := time.Now()

			trackFn := func(int, time.Duration) {}
			if track != nil {
				if fn := track(r); fn != nil {
					trackFn = fn
				}
			}

			var hijackTracker func() (func(), func(net.Conn) net.Conn)
			if hijacked != nil {
				hijackTracker = func() (func(), func(net.Conn) net.Conn) {
					return hijacked(r)
				}
			}

			writer := newLoggingResponseWriter(w, hijackTracker)
			next.ServeHTTP(writer, r)

			duration := time.Since(start)
			status := writer.status
			if status == 0 {
				status = http.StatusOK
			}

			trackFn(status, duration)

			fields := []any{
				"method", r.Method,
				"path", r.URL.Path,
				"status", status,
				"durationMs", float64(duration.Microseconds()) / 1000.0,
				"bytesWritten", writer.bytes,
			}

			if requestID != nil {
				if rid := requestID(r.Context()); rid != "" {
					fields = append(fields, "requestId", rid)
				}
			}
			if traceID != nil {
				if tid := traceID(r.Context()); tid != "" {
					fields = append(fields, "traceId", tid)
				}
			}
			if clientAddr != nil {
				if remote := clientAddr(r); remote != "" {
					fields = append(fields, "remoteAddr", remote)
				}
			}

			switch {
			case status >= 500:
				logger.Errorw("http request completed", fields...)
			case status >= 400:
				logger.Warnw("http request completed", fields...)
			default:
				logger.Infow("http request completed", fields...)
			}
		})
	}
}
```

### `newLoggingResponseWriter`

**What:** Constructs a `loggingResponseWriter` wrapper.

**Why:** Centralizes the initialization defaults (status = 200) and dependency injection for hijack tracking.

**How:** Stores the underlying response writer and the optional hijack tracker function.

```go title="pkg/gateway/server/middleware/middleware.go#L257" showLineNumbers
func newLoggingResponseWriter(w http.ResponseWriter, tracker func() (func(), func(net.Conn) net.Conn)) *loggingResponseWriter {
	return &loggingResponseWriter{
		ResponseWriter: w,
		status:         http.StatusOK,
		hijackTracker:  tracker,
	}
}
```

### `(*loggingResponseWriter).WriteHeader`

**What:** Captures the status code while delegating header writes.

**Why:** Status code is needed for both logs and metrics.

**How:** Stores the status code then calls the underlying `WriteHeader`.

```go title="pkg/gateway/server/middleware/middleware.go#L265" showLineNumbers
func (w *loggingResponseWriter) WriteHeader(status int) {
	w.status = status
	w.ResponseWriter.WriteHeader(status)
}
```

### `(*loggingResponseWriter).Write`

**What:** Captures bytes written while delegating response writes.

**Why:** Byte counts are useful for operational logs and for debugging unexpectedly large responses.

**How:** Ensures a default status exists, calls the underlying `Write`, and accumulates the byte count.

```go title="pkg/gateway/server/middleware/middleware.go#L270" showLineNumbers
func (w *loggingResponseWriter) Write(b []byte) (int, error) {
	if w.status == 0 {
		w.status = http.StatusOK
	}
	n, err := w.ResponseWriter.Write(b)
	w.bytes += n
	return n, err
}
```

### `(*loggingResponseWriter).Flush`

**What:** Implements `http.Flusher` when the underlying writer supports it.

**Why:** Some responses (streaming/SSE) require flush support; the wrapper should not break that behaviour.

**How:** Type-asserts to `http.Flusher` and delegates.

```go title="pkg/gateway/server/middleware/middleware.go#L279" showLineNumbers
func (w *loggingResponseWriter) Flush() {
	if flusher, ok := w.ResponseWriter.(http.Flusher); ok {
		flusher.Flush()
	}
}
```

### `(*loggingResponseWriter).Hijack`

**What:** Implements `http.Hijacker` and integrates upgraded-connection tracking.

**Why:** Websockets and other upgrades require hijacking; the gateway also wants to track upgraded connection lifetime for metrics and limits.

**How:** Delegates to the underlying `http.Hijacker`, then (optionally) calls the configured hijack tracker once to obtain an on-close callback and a connection wrapper; wraps the returned `net.Conn` accordingly.

**Notes:** If the underlying writer does not support hijacking, returns an explicit error.

```go title="pkg/gateway/server/middleware/middleware.go#L285" showLineNumbers
func (w *loggingResponseWriter) Hijack() (net.Conn, *bufio.ReadWriter, error) {
	hijacker, ok := w.ResponseWriter.(http.Hijacker)
	if !ok {
		return nil, nil, errors.New("hijacker not supported")
	}
	conn, rw, err := hijacker.Hijack()
	if err != nil {
		return nil, nil, err
	}

	if w.hijackTracker != nil {
		var closer func()
		var wrapper func(net.Conn) net.Conn
		w.hijackOnce.Do(func() {
			closer, wrapper = w.hijackTracker()
		})
		if wrapper != nil {
			conn = wrapper(conn)
		}
		if closer != nil {
			conn = &trackingConn{Conn: conn, onClose: closer}
		}
	}

	return conn, rw, nil
}
```

### `(*loggingResponseWriter).Push`

**What:** Implements `http.Pusher` when the underlying writer supports it.

**Why:** Preserves HTTP/2 server push support when enabled by downstream handlers (rare for the gateway, but safe to support).

**How:** Delegates to `http.Pusher.Push` or returns `http.ErrNotSupported`.

```go title="pkg/gateway/server/middleware/middleware.go#L312" showLineNumbers
func (w *loggingResponseWriter) Push(target string, opts *http.PushOptions) error {
	if pusher, ok := w.ResponseWriter.(http.Pusher); ok {
		return pusher.Push(target, opts)
	}
	return http.ErrNotSupported
}
```

### `(*trackingConn).Close`

**What:** Closes the underlying connection and runs the on-close callback once.

**Why:** Upgraded connections can outlive the HTTP request; metrics/accounting must decrement when the connection actually closes.

**How:** Delegates to `Conn.Close`, then uses `sync.Once` to invoke `onClose` a single time.

```go title="pkg/gateway/server/middleware/middleware.go#L326" showLineNumbers
func (c *trackingConn) Close() error {
	err := c.Conn.Close()
	c.once.Do(func() {
		if c.onClose != nil {
			c.onClose()
		}
	})
	return err
}
```

### `(*trackingConn).Read`

**What:** Reads from the underlying connection with optional deadline enforcement.

**Why:** Deadline enforcement can protect the gateway from idle upgraded connections when configured.

**How:** If `timeout` is non-zero, sets a read deadline before calling `Conn.Read`.

**Notes:** This wrapper is currently constructed with a zero timeout in this package; provide a custom wrapper via `HijackedFunc` for idle enforcement.

```go title="pkg/gateway/server/middleware/middleware.go#L336" showLineNumbers
func (c *trackingConn) Read(b []byte) (int, error) {
	if c.timeout > 0 {
		_ = c.Conn.SetReadDeadline(time.Now().Add(c.timeout))
	}
	return c.Conn.Read(b)
}
```

### `(*trackingConn).Write`

**What:** Writes to the underlying connection with optional deadline enforcement.

**Why:** Mirrors the read path for symmetry and supports enforcing write-side timeouts when configured.

**How:** If `timeout` is non-zero, sets a write deadline before calling `Conn.Write`.

**Notes:** This wrapper is currently constructed with a zero timeout in this package; provide a custom wrapper via `HijackedFunc` for idle enforcement.

```go title="pkg/gateway/server/middleware/middleware.go#L343" showLineNumbers
func (c *trackingConn) Write(b []byte) (int, error) {
	if c.timeout > 0 {
		_ = c.Conn.SetWriteDeadline(time.Now().Add(c.timeout))
	}
	return c.Conn.Write(b)
}
```

