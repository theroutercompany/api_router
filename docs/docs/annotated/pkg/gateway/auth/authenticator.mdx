---
title: "pkg/gateway/auth/authenticator.go"
---

<!--
Generated by `go run ./cmd/docsgen`.
Do not edit this file directly.
Edit commentary in `docs/annotations/pkg/gateway/auth/authenticator.yaml`.
-->

## Source

- Package: `auth`
- File: `pkg/gateway/auth/authenticator.go`
- GitHub: https://github.com/theroutercompany/api_router/blob/main/pkg/gateway/auth/authenticator.go

## Overview

**What:** Implements JWT-based authentication for the gateway using bearer tokens.

**Why:** Trade/task proxy routes require consistent authentication and scope enforcement that is reusable across the runtime and embedding scenarios.

**How:** Parses the Authorization header, validates an HS256 JWT using a shared secret, optionally enforces issuer/audience, and returns a `Principal` with extracted scopes.

**Notes:** Do not log raw tokens or secrets. This authenticator is designed around symmetric HS256 verification.


## Imports

### `import` block 1

```go title="pkg/gateway/auth/authenticator.go#L8" showLineNumbers
import (
	"errors"
	"net/http"
	"strings"

	"github.com/golang-jwt/jwt/v5"

	gatewayconfig "github.com/theroutercompany/api_router/pkg/gateway/config"
)
```


## Variables

### `var` block 1

```go title="pkg/gateway/auth/authenticator.go#L39" showLineNumbers
var (
	errMissingAuthorization = Error{Status: http.StatusUnauthorized, Title: "Authentication Required", Detail: "Missing authorization header"}
	errMalformedHeader      = Error{Status: http.StatusUnauthorized, Title: "Authentication Required", Detail: "Malformed authorization header"}
	errTokenInvalid         = Error{Status: http.StatusUnauthorized, Title: "Authentication Required", Detail: "Invalid or expired token"}
)
```

#### `errMissingAuthorization`

**What:** Auth error returned when the Authorization header is missing.

**Why:** Provides a consistent 401 error for unauthenticated requests.

**How:** Returned by `Authenticate` when the header is empty.

#### `errMalformedHeader`

**What:** Auth error returned when the Authorization header is not a valid Bearer token format.

**Why:** Separates "no header" from "bad header" to aid debugging and consistent messaging.

**How:** Returned by `Authenticate` when the header does not split into `Bearer <token>`.

#### `errTokenInvalid`

**What:** Auth error returned when the token cannot be validated or is not valid.

**Why:** Avoids leaking low-level JWT parse errors while still returning a consistent 401 response.

**How:** Returned by `Authenticate` for invalid tokens and by `parseToken` when `token.Valid` is false.


## Types

### `type` block 1

```go title="pkg/gateway/auth/authenticator.go#L19" showLineNumbers
type Principal struct {
	Subject string
	Scopes  []string
	Token   string
}
```

#### `Principal`

**What:** Represents an authenticated caller (subject + scopes + token string).

**Why:** Downstream authorization decisions need a normalized view of identity and permissions.

**How:** Constructed from validated JWT claims and then used for scope checks and request metadata.

### `type` block 2

```go title="pkg/gateway/auth/authenticator.go#L26" showLineNumbers
type Error struct {
	Status int
	Title  string
	Detail string
}
```

#### `Error`

**What:** Structured authentication error including HTTP status and error messaging.

**Why:** Server code needs to map auth failures to correct HTTP responses (401 vs 403, etc.) with stable titles/details.

**How:** Returned by auth helpers and handled specially by server error writers.

### `type` block 3

```go title="pkg/gateway/auth/authenticator.go#L46" showLineNumbers
type Authenticator struct {
	secret    []byte
	audiences []string
	issuer    string
}
```

#### `Authenticator`

**What:** Validates JWT bearer tokens and produces principals.

**Why:** Encapsulates auth policy (secret, audiences, issuer) and avoids spreading JWT verification across handlers.

**How:** Stores the secret bytes and optional issuer/audience constraints and exposes `Authenticate`.

### `type` block 4

```go title="pkg/gateway/auth/authenticator.go#L136" showLineNumbers
type gatewayClaims struct {
	Scope string   `json:"scope"`
	Scp   []string `json:"scp"`
	jwt.RegisteredClaims
}
```

#### `gatewayClaims`

**What:** JWT claims struct that supports both `scope` and `scp` scope encodings.

**Why:** Different issuers encode scopes differently; the gateway supports both formats for compatibility.

**How:** Embeds `jwt.RegisteredClaims` and adds fields for scope extraction.


## Functions and Methods

### `(Error).Error`

**What:** Implements the `error` interface for auth errors.

**Why:** Allows auth failures to carry HTTP status and user-facing titles/details while still behaving like errors.

**How:** Returns `Detail` when non-empty, otherwise returns `Title`.

```go title="pkg/gateway/auth/authenticator.go#L32" showLineNumbers
func (e Error) Error() string {
	if e.Detail != "" {
		return e.Detail
	}
	return e.Title
}
```

### `New`

**What:** Constructs an `Authenticator` from `gatewayconfig.AuthConfig`.

**Why:** Centralizes validation of required auth inputs and converts config into runtime-ready fields.

**How:** Requires a non-empty secret and stores secret bytes, audiences, and issuer on the authenticator.

```go title="pkg/gateway/auth/authenticator.go#L53" showLineNumbers
func New(cfg gatewayconfig.AuthConfig) (*Authenticator, error) {
	if cfg.Secret == "" {
		return nil, errors.New("jwt secret not configured")
	}

	return &Authenticator{
		secret:    []byte(cfg.Secret),
		audiences: cfg.Audiences,
		issuer:    cfg.Issuer,
	}, nil
}
```

### `(*Authenticator).Authenticate`

**What:** Validates the request's bearer token and returns a `Principal`.

**Why:** Callers (server middleware/handlers) need a single function that handles header parsing plus token validation.

**How:** Reads the Authorization header, enforces the Bearer format, delegates JWT validation to `parseToken`, then attaches the raw token string to the returned principal.

```go title="pkg/gateway/auth/authenticator.go#L66" showLineNumbers
func (a *Authenticator) Authenticate(r *http.Request) (*Principal, error) {
	header := r.Header.Get("Authorization")
	if header == "" {
		return nil, errMissingAuthorization
	}

	parts := strings.SplitN(header, " ", 2)
	if len(parts) != 2 || !strings.EqualFold(parts[0], "Bearer") {
		return nil, errMalformedHeader
	}

	tokenString := strings.TrimSpace(parts[1])
	if tokenString == "" {
		return nil, errMalformedHeader
	}

	principal, err := a.parseToken(tokenString)
	if err != nil {
		var authErr Error
		if errors.As(err, &authErr) {
			return nil, authErr
		}
		return nil, errTokenInvalid
	}

	principal.Token = tokenString
	return principal, nil
}
```

### `(*Authenticator).parseToken`

**What:** Parses and validates a JWT token string and extracts identity/scope information.

**Why:** Keeps JWT library usage isolated and allows `Authenticate` to focus on HTTP concerns.

**How:** Creates a JWT parser with HS256-only, optional audience/issuer enforcement, parses into `gatewayClaims`, checks validity, and returns a `Principal` with subject and scopes.

```go title="pkg/gateway/auth/authenticator.go#L95" showLineNumbers
func (a *Authenticator) parseToken(tokenString string) (*Principal, error) {
	options := []jwt.ParserOption{jwt.WithValidMethods([]string{jwt.SigningMethodHS256.Alg()})}
	if len(a.audiences) > 0 {
		options = append(options, jwt.WithAudience(a.audiences...))
	}
	if a.issuer != "" {
		options = append(options, jwt.WithIssuer(a.issuer))
	}

	parser := jwt.NewParser(options...)
	claims := &gatewayClaims{}

	token, err := parser.ParseWithClaims(tokenString, claims, func(_ *jwt.Token) (interface{}, error) {
		return a.secret, nil
	})
	if err != nil {
		return nil, Error{Status: http.StatusUnauthorized, Title: "Authentication Required", Detail: err.Error()}
	}

	if !token.Valid {
		return nil, errTokenInvalid
	}

	principal := &Principal{
		Subject: claims.Subject,
		Scopes:  claims.Scopes(),
	}
	return principal, nil
}
```

### `(*Principal).HasAnyScope`

**What:** Checks whether the principal has at least one of the required scopes.

**Why:** Upstream products enforce scopes (e.g., read/write) and handlers need a simple predicate.

**How:** Performs a nested loop over required scopes and the principal's scopes.

```go title="pkg/gateway/auth/authenticator.go#L125" showLineNumbers
func (p *Principal) HasAnyScope(required []string) bool {
	for _, scope := range required {
		for _, owned := range p.Scopes {
			if scope == owned {
				return true
			}
		}
	}
	return false
}
```

### `(*gatewayClaims).Scopes`

**What:** Returns scopes extracted from gateway JWT claims.

**Why:** Tokens may encode scopes in different fields depending on issuer conventions.

**How:** Prefers `scp` (array) when present; otherwise splits the `scope` string on whitespace; returns nil when neither exists.

```go title="pkg/gateway/auth/authenticator.go#L142" showLineNumbers
func (c *gatewayClaims) Scopes() []string {
	if len(c.Scp) > 0 {
		return c.Scp
	}
	if c.Scope == "" {
		return nil
	}
	parts := strings.Fields(c.Scope)
	return parts
}
```

