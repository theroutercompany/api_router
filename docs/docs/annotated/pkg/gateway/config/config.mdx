---
title: "pkg/gateway/config/config.go"
---

<!--
Generated by `go run ./cmd/docsgen`.
Do not edit this file directly.
Edit commentary in `docs/annotations/pkg/gateway/config/config.yaml`.
-->

## Source

- Package: `config`
- File: `pkg/gateway/config/config.go`
- GitHub: https://github.com/theroutercompany/api_router/blob/main/pkg/gateway/config/config.go

## Overview

**What:** Defines the gateway's configuration schema (Go structs + YAML tags), default values, YAML decoding, environment-variable overrides, normalization, and semantic validation.

**Why:** The gateway needs one source of truth for configuration shared across:
- the CLI (`cmd/apigw`)
- the runtime (`pkg/gateway/runtime`)
- downstream SDK consumers (who reuse the config schema)

Centralizing defaults and validation here avoids "magic values" spread across the codebase and turns configuration mistakes into early, actionable errors.

**How:** `Load()` applies configuration layers in order:
1) `Default()` (baseline values)
2) optional YAML file(s)
3) environment overrides (secrets/platform knobs/legacy env config)
4) `normalize()` (fill missing defaults + canonicalize fields)
5) `Validate()` (semantic checks)

**Notes:** Security: secrets (JWT/webhook/admin) typically come from env vars. Treat rendered configs as sensitive and avoid logging secrets.


## Imports

### `import` block 1

```go title="pkg/gateway/config/config.go#L7" showLineNumbers
import (
	"errors"
	"fmt"
	"net/netip"
	"net/url"
	"os"
	"strconv"
	"strings"
	"time"

	"gopkg.in/yaml.v3"
)
```


## Constants

### `const` block 1

```go title="pkg/gateway/config/config.go#L20" showLineNumbers
const (
	defaultPort                   = 8080
	defaultShutdownTimeout        = 15 * time.Second
	defaultReadinessTimeout       = 2 * time.Second
	defaultReadinessUserAgent     = "api-router-gateway/readyz"
	defaultHealthPath             = "/health"
	defaultRateLimitWindow        = 60 * time.Second
	defaultRateLimitMax           = 120
	defaultMetricsEnabled         = true
	defaultAdminListen            = "127.0.0.1:9090"
	defaultWebSocketMaxConcurrent = 0
	defaultWebSocketIdleTimeout   = 5 * time.Minute
	defaultConfigEnvVar           = "APIGW_CONFIG"
	defaultWebhookSignatureHeader = "X-Webhook-Signature"
	defaultWebhookMaxAttempts     = 3
	defaultWebhookBackoff         = 2 * time.Second
	defaultWebhookTimeout         = 10 * time.Second
	envTradePrefix                = "TRADE"
	envTaskPrefix                 = "TASK"
	envPort                       = "PORT"
	envShutdownTimeout            = "SHUTDOWN_TIMEOUT_MS"
	envReadinessTimeout           = "READINESS_TIMEOUT_MS"
	envReadinessUserAgent         = "READINESS_USER_AGENT"
	envGitSHA                     = "GIT_SHA"
	envJWTSecret                  = "JWT_SECRET"
	envJWTAudience                = "JWT_AUDIENCE"
	envJWTIssuer                  = "JWT_ISSUER"
	envCorsAllowedOrigins         = "CORS_ALLOWED_ORIGINS"
	envRateLimitWindow            = "RATE_LIMIT_WINDOW_MS"
	envRateLimitMax               = "RATE_LIMIT_MAX"
	envMetricsEnabled             = "METRICS_ENABLED"
	envAdminEnabled               = "ADMIN_ENABLED"
	envAdminListen                = "ADMIN_LISTEN"
	envAdminToken                 = "ADMIN_TOKEN"
	envAdminAllow                 = "ADMIN_ALLOW"
	envTLSInsecureSkipVerify      = "_TLS_INSECURE_SKIP_VERIFY"
	envTLSEnabled                 = "_TLS_ENABLED"
	envTLSCAFile                  = "_TLS_CA_FILE"
	envTLSCertFile                = "_TLS_CERT_FILE"
	envTLSKeyFile                 = "_TLS_KEY_FILE"
	envAPIURL                     = "_API_URL"
	envHealthPath                 = "_HEALTH_PATH"
)
```

#### `defaultPort`

**What:** Default public HTTP listen port (`8080`).

**Why:** Common convention for services in local development and containers.

**How:** Used in `Default()` and by `normalize()` when `http.port` is `0`.

#### `defaultShutdownTimeout`

**What:** Default graceful shutdown timeout for the HTTP server.

**Why:** Avoids indefinite shutdown hangs while giving in-flight requests time to finish.

**How:** Used in `Default()` and by `normalize()` when `http.shutdownTimeout` is unset/invalid.

#### `defaultReadinessTimeout`

**What:** Default timeout for readiness probe HTTP calls.

**Why:** Prevents readiness checks from hanging indefinitely and stalling rollouts.

**How:** Used in `Default()` and by `normalize()` when `readiness.timeout` is unset/invalid.

#### `defaultReadinessUserAgent`

**What:** Default `User-Agent` header used for readiness probe requests.

**Why:** Makes readiness traffic identifiable in upstream access logs.

**How:** Defaulted in `Default()`/`normalize()` and used by the readiness checker HTTP client.

#### `defaultHealthPath`

**What:** Default upstream health check path (`/health`) used for readiness probing.

**Why:** Ensures upstream readiness checks have a predictable path if omitted.

**How:** Used in `Default()` and reinforced by `normalize()` (including leading-slash canonicalization).

#### `defaultRateLimitWindow`

**What:** Default duration of the rate-limit window.

**Why:** Pairs with `defaultRateLimitMax` to define a complete baseline policy.

**How:** Used in `Default()` and by `normalize()` when `rateLimit.window` is unset/invalid.

#### `defaultRateLimitMax`

**What:** Default maximum number of requests allowed per rate-limit window.

**Why:** Provides a safe baseline throttle policy when operators enable rate limiting but omit tuning.

**How:** Used in `Default()` and by `normalize()` when `rateLimit.max` is unset/invalid.

#### `defaultMetricsEnabled`

**What:** Default toggle for metrics exposure.

**Why:** Metrics are expected in most environments for debugging and alerting.

**How:** Set by `Default()`; overridden by YAML/env; consumed by runtime/server wiring.

#### `defaultAdminListen`

**What:** Default listen address for the admin control-plane server.

**Why:** Binds to loopback by default to reduce accidental exposure of control endpoints.

**How:** Applied by `normalize()` when `admin.listen` is empty.

#### `defaultWebSocketMaxConcurrent`

**What:** Default maximum number of concurrent WebSocket upgrades (`0` = unlimited).

**Why:** Keeps default behavior backwards compatible while enabling operators to add capacity protection.

**How:** Defaulted in `Default()`/`normalize()` and enforced by server middleware prior to upgrade.

#### `defaultWebSocketIdleTimeout`

**What:** Default idle timeout for WebSocket connections (when idle enforcement is enabled).

**Why:** Protects the gateway from leaked/abandoned upgraded connections consuming resources indefinitely.

**How:** Defaulted in `Default()`/`normalize()` and enforced by the server by wrapping hijacked `net.Conn` read/write deadlines.

#### `defaultConfigEnvVar`

**What:** Environment variable name (`APIGW_CONFIG`) that points to a default YAML config file path.

**Why:** Allows deployments to define a canonical config path without always passing CLI flags.

**How:** Reads `os.Getenv(defaultConfigEnvVar)` inside `Load()` and tries it as an additional YAML input (before `WithPath(...)` options).

#### `defaultWebhookSignatureHeader`

**What:** Default header name that carries the webhook HMAC signature (`X-Webhook-Signature`).

**Why:** Provides a consistent default while allowing per-endpoint override when upstreams differ.

**How:** Applied by `normalize()` when `webhooks.endpoints[].signatureHeader` is empty.

#### `defaultWebhookMaxAttempts`

**What:** Default maximum number of webhook forwarding attempts.

**Why:** Bounds work per incoming webhook request and limits tail latency.

**How:** Applied by `normalize()` when `webhooks.endpoints[].maxAttempts` is unset/invalid.

#### `defaultWebhookBackoff`

**What:** Default initial backoff duration between webhook delivery attempts.

**Why:** Avoids immediate retry storms on transient upstream failures.

**How:** Applied by `normalize()` when `webhooks.endpoints[].initialBackoff` is unset/invalid.

#### `defaultWebhookTimeout`

**What:** Default timeout for a single webhook forwarding attempt.

**Why:** Prevents slow webhook targets from tying up gateway resources indefinitely.

**How:** Applied by `normalize()` when `webhooks.endpoints[].timeout` is unset/invalid.

#### `envTradePrefix`

**What:** Prefix (`TRADE`) used to build trade upstream env var names.

**Why:** Keeps upstream env overrides consistent for supported products.

**How:** Used by `applyEnvOverrides()`/`applyUpstreamOverrides()` to locate trade upstream overrides.

#### `envTaskPrefix`

**What:** Prefix (`TASK`) used to build task upstream env var names.

**Why:** Keeps upstream env overrides consistent for supported products.

**How:** Used by `applyEnvOverrides()`/`applyUpstreamOverrides()` to locate task upstream overrides.

#### `envPort`

**What:** Env var (`PORT`) overriding the public HTTP listen port.

**Why:** Common convention on PaaS platforms where the platform assigns a port.

**How:** Parsed by `applyEnvOverrides()` as an integer into `http.port`.

#### `envShutdownTimeout`

**What:** Env var (`SHUTDOWN_TIMEOUT_MS`) overriding `http.shutdownTimeout` (milliseconds).

**Why:** Shutdown grace needs may vary by environment and traffic patterns.

**How:** Parsed by `applyEnvOverrides()` via `parsePositiveDurationMillis`.

#### `envReadinessTimeout`

**What:** Env var (`READINESS_TIMEOUT_MS`) overriding `readiness.timeout` (milliseconds).

**Why:** Readiness sensitivity differs between local/dev and production.

**How:** Parsed by `applyEnvOverrides()` via `parsePositiveDurationMillis`.

#### `envReadinessUserAgent`

**What:** Env var (`READINESS_USER_AGENT`) overriding `readiness.userAgent`.

**Why:** Lets operators ensure readiness requests are identifiable in upstream logs.

**How:** Read by `applyEnvOverrides()` as a string.

#### `envGitSHA`

**What:** Env var (`GIT_SHA`) used to stamp build/version metadata.

**Why:** Build metadata is useful for debugging, rollouts, and health endpoints.

**How:** Read by `Default()` (and optionally overwritten by `applyEnvOverrides()`).

#### `envJWTSecret`

**What:** Env var (`JWT_SECRET`) holding the symmetric key used for JWT verification.

**Why:** Secrets should be injected at runtime via env/secret managers rather than embedded in YAML.

**How:** Read by `applyEnvOverrides()` into `auth.secret`; consumed by `pkg/gateway/auth`.

#### `envJWTAudience`

**What:** Env var (`JWT_AUDIENCE`) configuring acceptable JWT audiences.

**Why:** Audience sets often differ by environment and can evolve without code changes.

**How:** Parsed by `applyEnvOverrides()` using `splitAndTrim` into `auth.audiences`.

#### `envJWTIssuer`

**What:** Env var (`JWT_ISSUER`) configuring the expected JWT issuer.

**Why:** Separates auth policy from code and supports multi-environment deployments.

**How:** Read by `applyEnvOverrides()` into `auth.issuer`.

#### `envCorsAllowedOrigins`

**What:** Env var (`CORS_ALLOWED_ORIGINS`) overriding `cors.allowedOrigins`.

**Why:** CORS policy is commonly environment-specific and needs safe, deploy-time control.

**How:** Parsed by `applyEnvOverrides()` using `splitAndTrim`.

#### `envRateLimitWindow`

**What:** Env var (`RATE_LIMIT_WINDOW_MS`) overriding `rateLimit.window` (milliseconds).

**Why:** Allows deploy-time tuning of the rate-limit window without YAML edits.

**How:** Parsed by `applyEnvOverrides()` via `parsePositiveDurationMillis`.

#### `envRateLimitMax`

**What:** Env var (`RATE_LIMIT_MAX`) overriding `rateLimit.max`.

**Why:** Allows rate limiting to be tuned per environment without YAML edits.

**How:** Parsed by `applyEnvOverrides()` as an integer.

#### `envMetricsEnabled`

**What:** Env var (`METRICS_ENABLED`) controlling metrics exposure.

**Why:** Some environments may forbid metrics endpoints or want them disabled.

**How:** Parsed by `applyEnvOverrides()` as a boolean into `metrics.enabled`.

#### `envAdminEnabled`

**What:** Env var (`ADMIN_ENABLED`) toggling the admin server.

**Why:** Enables turning on/off the admin plane per environment at deploy time.

**How:** Parsed by `applyEnvOverrides()` as a boolean into `admin.enabled`.

#### `envAdminListen`

**What:** Env var (`ADMIN_LISTEN`) overriding `admin.listen`.

**Why:** Supports binding admin endpoints to a specific interface/port per environment.

**How:** Read by `applyEnvOverrides()`; defaulted by `normalize()` when missing.

#### `envAdminToken`

**What:** Env var (`ADMIN_TOKEN`) holding a bearer token for admin authentication.

**Why:** Encourages keeping admin auth secrets in secret managers, not YAML.

**How:** Read by `applyEnvOverrides()` into `admin.token`.

#### `envAdminAllow`

**What:** Env var (`ADMIN_ALLOW`) configuring an IP/CIDR allowlist for admin endpoints.

**Why:** Allows locking down admin access without editing YAML.

**How:** Parsed by `applyEnvOverrides()` using `splitAndTrim` and validated in `Validate()`.

#### `envTLSInsecureSkipVerify`

**What:** Env var suffix (`_TLS_INSECURE_SKIP_VERIFY`) disabling upstream TLS verification for readiness checks.

**Why:** Useful for dev/test against self-signed certs; unsafe for production.

**How:** Parsed by `applyUpstreamOverrides()` and implicitly enables TLS when set.

**Notes:** Avoid in production; disables server certificate verification.

#### `envTLSEnabled`

**What:** Env var suffix (`_TLS_ENABLED`) toggling upstream TLS behavior.

**Why:** Allows enabling TLS through env configuration without editing YAML.

**How:** Parsed by `applyUpstreamOverrides()` as a boolean.

#### `envTLSCAFile`

**What:** Env var suffix (`_TLS_CA_FILE`) providing a PEM CA bundle path for upstream TLS verification.

**Why:** Supports internal PKI / custom root CAs via mounted secret files.

**How:** Read by `applyUpstreamOverrides()` and used by the runtime readiness TLS client configuration.

#### `envTLSCertFile`

**What:** Env var suffix (`_TLS_CERT_FILE`) providing a client certificate path for upstream mTLS.

**Why:** Supports upstreams that require client authentication.

**How:** Read by `applyUpstreamOverrides()`; validated together with `_TLS_KEY_FILE`.

#### `envTLSKeyFile`

**What:** Env var suffix (`_TLS_KEY_FILE`) providing a client private key path for upstream mTLS.

**Why:** Completes the mTLS key pair alongside `_TLS_CERT_FILE`.

**How:** Read by `applyUpstreamOverrides()`; validated together with `_TLS_CERT_FILE`.

#### `envAPIURL`

**What:** Env var suffix (`_API_URL`) appended to an upstream prefix to form the upstream base URL variable.

**Why:** Keeps env naming consistent across upstream products (e.g. `TRADE_API_URL`, `TASK_API_URL`).

**How:** Read by `applyUpstreamOverrides()` as `prefix + envAPIURL`.

#### `envHealthPath`

**What:** Env var suffix (`_HEALTH_PATH`) appended to an upstream prefix to form the upstream health path variable.

**Why:** Keeps env naming consistent across upstream products (e.g. `TRADE_HEALTH_PATH`, `TASK_HEALTH_PATH`).

**How:** Read by `applyUpstreamOverrides()` and canonicalized via `ensureLeadingSlash`.


## Types

### `type` block 1

```go title="pkg/gateway/config/config.go#L65" showLineNumbers
type Config struct {
	Version   string          `yaml:"version"`
	HTTP      HTTPConfig      `yaml:"http"`
	Readiness ReadinessConfig `yaml:"readiness"`
	Auth      AuthConfig      `yaml:"auth"`
	CORS      CORSConfig      `yaml:"cors"`
	RateLimit RateLimitConfig `yaml:"rateLimit"`
	Metrics   MetricsConfig   `yaml:"metrics"`
	Admin     AdminConfig     `yaml:"admin"`
	WebSocket WebSocketConfig `yaml:"websocket"`
	Webhooks  WebhookConfig   `yaml:"webhooks"`
}
```

#### `Config`

**What:** Root configuration object for the gateway runtime and SDK.

**Why:** Provides a stable schema for running the gateway via CLI and for embedding it as a library.

**How:** Created by `Load()` and then consumed by runtime/server packages to configure listeners, upstreams, auth, middleware, and feature flags.

### `type` block 2

```go title="pkg/gateway/config/config.go#L79" showLineNumbers
type HTTPConfig struct {
	Port            int      `yaml:"port"`
	ShutdownTimeout Duration `yaml:"shutdownTimeout"`
}
```

#### `HTTPConfig`

**What:** Public HTTP server configuration (port and shutdown timeout).

**Why:** Keeps listener behavior explicit and environment-configurable.

**How:** Used by the server runtime to bind and to configure graceful shutdown.

### `type` block 3

```go title="pkg/gateway/config/config.go#L85" showLineNumbers
type ReadinessConfig struct {
	Timeout   Duration         `yaml:"timeout"`
	UserAgent string           `yaml:"userAgent"`
	Upstreams []UpstreamConfig `yaml:"upstreams"`
}
```

#### `ReadinessConfig`

**What:** Readiness probing configuration (timeout, user-agent, upstream list).

**Why:** Readiness controls whether the gateway should receive traffic; it must reflect upstream reachability.

**How:** Used by the runtime to build the readiness checker; validated for required upstreams (trade/task).

### `type` block 4

```go title="pkg/gateway/config/config.go#L92" showLineNumbers
type UpstreamConfig struct {
	Name       string    `yaml:"name"`
	BaseURL    string    `yaml:"baseURL"`
	HealthPath string    `yaml:"healthPath"`
	TLS        TLSConfig `yaml:"tls"`
}
```

#### `UpstreamConfig`

**What:** Upstream service configuration (name, base URL, health path, TLS options).

**Why:** The gateway proxies to multiple upstream products and needs per-upstream settings for probing and routing.

**How:** Loaded from defaults/YAML/env and used by readiness checks and proxy routing.

### `type` block 5

```go title="pkg/gateway/config/config.go#L100" showLineNumbers
type TLSConfig struct {
	Enabled            bool   `yaml:"enabled"`
	InsecureSkipVerify bool   `yaml:"insecureSkipVerify"`
	CAFile             string `yaml:"caFile"`
	ClientCertFile     string `yaml:"clientCertFile"`
	ClientKeyFile      string `yaml:"clientKeyFile"`
}
```

#### `TLSConfig`

**What:** Upstream TLS/mTLS configuration for readiness checks (enable, CA file, client cert/key, skip verify).

**Why:** Supports upstreams with internal PKI or client-auth requirements while keeping secrets/file paths out of code.

**How:** Applied to upstream configs and validated for cert/key pairing; used by runtime to build per-upstream TLS transports.

### `type` block 6

```go title="pkg/gateway/config/config.go#L109" showLineNumbers
type AuthConfig struct {
	Secret    string   `yaml:"secret"`
	Audiences []string `yaml:"audiences"`
	Issuer    string   `yaml:"issuer"`
}
```

#### `AuthConfig`

**What:** JWT verification configuration (secret, audiences, issuer).

**Why:** Keeps auth policy configurable across environments without changing code.

**How:** Used by `pkg/gateway/auth` when building the authenticator and auth middleware.

### `type` block 7

```go title="pkg/gateway/config/config.go#L116" showLineNumbers
type CORSConfig struct {
	AllowedOrigins []string `yaml:"allowedOrigins"`
}
```

#### `CORSConfig`

**What:** CORS configuration (allowed origins).

**Why:** Browser-facing clients require explicit CORS policy control.

**How:** Applied by server middleware when handling cross-origin requests.

### `type` block 8

```go title="pkg/gateway/config/config.go#L121" showLineNumbers
type RateLimitConfig struct {
	Window Duration `yaml:"window"`
	Max    int      `yaml:"max"`
}
```

#### `RateLimitConfig`

**What:** Rate limiting configuration (window and max requests).

**Why:** Protects the gateway and upstreams from bursts and accidental abuse.

**How:** Consumed by rate limiting middleware; defaulted and validated by this package.

### `type` block 9

```go title="pkg/gateway/config/config.go#L127" showLineNumbers
type MetricsConfig struct {
	Enabled bool `yaml:"enabled"`
}
```

#### `MetricsConfig`

**What:** Metrics enablement configuration.

**Why:** Allows disabling metrics in constrained or special environments.

**How:** Read by runtime/server to decide whether to register/expose Prometheus metrics.

### `type` block 10

```go title="pkg/gateway/config/config.go#L132" showLineNumbers
type WebSocketConfig struct {
	MaxConcurrent int      `yaml:"maxConcurrent"`
	IdleTimeout   Duration `yaml:"idleTimeout"`
}
```

#### `WebSocketConfig`

**What:** WebSocket connection policy (max concurrent and idle timeout).

**Why:** Upgraded connections are long-lived; limits protect against resource exhaustion and leaks.

**How:** Consumed by the server to reject upgrades at capacity and enforce idle timeouts.

### `type` block 11

```go title="pkg/gateway/config/config.go#L138" showLineNumbers
type AdminConfig struct {
	Enabled bool     `yaml:"enabled"`
	Listen  string   `yaml:"listen"`
	Token   string   `yaml:"token"`
	Allow   []string `yaml:"allow"`
}
```

#### `AdminConfig`

**What:** Configuration for the admin/control-plane HTTP server (enable, listen, token, allowlist).

**Why:** Separates operational endpoints from the public gateway interface and supports tight access control.

**How:** Consumed by runtime/server when starting admin endpoints; validated when enabled.

### `type` block 12

```go title="pkg/gateway/config/config.go#L146" showLineNumbers
type WebhookConfig struct {
	Enabled   bool                    `yaml:"enabled"`
	Endpoints []WebhookEndpointConfig `yaml:"endpoints"`
}
```

#### `WebhookConfig`

**What:** Webhook ingestion configuration (enabled flag and endpoint list).

**Why:** Enables secure ingestion of event callbacks and controlled forwarding to upstream targets.

**How:** When enabled, server registers per-endpoint webhook handlers using the endpoint configs.

### `type` block 13

```go title="pkg/gateway/config/config.go#L152" showLineNumbers
type WebhookEndpointConfig struct {
	Name            string   `yaml:"name"`
	Path            string   `yaml:"path"`
	TargetURL       string   `yaml:"targetURL"`
	Secret          string   `yaml:"secret"`
	SignatureHeader string   `yaml:"signatureHeader"`
	MaxAttempts     int      `yaml:"maxAttempts"`
	InitialBackoff  Duration `yaml:"initialBackoff"`
	Timeout         Duration `yaml:"timeout"`
}
```

#### `WebhookEndpointConfig`

**What:** Per-endpoint webhook configuration (path, target URL, secret, signature header, retry/backoff, timeout).

**Why:** Different webhook senders may require different endpoints, secrets, and retry characteristics.

**How:** Normalized/validated here; used to construct `pkg/gateway/webhook` handlers and mount them in the server.

### `type` block 14

```go title="pkg/gateway/config/config.go#L164" showLineNumbers
type Duration time.Duration
```

#### `Duration`

**What:** A YAML-friendly wrapper around `time.Duration`.

**Why:** Allows config fields to accept both `1s`-style strings and millisecond integers.

**How:** Implements YAML marshal/unmarshal methods and exposes `AsDuration()` for consumers.

### `type` block 15

```go title="pkg/gateway/config/config.go#L270" showLineNumbers
type Option func(*loaderOptions)
```

#### `Option`

**What:** Functional option type used to customize how `Load()` behaves.

**Why:** Keeps the `Load()` API stable while enabling targeted customization for CLI/tests.

**How:** Options mutate a private `loaderOptions` instance inside `Load()`.

### `type` block 16

```go title="pkg/gateway/config/config.go#L272" showLineNumbers
type loaderOptions struct {
	paths     []string
	lookupEnv func(string) (string, bool)
}
```

#### `loaderOptions`

**What:** Internal accumulator for config-loading options (YAML paths and env lookup function).

**Why:** Keeps `Load()` testable and configurable without global state.

**How:** Mutated by `WithPath` and `WithLookupEnv`, then consumed by `Load()`.


## Functions and Methods

### `(Duration).AsDuration`

**What:** Converts the wrapper to a `time.Duration`.

**Why:** Makes transitions between config types and standard library types explicit.

**How:** Implemented as a simple type conversion.

```go title="pkg/gateway/config/config.go#L167" showLineNumbers
func (d Duration) AsDuration() time.Duration {
	return time.Duration(d)
}
```

### `(Duration).MarshalYAML`

**What:** Encodes a `Duration` as a Go duration string for YAML output.

**Why:** Produces human-readable YAML when configs are emitted/converted.

**How:** Returns `d.AsDuration().String()` to the YAML encoder.

```go title="pkg/gateway/config/config.go#L172" showLineNumbers
func (d Duration) MarshalYAML() (interface{}, error) {
	return d.AsDuration().String(), nil
}
```

### `(*Duration).UnmarshalYAML`

**What:** Parses a YAML scalar into a `Duration`.

**Why:** Supports both Go duration strings (`1s`) and numeric millisecond strings (`2000`) in config.

**How:** Treats integer-looking scalars as milliseconds; otherwise uses `time.ParseDuration`. Rejects negative values.

```go title="pkg/gateway/config/config.go#L177" showLineNumbers
func (d *Duration) UnmarshalYAML(value *yaml.Node) error {
	if value == nil {
		return nil
	}

	switch value.Kind {
	case yaml.ScalarNode:
		txt := strings.TrimSpace(value.Value)
		if txt == "" {
			*d = Duration(0)
			return nil
		}
		if ms, err := strconv.Atoi(txt); err == nil {
			if ms < 0 {
				return fmt.Errorf("duration must be non-negative, got %d", ms)
			}
			*d = Duration(time.Duration(ms) * time.Millisecond)
			return nil
		}
		parsed, err := time.ParseDuration(txt)
		if err != nil {
			return fmt.Errorf("parse duration %q: %w", txt, err)
		}
		if parsed < 0 {
			return fmt.Errorf("duration must be non-negative, got %s", parsed)
		}
		*d = Duration(parsed)
		return nil
	default:
		return fmt.Errorf("unsupported duration node kind: %v", value.Kind)
	}
}
```

### `DurationFrom`

**What:** Converts `time.Duration` into the config `Duration` wrapper type.

**Why:** Keeps default-setting code readable and consistent.

**How:** Used by `Default()` and `normalize()` when assigning durations.

```go title="pkg/gateway/config/config.go#L211" showLineNumbers
func DurationFrom(d time.Duration) Duration {
	return Duration(d)
}
```

### `Default`

**What:** Constructs a baseline `Config` with safe defaults.

**Why:** Provides predictable behavior when YAML/env inputs are partial and gives `Load()` a stable base layer.

**How:** Initializes default timeouts/ports/limits, creates trade/task upstream stubs, and sets `Config.Version` from `GIT_SHA`.

```go title="pkg/gateway/config/config.go#L216" showLineNumbers
func Default() Config {
	return Config{
		Version: os.Getenv(envGitSHA),
		HTTP: HTTPConfig{
			Port:            defaultPort,
			ShutdownTimeout: DurationFrom(defaultShutdownTimeout),
		},
		Readiness: ReadinessConfig{
			Timeout:   DurationFrom(defaultReadinessTimeout),
			UserAgent: defaultReadinessUserAgent,
			Upstreams: []UpstreamConfig{
				{
					Name:       "trade",
					BaseURL:    "",
					HealthPath: defaultHealthPath,
					TLS:        TLSConfig{},
				},
				{
					Name:       "task",
					BaseURL:    "",
					HealthPath: defaultHealthPath,
					TLS:        TLSConfig{},
				},
			},
		},
		Auth: AuthConfig{},
		CORS: CORSConfig{
			AllowedOrigins: nil,
		},
		RateLimit: RateLimitConfig{
			Window: DurationFrom(defaultRateLimitWindow),
			Max:    defaultRateLimitMax,
		},
		Metrics: MetricsConfig{
			Enabled: defaultMetricsEnabled,
		},
		Admin: AdminConfig{
			Enabled: false,
			Listen:  defaultAdminListen,
			Token:   "",
			Allow:   nil,
		},
		WebSocket: WebSocketConfig{
			MaxConcurrent: defaultWebSocketMaxConcurrent,
			IdleTimeout:   DurationFrom(defaultWebSocketIdleTimeout),
		},
		Webhooks: WebhookConfig{
			Enabled:   false,
			Endpoints: nil,
		},
	}
}
```

### `WithPath`

**What:** Option that adds a YAML config path to attempt loading.

**Why:** Lets CLI/tests specify config file(s) without relying on global state.

**How:** Appends to `loaderOptions.paths` when the provided path is non-empty.

```go title="pkg/gateway/config/config.go#L278" showLineNumbers
func WithPath(path string) Option {
	return func(o *loaderOptions) {
		if strings.TrimSpace(path) != "" {
			o.paths = append(o.paths, path)
		}
	}
}
```

### `WithLookupEnv`

**What:** Option that overrides how environment variables are looked up.

**Why:** Enables deterministic tests without mutating real process environment.

**How:** Sets `loaderOptions.lookupEnv`, which is passed into `applyEnvOverrides`.

```go title="pkg/gateway/config/config.go#L287" showLineNumbers
func WithLookupEnv(fn func(string) (string, bool)) Option {
	return func(o *loaderOptions) {
		o.lookupEnv = fn
	}
}
```

### `Load`

**What:** Loads configuration by merging defaults, YAML file(s), and environment overrides.

**Why:** Supports both config-file-driven deployments and env-driven deployments (especially for secrets).

**How:** - Builds `loaderOptions` (paths + env lookup)
- Seeds paths from `APIGW_CONFIG`
- Applies any `Option`s (e.g. `WithPath`)
- Starts from `Default()`
- Reads and unmarshals YAML (skipping missing files)
- Applies env overrides (`applyEnvOverrides`)
- Normalizes (`normalize`) and validates (`Validate`)

**Notes:** Order matters: later layers override earlier layers.

```go title="pkg/gateway/config/config.go#L294" showLineNumbers
func Load(opts ...Option) (Config, error) {
	options := loaderOptions{
		lookupEnv: os.LookupEnv,
	}
	if envPath := strings.TrimSpace(os.Getenv(defaultConfigEnvVar)); envPath != "" {
		options.paths = append(options.paths, envPath)
	}
	for _, opt := range opts {
		if opt != nil {
			opt(&options)
		}
	}

	cfg := Default()

	for _, path := range options.paths {
		if strings.TrimSpace(path) == "" {
			continue
		}
		data, err := os.ReadFile(path)
		switch {
		case errors.Is(err, os.ErrNotExist):
			continue
		case err != nil:
			return cfg, fmt.Errorf("read config %q: %w", path, err)
		}
		if err := yaml.Unmarshal(data, &cfg); err != nil {
			return cfg, fmt.Errorf("decode config %q: %w", path, err)
		}
	}

	if err := applyEnvOverrides(&cfg, options.lookupEnv); err != nil {
		return cfg, err
	}

	if err := cfg.normalize(); err != nil {
		return cfg, err
	}

	if err := cfg.Validate(); err != nil {
		return cfg, err
	}

	return cfg, nil
}
```

### `applyEnvOverrides`

**What:** Applies environment-variable overrides to an existing `Config`.

**Why:** Deployments frequently inject secrets and runtime knobs via env vars; this layer keeps overrides explicit and validated.

**How:** - Reads known gateway-level env vars (port, timeouts, auth, CORS, rate limiting, metrics, admin)
- Calls `applyUpstreamOverrides` for the trade/task upstream prefixes
- Leaves YAML/default values untouched when env vars are absent

```go title="pkg/gateway/config/config.go#L340" showLineNumbers
func applyEnvOverrides(cfg *Config, lookup func(string) (string, bool)) error {
	if lookup == nil {
		lookup = os.LookupEnv
	}

	if val, ok := lookup(envPort); ok && strings.TrimSpace(val) != "" {
		port, err := strconv.Atoi(strings.TrimSpace(val))
		if err != nil || port <= 0 {
			return fmt.Errorf("invalid %s value: %s", envPort, val)
		}
		cfg.HTTP.Port = port
	}

	if val, ok := lookup(envShutdownTimeout); ok && strings.TrimSpace(val) != "" {
		timeout, err := parsePositiveDurationMillis(val)
		if err != nil {
			return fmt.Errorf("invalid %s: %w", envShutdownTimeout, err)
		}
		cfg.HTTP.ShutdownTimeout = DurationFrom(timeout)
	}

	if val, ok := lookup(envReadinessTimeout); ok && strings.TrimSpace(val) != "" {
		timeout, err := parsePositiveDurationMillis(val)
		if err != nil {
			return fmt.Errorf("invalid %s: %w", envReadinessTimeout, err)
		}
		cfg.Readiness.Timeout = DurationFrom(timeout)
	}

	if val, ok := lookup(envReadinessUserAgent); ok && strings.TrimSpace(val) != "" {
		cfg.Readiness.UserAgent = strings.TrimSpace(val)
	}

	if val, ok := lookup(envGitSHA); ok && strings.TrimSpace(val) != "" {
		cfg.Version = strings.TrimSpace(val)
	}

	if val, ok := lookup(envJWTSecret); ok && strings.TrimSpace(val) != "" {
		cfg.Auth.Secret = strings.TrimSpace(val)
	}

	if val, ok := lookup(envJWTAudience); ok && strings.TrimSpace(val) != "" {
		cfg.Auth.Audiences = splitAndTrim(val)
	}

	if val, ok := lookup(envJWTIssuer); ok && strings.TrimSpace(val) != "" {
		cfg.Auth.Issuer = strings.TrimSpace(val)
	}

	if val, ok := lookup(envCorsAllowedOrigins); ok && strings.TrimSpace(val) != "" {
		cfg.CORS.AllowedOrigins = splitAndTrim(val)
	}

	if val, ok := lookup(envRateLimitWindow); ok && strings.TrimSpace(val) != "" {
		window, err := parsePositiveDurationMillis(val)
		if err != nil {
			return fmt.Errorf("invalid %s: %w", envRateLimitWindow, err)
		}
		cfg.RateLimit.Window = DurationFrom(window)
	}

	if val, ok := lookup(envRateLimitMax); ok && strings.TrimSpace(val) != "" {
		max, err := strconv.Atoi(strings.TrimSpace(val))
		if err != nil || max <= 0 {
			return fmt.Errorf("invalid %s: %s", envRateLimitMax, val)
		}
		cfg.RateLimit.Max = max
	}

	if val, ok := lookup(envMetricsEnabled); ok && strings.TrimSpace(val) != "" {
		enabled, err := strconv.ParseBool(strings.TrimSpace(val))
		if err != nil {
			return fmt.Errorf("invalid %s: %w", envMetricsEnabled, err)
		}
		cfg.Metrics.Enabled = enabled
	}

	if err := applyUpstreamOverrides(cfg, lookup, envTradePrefix); err != nil {
		return fmt.Errorf("trade upstream config: %w", err)
	}
	if err := applyUpstreamOverrides(cfg, lookup, envTaskPrefix); err != nil {
		return fmt.Errorf("task upstream config: %w", err)
	}

	if val, ok := lookup(envAdminEnabled); ok && strings.TrimSpace(val) != "" {
		enabled, err := strconv.ParseBool(strings.TrimSpace(val))
		if err != nil {
			return fmt.Errorf("invalid %s: %w", envAdminEnabled, err)
		}
		cfg.Admin.Enabled = enabled
	}

	if val, ok := lookup(envAdminListen); ok && strings.TrimSpace(val) != "" {
		cfg.Admin.Listen = strings.TrimSpace(val)
	}

	if val, ok := lookup(envAdminToken); ok {
		cfg.Admin.Token = strings.TrimSpace(val)
	}

	if val, ok := lookup(envAdminAllow); ok && strings.TrimSpace(val) != "" {
		cfg.Admin.Allow = splitAndTrim(val)
	}

	return nil
}
```

### `applyUpstreamOverrides`

**What:** Applies per-upstream env overrides for a given upstream prefix (e.g. `TRADE`, `TASK`).

**Why:** Centralizes upstream override logic and keeps naming consistent across products.

**How:** Ensures the upstream exists (via `ensureUpstream`), then applies base URL, health path, and TLS-related env vars.

```go title="pkg/gateway/config/config.go#L447" showLineNumbers
func applyUpstreamOverrides(cfg *Config, lookup func(string) (string, bool), prefix string) error {
	upstream := cfg.ensureUpstream(prefix)

	if val, ok := lookup(prefix + envAPIURL); ok && strings.TrimSpace(val) != "" {
		upstream.BaseURL = strings.TrimSpace(val)
	}
	if val, ok := lookup(prefix + envHealthPath); ok && strings.TrimSpace(val) != "" {
		upstream.HealthPath = ensureLeadingSlash(strings.TrimSpace(val))
	}

	if val, ok := lookup(prefix + envTLSEnabled); ok && strings.TrimSpace(val) != "" {
		enabled, err := strconv.ParseBool(strings.TrimSpace(val))
		if err != nil {
			return fmt.Errorf("invalid %s%s: %w", prefix, envTLSEnabled, err)
		}
		upstream.TLS.Enabled = enabled
	}

	if val, ok := lookup(prefix + envTLSInsecureSkipVerify); ok && strings.TrimSpace(val) != "" {
		enabled, err := strconv.ParseBool(strings.TrimSpace(val))
		if err != nil {
			return fmt.Errorf("invalid %s%s: %w", prefix, envTLSInsecureSkipVerify, err)
		}
		upstream.TLS.InsecureSkipVerify = enabled
		if enabled {
			upstream.TLS.Enabled = true
		}
	}

	if val, ok := lookup(prefix + envTLSCAFile); ok && strings.TrimSpace(val) != "" {
		upstream.TLS.CAFile = strings.TrimSpace(val)
		upstream.TLS.Enabled = true
	}
	if val, ok := lookup(prefix + envTLSCertFile); ok && strings.TrimSpace(val) != "" {
		upstream.TLS.ClientCertFile = strings.TrimSpace(val)
		upstream.TLS.Enabled = true
	}
	if val, ok := lookup(prefix + envTLSKeyFile); ok && strings.TrimSpace(val) != "" {
		upstream.TLS.ClientKeyFile = strings.TrimSpace(val)
		upstream.TLS.Enabled = true
	}

	return nil
}
```

### `(*Config).normalize`

**What:** Fills in derived defaults and canonicalizes fields after YAML/env overrides.

**Why:** Config inputs can be partial and inconsistent (missing slashes, empty defaults). Normalization makes downstream behavior predictable.

**How:** Defaults numeric/time fields, ensures required upstream entries exist, canonicalizes health paths, reconciles TLS flags, and normalizes webhook endpoint values.

```go title="pkg/gateway/config/config.go#L493" showLineNumbers
func (cfg *Config) normalize() error {
	if cfg.HTTP.Port == 0 {
		cfg.HTTP.Port = defaultPort
	}
	if cfg.HTTP.ShutdownTimeout.AsDuration() <= 0 {
		cfg.HTTP.ShutdownTimeout = DurationFrom(defaultShutdownTimeout)
	}
	if cfg.Readiness.Timeout.AsDuration() <= 0 {
		cfg.Readiness.Timeout = DurationFrom(defaultReadinessTimeout)
	}
	if strings.TrimSpace(cfg.Readiness.UserAgent) == "" {
		cfg.Readiness.UserAgent = defaultReadinessUserAgent
	}
	if cfg.RateLimit.Window.AsDuration() <= 0 {
		cfg.RateLimit.Window = DurationFrom(defaultRateLimitWindow)
	}
	if cfg.RateLimit.Max <= 0 {
		cfg.RateLimit.Max = defaultRateLimitMax
	}

	if strings.TrimSpace(cfg.Admin.Listen) == "" {
		cfg.Admin.Listen = defaultAdminListen
	}

	if cfg.WebSocket.IdleTimeout.AsDuration() <= 0 {
		cfg.WebSocket.IdleTimeout = DurationFrom(defaultWebSocketIdleTimeout)
	}
	if cfg.WebSocket.MaxConcurrent < 0 {
		cfg.WebSocket.MaxConcurrent = defaultWebSocketMaxConcurrent
	}

	cfg.ensureUpstream(envTradePrefix)
	cfg.ensureUpstream(envTaskPrefix)

	for i := range cfg.Readiness.Upstreams {
		if strings.TrimSpace(cfg.Readiness.Upstreams[i].HealthPath) == "" {
			cfg.Readiness.Upstreams[i].HealthPath = defaultHealthPath
		} else {
			cfg.Readiness.Upstreams[i].HealthPath = ensureLeadingSlash(cfg.Readiness.Upstreams[i].HealthPath)
		}
		if cfg.Readiness.Upstreams[i].TLS.InsecureSkipVerify {
			cfg.Readiness.Upstreams[i].TLS.Enabled = true
		}
	}

	for i := range cfg.Webhooks.Endpoints {
		cfg.Webhooks.Endpoints[i].Name = strings.ToLower(strings.TrimSpace(cfg.Webhooks.Endpoints[i].Name))
		cfg.Webhooks.Endpoints[i].Path = ensureLeadingSlash(strings.TrimSpace(cfg.Webhooks.Endpoints[i].Path))
		if strings.TrimSpace(cfg.Webhooks.Endpoints[i].SignatureHeader) == "" {
			cfg.Webhooks.Endpoints[i].SignatureHeader = defaultWebhookSignatureHeader
		}
		if cfg.Webhooks.Endpoints[i].MaxAttempts <= 0 {
			cfg.Webhooks.Endpoints[i].MaxAttempts = defaultWebhookMaxAttempts
		}
		if cfg.Webhooks.Endpoints[i].InitialBackoff.AsDuration() <= 0 {
			cfg.Webhooks.Endpoints[i].InitialBackoff = DurationFrom(defaultWebhookBackoff)
		}
		if cfg.Webhooks.Endpoints[i].Timeout.AsDuration() <= 0 {
			cfg.Webhooks.Endpoints[i].Timeout = DurationFrom(defaultWebhookTimeout)
		}
	}

	return nil
}
```

### `(Config).Validate`

**What:** Performs semantic validation of configuration values.

**Why:** Failing fast prevents partial startup and reduces runtime surprises.

**How:** Checks ports/timeouts, enforces required upstreams and unique names, validates URLs and TLS cert/key pairing, validates admin allowlist values, and validates websocket/webhook settings; returns `errors.Join` for multiple failures.

```go title="pkg/gateway/config/config.go#L559" showLineNumbers
func (cfg Config) Validate() error {
	var errs []error

	if cfg.HTTP.Port <= 0 {
		errs = append(errs, fmt.Errorf("http.port must be positive"))
	}
	if cfg.HTTP.ShutdownTimeout.AsDuration() <= 0 {
		errs = append(errs, fmt.Errorf("http.shutdownTimeout must be positive"))
	}
	if cfg.Readiness.Timeout.AsDuration() <= 0 {
		errs = append(errs, fmt.Errorf("readiness.timeout must be positive"))
	}
	if len(cfg.Readiness.Upstreams) == 0 {
		errs = append(errs, fmt.Errorf("at least one readiness upstream required"))
	}

	requiredUpstreams := map[string]bool{"trade": false, "task": false}
	seen := make(map[string]struct{})
	for _, upstream := range cfg.Readiness.Upstreams {
		name := strings.TrimSpace(strings.ToLower(upstream.Name))
		if name == "" {
			errs = append(errs, fmt.Errorf("readiness upstream name must not be empty"))
			continue
		}
		if _, exists := seen[name]; exists {
			errs = append(errs, fmt.Errorf("duplicate readiness upstream name: %s", upstream.Name))
			continue
		}
		seen[name] = struct{}{}
		if upstream.BaseURL == "" {
			errs = append(errs, fmt.Errorf("readiness upstream %s requires baseURL", upstream.Name))
		} else if _, err := url.ParseRequestURI(upstream.BaseURL); err != nil {
			errs = append(errs, fmt.Errorf("readiness upstream %s baseURL invalid: %w", upstream.Name, err))
		}
		if upstream.TLS.ClientCertFile != "" && upstream.TLS.ClientKeyFile == "" {
			errs = append(errs, fmt.Errorf("readiness upstream %s tls client key required when cert provided", upstream.Name))
		}
		if upstream.TLS.ClientKeyFile != "" && upstream.TLS.ClientCertFile == "" {
			errs = append(errs, fmt.Errorf("readiness upstream %s tls client cert required when key provided", upstream.Name))
		}
		if _, ok := requiredUpstreams[name]; ok {
			requiredUpstreams[name] = true
		}
	}

	for key, satisfied := range requiredUpstreams {
		if !satisfied {
			errs = append(errs, fmt.Errorf("%s upstream configuration is required", key))
		}
	}

	if cfg.RateLimit.Max <= 0 {
		errs = append(errs, fmt.Errorf("rateLimit.max must be positive"))
	}
	if cfg.RateLimit.Window.AsDuration() <= 0 {
		errs = append(errs, fmt.Errorf("rateLimit.window must be positive"))
	}

	if cfg.Admin.Enabled {
		if strings.TrimSpace(cfg.Admin.Listen) == "" {
			errs = append(errs, fmt.Errorf("admin.listen must be provided when admin.enabled is true"))
		}
		for _, entry := range cfg.Admin.Allow {
			e := strings.TrimSpace(entry)
			if e == "" {
				continue
			}
			if strings.Contains(e, "/") {
				if _, err := netip.ParsePrefix(e); err != nil {
					errs = append(errs, fmt.Errorf("invalid admin allow value %q: %w", e, err))
				}
			} else if _, err := netip.ParseAddr(e); err != nil {
				errs = append(errs, fmt.Errorf("invalid admin allow value %q: %w", e, err))
			}
		}
	}

	if cfg.WebSocket.MaxConcurrent < 0 {
		errs = append(errs, fmt.Errorf("websocket.maxConcurrent cannot be negative"))
	}
	if cfg.WebSocket.IdleTimeout.AsDuration() < 0 {
		errs = append(errs, fmt.Errorf("websocket.idleTimeout cannot be negative"))
	}

	if cfg.Webhooks.Enabled {
		if len(cfg.Webhooks.Endpoints) == 0 {
			errs = append(errs, fmt.Errorf("webhooks.enabled is true but no endpoints configured"))
		}
		seenWebhookNames := make(map[string]struct{})
		seenWebhookPaths := make(map[string]struct{})
		for _, endpoint := range cfg.Webhooks.Endpoints {
			name := strings.TrimSpace(endpoint.Name)
			if name == "" {
				errs = append(errs, fmt.Errorf("webhook endpoint name must be provided"))
			} else {
				if _, exists := seenWebhookNames[name]; exists {
					errs = append(errs, fmt.Errorf("duplicate webhook endpoint name: %s", name))
				}
				seenWebhookNames[name] = struct{}{}
			}

			path := strings.TrimSpace(endpoint.Path)
			if path == "" || path == "/" {
				errs = append(errs, fmt.Errorf("webhook endpoint %s must specify a path", name))
			} else {
				if _, exists := seenWebhookPaths[path]; exists {
					errs = append(errs, fmt.Errorf("duplicate webhook endpoint path: %s", path))
				}
				seenWebhookPaths[path] = struct{}{}
			}

			if strings.TrimSpace(endpoint.TargetURL) == "" {
				errs = append(errs, fmt.Errorf("webhook endpoint %s targetURL is required", name))
			} else if _, err := url.ParseRequestURI(endpoint.TargetURL); err != nil {
				errs = append(errs, fmt.Errorf("webhook endpoint %s targetURL invalid: %w", name, err))
			}

			if strings.TrimSpace(endpoint.Secret) == "" {
				errs = append(errs, fmt.Errorf("webhook endpoint %s secret is required", name))
			}

			if endpoint.MaxAttempts <= 0 {
				errs = append(errs, fmt.Errorf("webhook endpoint %s maxAttempts must be positive", name))
			}

			if endpoint.InitialBackoff.AsDuration() <= 0 {
				errs = append(errs, fmt.Errorf("webhook endpoint %s initialBackoff must be positive", name))
			}
			if endpoint.Timeout.AsDuration() <= 0 {
				errs = append(errs, fmt.Errorf("webhook endpoint %s timeout must be positive", name))
			}
		}
	}

	if len(errs) == 0 {
		return nil
	}
	return errors.Join(errs...)
}
```

### `(*Config).ensureUpstream`

**What:** Ensures an upstream entry exists for the provided prefix/name and returns it.

**Why:** Env overrides must be able to target an upstream even if YAML omitted its entry.

**How:** Searches `cfg.Readiness.Upstreams` case-insensitively; if missing, appends a new `UpstreamConfig` with defaults.

```go title="pkg/gateway/config/config.go#L699" showLineNumbers
func (cfg *Config) ensureUpstream(prefix string) *UpstreamConfig {
	name := strings.ToLower(prefix)
	for i := range cfg.Readiness.Upstreams {
		if strings.EqualFold(cfg.Readiness.Upstreams[i].Name, name) {
			cfg.Readiness.Upstreams[i].Name = name
			return &cfg.Readiness.Upstreams[i]
		}
	}

	upstream := UpstreamConfig{
		Name:       name,
		BaseURL:    "",
		HealthPath: defaultHealthPath,
	}
	cfg.Readiness.Upstreams = append(cfg.Readiness.Upstreams, upstream)
	return &cfg.Readiness.Upstreams[len(cfg.Readiness.Upstreams)-1]
}
```

### `parsePositiveDurationMillis`

**What:** Parses a millisecond duration env var into a `time.Duration`.

**Why:** Several env overrides use the `*_MS` convention for backwards compatibility and platform friendliness.

**How:** Parses an integer, rejects non-positive values, and multiplies by `time.Millisecond`.

```go title="pkg/gateway/config/config.go#L717" showLineNumbers
func parsePositiveDurationMillis(value string) (time.Duration, error) {
	ms, err := strconv.Atoi(strings.TrimSpace(value))
	if err != nil {
		return 0, err
	}
	if ms <= 0 {
		return 0, fmt.Errorf("value must be positive: %d", ms)
	}
	return time.Duration(ms) * time.Millisecond, nil
}
```

### `splitAndTrim`

**What:** Splits a delimited string into trimmed tokens (comma/space/semicolon separators).

**Why:** Many env vars accept lists (audiences, CORS origins, allowlist); this makes parsing consistent.

**How:** Uses `strings.FieldsFunc` and filters empty tokens.

```go title="pkg/gateway/config/config.go#L728" showLineNumbers
func splitAndTrim(value string) []string {
	parts := strings.FieldsFunc(value, func(r rune) bool {
		return r == ',' || r == ' ' || r == ';'
	})
	result := make([]string, 0, len(parts))
	for _, part := range parts {
		if trimmed := strings.TrimSpace(part); trimmed != "" {
			result = append(result, trimmed)
		}
	}
	return result
}
```

### `ensureLeadingSlash`

**What:** Ensures a URL path begins with `/`.

**Why:** Normalizes config inputs so downstream routing/probing code can assume canonical paths.

**How:** Returns `/` for empty input, preserves already-slashed paths, otherwise prefixes `/`.

```go title="pkg/gateway/config/config.go#L741" showLineNumbers
func ensureLeadingSlash(path string) string {
	if path == "" {
		return "/"
	}
	if strings.HasPrefix(path, "/") {
		return path
	}
	return "/" + path
}
```

