---
title: "pkg/gateway/runtime/runtime.go"
---

<!--
Generated by `go run ./cmd/docsgen`.
Do not edit this file directly.
Edit commentary in `docs/annotations/pkg/gateway/runtime/runtime.yaml`.
-->

## Source

- Package: `runtime`
- File: `pkg/gateway/runtime/runtime.go`
- GitHub: https://github.com/theroutercompany/api_router/blob/main/pkg/gateway/runtime/runtime.go

## Overview

**What:** Composes configuration, readiness checking, metrics registry, and the HTTP server into a single lifecycle object (`Runtime`).

This package is the "composition root" for gateway execution: it builds the server and (optionally) an admin control-plane server.

**Why:** The gateway needs a reusable runtime that can be:
- started/stopped by the CLI
- embedded as a library
- managed by a daemon wrapper

Keeping lifecycle orchestration here avoids duplicating startup/shutdown/reload logic across entrypoints.

**How:** - `New()` builds the server, readiness checker, and metrics registry.
- `Start()` runs the public server (and optionally the admin server) in the background.
- `Wait()` blocks until shutdown and returns the terminal error.
- `Shutdown()` requests graceful shutdown.
- `Reload()` rebuilds dependencies with a new config (only when not running).

**Notes:** The admin server is intentionally separated from the public listener. It should be bound to loopback or protected by `admin.token` and allowlists.


## Imports

### `import` block 1

```go title="pkg/gateway/runtime/runtime.go#L6" showLineNumbers
import (
	"context"
	"crypto/tls"
	"crypto/x509"
	"encoding/json"
	"errors"
	"fmt"
	"net"
	"net/http"
	"net/url"
	"os"
	"strings"
	"sync"
	"time"

	"github.com/theroutercompany/api_router/internal/platform/health"
	gatewayconfig "github.com/theroutercompany/api_router/pkg/gateway/config"
	gatewaymetrics "github.com/theroutercompany/api_router/pkg/gateway/metrics"
	gatewayserver "github.com/theroutercompany/api_router/pkg/gateway/server"
	pkglog "github.com/theroutercompany/api_router/pkg/log"
)
```


## Variables

### `var` block 1

```go title="pkg/gateway/runtime/runtime.go#L28" showLineNumbers
var (
	// ErrAlreadyRunning indicates the runtime is already serving requests.
	ErrAlreadyRunning = errors.New("runtime already running")
	// ErrNotRunning indicates the runtime has not been started yet.
	ErrNotRunning = errors.New("runtime not running")
	// ErrReloadWhileRunning is returned when attempting to reload while serving.
	ErrReloadWhileRunning = errors.New("cannot reload runtime while it is running")
)
```

#### `ErrAlreadyRunning`

**What:** Sentinel error returned when `Start()` is called while the runtime is already running.

**Why:** Prevents multiple goroutines from attempting to start/own the same server lifecycle.

**How:** Returned when `Runtime.errCh` is non-nil inside `Start()`.

#### `ErrNotRunning`

**What:** Sentinel error returned when `Wait()` is called before the runtime has started.

**Why:** Makes lifecycle misuse explicit instead of blocking forever or panicking.

**How:** Returned when `Runtime.errCh` is nil inside `Wait()`.

#### `ErrReloadWhileRunning`

**What:** Sentinel error returned when `Reload()` is called while the runtime is running.

**Why:** Hot-swapping server dependencies during active serving is unsafe; reload is only supported while stopped.

**How:** Returned when `Runtime.errCh` is non-nil inside `Reload()`.


## Types

### `type` block 1

```go title="pkg/gateway/runtime/runtime.go#L38" showLineNumbers
type Runtime struct {
	mu sync.Mutex

	cfg        gatewayconfig.Config
	server     *gatewayserver.Server
	checker    *health.Checker
	registry   *gatewaymetrics.Registry
	reloadFn   func() (gatewayconfig.Config, error)
	adminAllow []*net.IPNet
	bootTime   time.Time
	logger     pkglog.Logger

	baseCtx    context.Context
	cancel     context.CancelFunc
	errCh      chan error
	adminSrv   *http.Server
	adminErrCh chan error
	adminAddr  string
}
```

#### `Runtime`

**What:** The primary lifecycle object that owns the server, readiness checker, metrics registry, and admin server.

**Why:** Encapsulates concurrency, context cancellation, and shared state so entrypoints don't reimplement lifecycle wiring.

**How:** Uses a mutex to guard state transitions and stores channels/cancel funcs for start/wait/shutdown coordination.

### `type` block 2

```go title="pkg/gateway/runtime/runtime.go#L59" showLineNumbers
type Option func(*Runtime)
```

#### `Option`

**What:** Functional option type for configuring `Runtime` construction.

**Why:** Keeps the `New()` signature stable while allowing opt-in behaviors (logger injection, reload callback).

**How:** Options mutate fields on the `Runtime` during `New()`.

### `type` block 3

```go title="pkg/gateway/runtime/runtime.go#L315" showLineNumbers
type upstreamTransport struct {
	defaultTransport *http.Transport
	transports       map[string]*http.Transport
}
```

#### `upstreamTransport`

**What:** A custom `http.RoundTripper` that routes requests to host-specific `*http.Transport` instances.

**Why:** Per-upstream TLS settings require per-host transport configuration; a single transport cannot represent multiple TLS configs safely.

**How:** Implements `RoundTrip` and `CloseIdleConnections` and holds a default transport plus a host-to-transport map.


## Functions and Methods

### `WithReloadFunc`

**What:** Runtime option that registers a callback invoked by the admin server on reload requests.

**Why:** The runtime itself does not know how to re-read config (file watching, env layering, etc.); the caller provides that policy.

**How:** Sets `Runtime.reloadFn`, which is called by the `POST /__admin/reload` handler.

```go title="pkg/gateway/runtime/runtime.go#L62" showLineNumbers
func WithReloadFunc(fn func() (gatewayconfig.Config, error)) Option {
	return func(r *Runtime) {
		r.reloadFn = fn
	}
}
```

### `WithLogger`

**What:** Runtime option that overrides the logger used by the runtime and underlying server.

**Why:** Allows CLIs/services to inject their own structured logger configuration.

**How:** Sets `Runtime.logger` when the provided logger is non-nil.

```go title="pkg/gateway/runtime/runtime.go#L69" showLineNumbers
func WithLogger(logger pkglog.Logger) Option {
	return func(r *Runtime) {
		if logger != nil {
			r.logger = logger
		}
	}
}
```

### `New`

**What:** Constructs a `Runtime` from an already-loaded `gatewayconfig.Config`.

**Why:** Separates config loading from runtime composition so callers can control where config comes from (CLI, tests, embedding).

**How:** Initializes logger/boot time/admin allowlist, applies `Option`s, then calls `buildComponents` to create the server/checker/metrics registry.

```go title="pkg/gateway/runtime/runtime.go#L78" showLineNumbers
func New(cfg gatewayconfig.Config, opts ...Option) (*Runtime, error) {
	rt := &Runtime{
		cfg:        cfg,
		adminAllow: parseAllowList(cfg.Admin.Allow),
		bootTime:   time.Now(),
		logger:     pkglog.Shared(),
	}

	for _, opt := range opts {
		if opt != nil {
			opt(rt)
		}
	}

	if rt.logger == nil {
		rt.logger = pkglog.Shared()
	}

	comps, err := buildComponents(cfg, rt.logger)
	if err != nil {
		return nil, err
	}

	rt.server = comps.server
	rt.checker = comps.checker
	rt.registry = comps.registry

	return rt, nil
}
```

### `(*Runtime).Start`

**What:** Starts serving the public gateway server (and optionally the admin server) in the background.

**Why:** Separates "start" from "wait" to support daemons and embedding where the caller controls the main loop.

**How:** Creates a derived context, starts `gatewayserver.Server.Start` in a goroutine, and conditionally starts the admin server based on config.

```go title="pkg/gateway/runtime/runtime.go#L109" showLineNumbers
func (r *Runtime) Start(ctx context.Context) error {
	r.mu.Lock()
	defer r.mu.Unlock()

	if r.errCh != nil {
		return ErrAlreadyRunning
	}

	if ctx == nil {
		ctx = context.Background()
	}

	runCtx, cancel := context.WithCancel(ctx)
	r.baseCtx = runCtx
	r.cancel = cancel
	r.errCh = make(chan error, 1)

	go func() {
		err := r.server.Start(runCtx)
		r.errCh <- err
		close(r.errCh)
	}()

	if r.cfg.Admin.Enabled {
		if err := r.startAdminServer(runCtx); err != nil {
			r.logger.Errorw("admin server failed to start", "error", err, "listen", r.cfg.Admin.Listen)
		}
	} else {
		r.adminAddr = ""
	}

	return nil
}
```

### `(*Runtime).Wait`

**What:** Blocks until the runtime stops and returns the terminal error.

**Why:** Provides a single place to normalize shutdown behavior and clean up internal state.

**How:** Waits for either server or admin errors, treats `context.Canceled` as nil, and resets internal fields (channels, cancel func, admin server state).

```go title="pkg/gateway/runtime/runtime.go#L144" showLineNumbers
func (r *Runtime) Wait() error {
	r.mu.Lock()
	errCh := r.errCh
	adminErrCh := r.adminErrCh
	r.mu.Unlock()

	if errCh == nil {
		return ErrNotRunning
	}

	var err error
	select {
	case err = <-errCh:
	case adminErr := <-adminErrCh:
		if adminErr != nil && !errors.Is(adminErr, http.ErrServerClosed) {
			r.logger.Errorw("admin server stopped with error", "error", adminErr)
		}
		err = <-errCh
	}

	if errors.Is(err, context.Canceled) {
		err = nil
	}

	r.mu.Lock()
	r.errCh = nil
	if r.cancel != nil {
		r.cancel()
		r.cancel = nil
	}
	if r.adminSrv != nil {
		_ = r.adminSrv.Shutdown(context.Background())
	}
	r.adminSrv = nil
	r.adminErrCh = nil
	r.mu.Unlock()

	return err
}
```

### `(*Runtime).Run`

**What:** Convenience method that calls `Start(ctx)` then `Wait()`.

**Why:** Common CLI pattern; keeps call sites simple.

**How:** Delegates to `Start` and then blocks on `Wait`.

```go title="pkg/gateway/runtime/runtime.go#L185" showLineNumbers
func (r *Runtime) Run(ctx context.Context) error {
	if err := r.Start(ctx); err != nil {
		return err
	}
	return r.Wait()
}
```

### `(*Runtime).Shutdown`

**What:** Requests graceful shutdown of the runtime when running.

**Why:** Provides a structured shutdown path for CLIs, daemons, and embedding (tests/servers).

**How:** Cancels the base context, shuts down the admin server (if present), then calls the underlying server's `Shutdown(ctx)`.

```go title="pkg/gateway/runtime/runtime.go#L193" showLineNumbers
func (r *Runtime) Shutdown(ctx context.Context) error {
	r.mu.Lock()
	defer r.mu.Unlock()

	if r.server == nil || r.errCh == nil {
		return nil
	}
	if ctx == nil {
		ctx = context.Background()
	}

	if r.cancel != nil {
		r.cancel()
	}

	if r.adminSrv != nil {
		_ = r.adminSrv.Shutdown(ctx)
		r.adminSrv = nil
		r.adminErrCh = nil
	}

	return r.server.Shutdown(ctx)
}
```

### `(*Runtime).Reload`

**What:** Rebuilds runtime dependencies using a new configuration while the runtime is not running.

**Why:** Replacing server/checker/metrics while serving traffic is unsafe; reload is a controlled, stop-the-world operation.

**How:** Refuses when running (`ErrReloadWhileRunning`), calls `buildComponents`, then swaps `cfg/server/checker/registry` and recomputes the admin allowlist.

```go title="pkg/gateway/runtime/runtime.go#L218" showLineNumbers
func (r *Runtime) Reload(cfg gatewayconfig.Config) error {
	r.mu.Lock()
	defer r.mu.Unlock()

	if r.errCh != nil {
		return ErrReloadWhileRunning
	}

	comps, err := buildComponents(cfg, r.logger)
	if err != nil {
		return err
	}

	r.cfg = cfg
	r.server = comps.server
	r.checker = comps.checker
	r.registry = comps.registry
	r.adminAllow = parseAllowList(cfg.Admin.Allow)

	return nil
}
```

### `(*Runtime).Config`

**What:** Returns the runtime's current configuration snapshot.

**Why:** Allows admin/status handlers and callers to report current settings without exposing internal mutation.

**How:** Returns a copy of `Runtime.cfg` under the runtime mutex.

```go title="pkg/gateway/runtime/runtime.go#L241" showLineNumbers
func (r *Runtime) Config() gatewayconfig.Config {
	r.mu.Lock()
	defer r.mu.Unlock()
	return r.cfg
}
```

### `buildComponents`

**What:** Internal helper that builds the server, readiness checker, and metrics registry from config.

**Why:** Keeps `New()` and `Reload()` small while centralizing dependency construction and invariants.

**How:** Builds a readiness `http.Client` (with per-upstream TLS transports), creates a `health.Checker`, optionally creates a metrics registry, then constructs `gatewayserver.Server`.

```go title="pkg/gateway/runtime/runtime.go#L247" showLineNumbers
func buildComponents(cfg gatewayconfig.Config, logger pkglog.Logger) (struct {
	server   *gatewayserver.Server
	checker  *health.Checker
	registry *gatewaymetrics.Registry
}, error,
) {
	readinessTimeout := cfg.Readiness.Timeout.AsDuration()
	defaultTransport := defaultHTTPTransport()
	hostTransports := make(map[string]*http.Transport)

	upstreams := make([]health.Upstream, len(cfg.Readiness.Upstreams))
	for i, upstreamCfg := range cfg.Readiness.Upstreams {
		host, err := hostFromURL(upstreamCfg.BaseURL)
		if err != nil {
			return struct {
				server   *gatewayserver.Server
				checker  *health.Checker
				registry *gatewaymetrics.Registry
			}{}, fmt.Errorf("parse upstream %s base url: %w", upstreamCfg.Name, err)
		}
		if upstreamCfg.TLS.Enabled {
			tlsCfg, err := buildReadinessTLSConfig(upstreamCfg.TLS)
			if err != nil {
				return struct {
					server   *gatewayserver.Server
					checker  *health.Checker
					registry *gatewaymetrics.Registry
				}{}, fmt.Errorf("build readiness tls config for %s: %w", upstreamCfg.Name, err)
			}
			tr := defaultHTTPTransport()
			tr.TLSClientConfig = tlsCfg
			hostTransports[host] = tr
		}

		upstreams[i] = health.Upstream{
			Name:       upstreamCfg.Name,
			BaseURL:    upstreamCfg.BaseURL,
			HealthPath: upstreamCfg.HealthPath,
		}
	}

	httpClient := &http.Client{
		Timeout: readinessTimeout,
		Transport: &upstreamTransport{
			defaultTransport: defaultTransport,
			transports:       hostTransports,
		},
	}

	checker := health.NewChecker(httpClient, upstreams, readinessTimeout, cfg.Readiness.UserAgent)

	var registry *gatewaymetrics.Registry
	if cfg.Metrics.Enabled {
		registry = gatewaymetrics.NewRegistry()
	}

	if logger == nil {
		logger = pkglog.Shared()
	}

	srv := gatewayserver.New(cfg, checker, registry, gatewayserver.WithLogger(logger))
	return struct {
		server   *gatewayserver.Server
		checker  *health.Checker
		registry *gatewaymetrics.Registry
	}{server: srv, checker: checker, registry: registry}, nil
}
```

### `(*upstreamTransport).RoundTrip`

**What:** Selects a per-host transport (when configured) for an outgoing readiness HTTP request.

**Why:** Allows readiness checks to use custom TLS settings per upstream host while keeping a shared default for others.

**How:** If the request host matches `transports[host]`, delegates to that transport; otherwise uses `defaultTransport`.

```go title="pkg/gateway/runtime/runtime.go#L320" showLineNumbers
func (t *upstreamTransport) RoundTrip(req *http.Request) (*http.Response, error) {
	if req == nil || req.URL == nil {
		return t.defaultTransport.RoundTrip(req)
	}
	if transport, ok := t.transports[req.URL.Host]; ok {
		return transport.RoundTrip(req)
	}
	return t.defaultTransport.RoundTrip(req)
}
```

### `(*upstreamTransport).CloseIdleConnections`

**What:** Closes idle connections for the default transport and all per-host transports.

**Why:** Prevents leaked keep-alives when swapping/reloading readiness transports.

**How:** Calls `CloseIdleConnections` on the default transport and iterates through the map.

```go title="pkg/gateway/runtime/runtime.go#L330" showLineNumbers
func (t *upstreamTransport) CloseIdleConnections() {
	if t.defaultTransport != nil {
		t.defaultTransport.CloseIdleConnections()
	}
	for _, transport := range t.transports {
		transport.CloseIdleConnections()
	}
}
```

### `defaultHTTPTransport`

**What:** Returns a clone of `http.DefaultTransport` when possible, otherwise a new `http.Transport`.

**Why:** Cloning preserves sane defaults (proxy, keep-alives, dialer settings) while allowing per-upstream TLS customization without mutating global state.

**How:** Type-asserts `http.DefaultTransport` to `*http.Transport` and calls `Clone()`.

```go title="pkg/gateway/runtime/runtime.go#L339" showLineNumbers
func defaultHTTPTransport() *http.Transport {
	if base, ok := http.DefaultTransport.(*http.Transport); ok && base != nil {
		return base.Clone()
	}
	return &http.Transport{}
}
```

### `buildReadinessTLSConfig`

**What:** Builds a `tls.Config` for readiness probing based on `gatewayconfig.TLSConfig`.

**Why:** Readiness probes may need custom CA bundles or client certificates (mTLS) depending on upstream requirements.

**How:** Sets safe defaults (TLS 1.2+, h2/http1.1), optionally loads a CA bundle, optionally loads a client certificate/key pair, and returns an error for partial mTLS config.

```go title="pkg/gateway/runtime/runtime.go#L346" showLineNumbers
func buildReadinessTLSConfig(cfg gatewayconfig.TLSConfig) (*tls.Config, error) {
	tlsCfg := &tls.Config{
		MinVersion:         tls.VersionTLS12,
		InsecureSkipVerify: cfg.InsecureSkipVerify,
		NextProtos:         []string{"h2", "http/1.1"},
	}

	if cfg.CAFile != "" {
		data, err := os.ReadFile(cfg.CAFile)
		if err != nil {
			return nil, fmt.Errorf("read ca file %q: %w", cfg.CAFile, err)
		}
		pool := x509.NewCertPool()
		if !pool.AppendCertsFromPEM(data) {
			return nil, fmt.Errorf("parse ca bundle %q", cfg.CAFile)
		}
		tlsCfg.RootCAs = pool
	}

	if cfg.ClientCertFile != "" || cfg.ClientKeyFile != "" {
		if cfg.ClientCertFile == "" || cfg.ClientKeyFile == "" {
			return nil, errors.New("client certificate and key must both be provided")
		}
		cert, err := tls.LoadX509KeyPair(cfg.ClientCertFile, cfg.ClientKeyFile)
		if err != nil {
			return nil, fmt.Errorf("load client key pair: %w", err)
		}
		tlsCfg.Certificates = []tls.Certificate{cert}
	}

	return tlsCfg, nil
}
```

### `hostFromURL`

**What:** Extracts the `Host` portion from a base URL string.

**Why:** Readiness uses host-specific transports for TLS settings; the host is the stable key for transport selection.

**How:** Parses the URL and returns `parsed.Host`, returning an error for empty/invalid URLs.

```go title="pkg/gateway/runtime/runtime.go#L379" showLineNumbers
func hostFromURL(raw string) (string, error) {
	if strings.TrimSpace(raw) == "" {
		return "", fmt.Errorf("empty url")
	}
	parsed, err := url.Parse(raw)
	if err != nil {
		return "", err
	}
	if parsed.Host == "" {
		return "", fmt.Errorf("url %q missing host", raw)
	}
	return parsed.Host, nil
}
```

### `parseAllowList`

**What:** Parses `admin.allow` entries into CIDRs (`*net.IPNet`) for IP-based admin authorization.

**Why:** When no admin token is configured, access is restricted to loopback or explicitly allowed networks.

**How:** Accepts CIDR strings (via `net.ParseCIDR`) and single IPs (converted to /32 or /128).

```go title="pkg/gateway/runtime/runtime.go#L393" showLineNumbers
func parseAllowList(entries []string) []*net.IPNet {
	if len(entries) == 0 {
		return nil
	}
	allow := make([]*net.IPNet, 0, len(entries))
	for _, entry := range entries {
		e := strings.TrimSpace(entry)
		if e == "" {
			continue
		}
		if strings.Contains(e, "/") {
			if _, network, err := net.ParseCIDR(e); err == nil {
				allow = append(allow, network)
			}
			continue
		}
		if ip := net.ParseIP(e); ip != nil {
			mask := net.CIDRMask(len(ip)*8, len(ip)*8)
			allow = append(allow, &net.IPNet{IP: ip, Mask: mask})
		}
	}
	return allow
}
```

### `(*Runtime).startAdminServer`

**What:** Starts the admin HTTP server on `cfg.Admin.Listen`.

**Why:** Keeps control-plane endpoints separate and optionally enabled.

**How:** Listens on TCP, registers status/config/reload handlers under `/_ _admin/*`, runs `http.Server.Serve` in a goroutine, and shuts down on context cancellation.

```go title="pkg/gateway/runtime/runtime.go#L417" showLineNumbers
func (r *Runtime) startAdminServer(ctx context.Context) error {
	ln, err := net.Listen("tcp", r.cfg.Admin.Listen)
	if err != nil {
		return err
	}

	r.adminAddr = ln.Addr().String()
	mux := http.NewServeMux()
	mux.HandleFunc("/__admin/status", r.adminAuth(r.handleAdminStatus))
	mux.HandleFunc("/__admin/config", r.adminAuth(r.handleAdminConfig))
	mux.HandleFunc("/__admin/reload", r.adminAuth(r.handleAdminReload))

	srv := &http.Server{Handler: mux}
	r.adminSrv = srv
	r.adminErrCh = make(chan error, 1)

	go func() {
		if err := srv.Serve(ln); err != nil && !errors.Is(err, http.ErrServerClosed) {
			r.adminErrCh <- err
		}
		close(r.adminErrCh)
	}()

	go func() {
		<-ctx.Done()
		shutdownCtx, cancel := context.WithTimeout(context.Background(), r.cfg.HTTP.ShutdownTimeout.AsDuration())
		defer cancel()
		_ = srv.Shutdown(shutdownCtx)
	}()

	return nil
}
```

### `(*Runtime).adminAuth`

**What:** Wraps an admin handler with authorization checks.

**Why:** Keeps the three admin endpoints consistent and avoids repetitive auth boilerplate.

**How:** Calls `authorizeAdmin` and invokes the handler only if authorized.

```go title="pkg/gateway/runtime/runtime.go#L450" showLineNumbers
func (r *Runtime) adminAuth(handler func(http.ResponseWriter, *http.Request)) http.HandlerFunc {
	return func(w http.ResponseWriter, req *http.Request) {
		if !r.authorizeAdmin(w, req) {
			return
		}
		handler(w, req)
	}
}
```

### `(*Runtime).authorizeAdmin`

**What:** Implements admin authorization based on either bearer token or IP allowlist.

**Why:** Admin endpoints can mutate/report runtime state and must be protected.

**How:** If `admin.token` is set, requires an Authorization header with a Bearer token matching the configured token; otherwise allows loopback or entries in `admin.allow`.

```go title="pkg/gateway/runtime/runtime.go#L459" showLineNumbers
func (r *Runtime) authorizeAdmin(w http.ResponseWriter, req *http.Request) bool {
	token := strings.TrimSpace(r.cfg.Admin.Token)
	if token != "" {
		authz := req.Header.Get("Authorization")
		if !strings.HasPrefix(authz, "Bearer ") || strings.TrimSpace(authz[7:]) != token {
			http.Error(w, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)
			return false
		}
		return true
	}

	host, _, err := net.SplitHostPort(req.RemoteAddr)
	if err != nil {
		http.Error(w, http.StatusText(http.StatusForbidden), http.StatusForbidden)
		return false
	}
	ip := net.ParseIP(host)
	if ip == nil {
		http.Error(w, http.StatusText(http.StatusForbidden), http.StatusForbidden)
		return false
	}
	if ip.IsLoopback() {
		return true
	}
	for _, network := range r.adminAllow {
		if network.Contains(ip) {
			return true
		}
	}
	http.Error(w, http.StatusText(http.StatusForbidden), http.StatusForbidden)
	return false
}
```

### `(*Runtime).handleAdminStatus`

**What:** Admin handler that returns runtime status as JSON.

**Why:** Provides a minimal control-plane "am I alive/what version/what admin address" endpoint.

**How:** Reports PID, uptime seconds, build version, and admin listen information.

```go title="pkg/gateway/runtime/runtime.go#L492" showLineNumbers
func (r *Runtime) handleAdminStatus(w http.ResponseWriter, _ *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	r.mu.Lock()
	response := map[string]any{
		"pid":           os.Getpid(),
		"uptimeSeconds": time.Since(r.bootTime).Seconds(),
		"version":       r.cfg.Version,
		"admin": map[string]any{
			"enabled": r.cfg.Admin.Enabled,
			"listen":  r.adminAddr,
		},
	}
	r.mu.Unlock()
	_ = json.NewEncoder(w).Encode(response)
}
```

### `(*Runtime).handleAdminConfig`

**What:** Admin handler that returns the current config as JSON with secrets redacted.

**Why:** Enables debugging the running configuration without leaking secrets.

**How:** Copies the config, clears `auth.secret` and `admin.token`, and JSON-encodes the result.

```go title="pkg/gateway/runtime/runtime.go#L508" showLineNumbers
func (r *Runtime) handleAdminConfig(w http.ResponseWriter, _ *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	cfg := r.Config()
	cfg.Auth.Secret = ""
	cfg.Admin.Token = ""
	_ = json.NewEncoder(w).Encode(cfg)
}
```

### `(*Runtime).handleAdminReload`

**What:** Admin handler that requests a reload via the caller-provided reload callback.

**Why:** The runtime doesn't know how to reload configuration sources; this endpoint triggers the caller's policy (watcher, SIGHUP, etc.).

**How:** Requires POST, ensures `reloadFn` exists, invokes it, and returns a JSON "accepted" response or an error.

```go title="pkg/gateway/runtime/runtime.go#L516" showLineNumbers
func (r *Runtime) handleAdminReload(w http.ResponseWriter, req *http.Request) {
	if req.Method != http.MethodPost {
		http.Error(w, http.StatusText(http.StatusMethodNotAllowed), http.StatusMethodNotAllowed)
		return
	}
	if r.reloadFn == nil {
		http.Error(w, "runtime reload callback not configured", http.StatusServiceUnavailable)
		return
	}
	if _, err := r.reloadFn(); err != nil {
		http.Error(w, fmt.Sprintf("reload failed: %v", err), http.StatusInternalServerError)
		return
	}
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusAccepted)
	_ = json.NewEncoder(w).Encode(map[string]any{"status": "reload requested"})
}
```

### `(*Runtime).AdminAddr`

**What:** Returns the bound admin server address (host:port) when enabled.

**Why:** Helpful when the admin listener is configured with an ephemeral port or needs to be surfaced to callers/tests.

**How:** Returns `Runtime.adminAddr` guarded by the runtime mutex.

```go title="pkg/gateway/runtime/runtime.go#L535" showLineNumbers
func (r *Runtime) AdminAddr() string {
	r.mu.Lock()
	defer r.mu.Unlock()
	return r.adminAddr
}
```

