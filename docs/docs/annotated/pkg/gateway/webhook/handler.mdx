---
title: "pkg/gateway/webhook/handler.go"
---

<!--
Generated by `go run ./cmd/docsgen`.
Do not edit this file directly.
Edit commentary in `docs/annotations/pkg/gateway/webhook/handler.yaml`.
-->

## Source

- Package: `webhook`
- File: `pkg/gateway/webhook/handler.go`
- GitHub: https://github.com/theroutercompany/api_router/blob/main/pkg/gateway/webhook/handler.go

## Overview

**What:** Implements webhook ingestion handlers that validate HMAC signatures and forward payloads to a configured target with retries and backoff.

**Why:** Webhooks provide an event-driven integration mechanism. The gateway needs a secure ingress that can verify authenticity and provide controlled forwarding behavior.

**How:** The `New()` constructor validates options and builds a handler. `ServeHTTP` reads and bounds the request body, verifies the signature, then forwards the payload to the target with retry/backoff rules.

**Notes:** Webhook secrets should be injected via secret managers. Consider idempotency on the target side because retries may deliver duplicates.


## Imports

### `import` block 1

```go title="pkg/gateway/webhook/handler.go#L3" showLineNumbers
import (
	"bytes"
	"context"
	"crypto/hmac"
	"crypto/sha256"
	"encoding/hex"
	"errors"
	"fmt"
	"io"
	"net/http"
	"strings"
	"time"

	pkglog "github.com/theroutercompany/api_router/pkg/log"
)
```


## Constants

### `const` block 1

```go title="pkg/gateway/webhook/handler.go#L19" showLineNumbers
const (
	defaultMaxBodyBytes int64 = 1 << 20 // 1 MiB
)
```

#### `defaultMaxBodyBytes`

**What:** Default maximum request body size (1 MiB) for webhook payloads.

**Why:** Prevents large payloads from exhausting memory and creating unbounded forwarding work.

**How:** Used when `Options.MaxBodyBytes` is unset or invalid.


## Variables

### `var` block 1

```go title="pkg/gateway/webhook/handler.go#L252" showLineNumbers
var errUpstreamRetryable = errors.New("retryable upstream failure")
```

#### `errUpstreamRetryable`

**What:** Sentinel error used to mark failures that should be retried.

**Why:** Allows retry logic to distinguish between retryable and non-retryable errors using `errors.Is`.

**How:** Wrapped with `%w` by `forwardOnce` for network errors and non-4xx status codes.


## Types

### `type` block 1

```go title="pkg/gateway/webhook/handler.go#L24" showLineNumbers
type Options struct {
	Name            string
	Path            string
	TargetURL       string
	Secret          string
	SignatureHeader string
	MaxAttempts     int
	InitialBackoff  time.Duration
	Timeout         time.Duration
	Client          *http.Client
	Logger          pkglog.Logger
	MaxBodyBytes    int64
}
```

#### `Options`

**What:** Configuration for the webhook handler (target, secret, signature header, retry/backoff/timeouts, client/logger, body size).

**Why:** Makes webhook handler behavior explicit and configurable from server/config packages.

**How:** Passed to `New()` and converted into a private `webhookHandler`.

### `type` block 2

```go title="pkg/gateway/webhook/handler.go#L86" showLineNumbers
type webhookHandler struct {
	name            string
	targetURL       string
	secret          []byte
	signatureHeader string
	maxAttempts     int
	initialBackoff  time.Duration
	timeout         time.Duration
	client          *http.Client
	logger          pkglog.Logger
	maxBodyBytes    int64
}
```

#### `webhookHandler`

**What:** Internal handler implementation that holds immutable webhook configuration.

**Why:** Keeps the public API small while allowing server/config to construct many handlers with different settings.

**How:** Stores secret bytes, target URL, retry parameters, client, logger, and body limits used by `ServeHTTP` and forwarding helpers.

### `type` block 3

```go title="pkg/gateway/webhook/handler.go#L254" showLineNumbers
type errBodyTooLarge struct {
	size  int64
	limit int64
}
```

#### `errBodyTooLarge`

**What:** Error type returned when the request body exceeds the configured size limit.

**Why:** Allows `ServeHTTP` to detect oversize payloads and map them to 413 responses.

**How:** Returned by `readRequestBody` when more than `maxBytes` are read.


## Functions and Methods

### `New`

**What:** Constructs a webhook `http.Handler` with signature verification and forwarding settings.

**Why:** Validates required inputs and provides safe defaults for client, logger, and body size limits.

**How:** Checks required options (secret, target URL, signature header, retry/backoff/timeouts), sets defaults for optional fields, and returns a configured `webhookHandler`.

```go title="pkg/gateway/webhook/handler.go#L39" showLineNumbers
func New(opts Options) (http.Handler, error) {
	if strings.TrimSpace(opts.Secret) == "" {
		return nil, errors.New("webhook secret required")
	}
	if strings.TrimSpace(opts.TargetURL) == "" {
		return nil, errors.New("webhook targetURL required")
	}
	if strings.TrimSpace(opts.SignatureHeader) == "" {
		return nil, errors.New("webhook signature header required")
	}
	if opts.MaxAttempts <= 0 {
		return nil, errors.New("webhook maxAttempts must be positive")
	}
	if opts.InitialBackoff <= 0 {
		return nil, errors.New("webhook initial backoff must be positive")
	}
	if opts.Timeout <= 0 {
		return nil, errors.New("webhook timeout must be positive")
	}
	if opts.Client == nil {
		opts.Client = &http.Client{
			Timeout: opts.Timeout,
		}
	}
	if opts.Logger == nil {
		opts.Logger = pkglog.Shared()
	}
	if opts.MaxBodyBytes <= 0 {
		opts.MaxBodyBytes = defaultMaxBodyBytes
	}

	handler := &webhookHandler{
		name:            opts.Name,
		targetURL:       opts.TargetURL,
		secret:          []byte(opts.Secret),
		signatureHeader: opts.SignatureHeader,
		maxAttempts:     opts.MaxAttempts,
		initialBackoff:  opts.InitialBackoff,
		timeout:         opts.Timeout,
		client:          opts.Client,
		logger:          opts.Logger,
		maxBodyBytes:    opts.MaxBodyBytes,
	}

	return handler, nil
}
```

### `(*webhookHandler).ServeHTTP`

**What:** Main HTTP handler for webhook ingestion.

**Why:** Orchestrates the end-to-end flow of method validation, body read, signature check, and forwarding.

**How:** Requires POST, reads and bounds the body, verifies signature, forwards with retry/backoff, and returns 202 Accepted on success.

```go title="pkg/gateway/webhook/handler.go#L99" showLineNumbers
func (h *webhookHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		w.Header().Set("Allow", http.MethodPost)
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
		return
	}
	defer r.Body.Close()

	body, err := readRequestBody(r.Body, h.maxBodyBytes)
	if err != nil {
		var tooLarge *errBodyTooLarge
		if errors.As(err, &tooLarge) {
			http.Error(w, "payload too large", http.StatusRequestEntityTooLarge)
			return
		}
		h.logger.Errorw("webhook read body failed", "error", err, "webhook", h.name)
		http.Error(w, "invalid payload", http.StatusBadRequest)
		return
	}

	if err := h.verifySignature(r.Header.Get(h.signatureHeader), body); err != nil {
		h.logger.Warnw("webhook signature verification failed", "error", err, "webhook", h.name)
		http.Error(w, "invalid signature", http.StatusUnauthorized)
		return
	}

	if err := h.forwardWithRetry(r.Context(), r, body); err != nil {
		h.logger.Errorw("webhook delivery failed", "error", err, "webhook", h.name)
		http.Error(w, "upstream unavailable", http.StatusBadGateway)
		return
	}

	w.WriteHeader(http.StatusAccepted)
}
```

### `(*webhookHandler).verifySignature`

**What:** Verifies the incoming webhook signature header against the request body.

**Why:** Prevents unauthenticated callers from injecting arbitrary webhook events.

**How:** Trims the header, strips an optional `sha256=` prefix, hex-decodes the signature, computes the expected HMAC, and compares using `hmac.Equal`.

```go title="pkg/gateway/webhook/handler.go#L134" showLineNumbers
func (h *webhookHandler) verifySignature(sigHeader string, body []byte) error {
	sig := strings.TrimSpace(sigHeader)
	if sig == "" {
		return errors.New("signature header missing")
	}
	if strings.HasPrefix(strings.ToLower(sig), "sha256=") {
		sig = sig[7:]
	}

	expectedMAC := computeHMAC(body, h.secret)
	provided, err := hex.DecodeString(sig)
	if err != nil {
		return fmt.Errorf("invalid signature encoding: %w", err)
	}

	if !hmac.Equal(expectedMAC, provided) {
		return errors.New("signature mismatch")
	}
	return nil
}
```

### `(*webhookHandler).forwardWithRetry`

**What:** Forwards the webhook payload with retry and backoff on retryable failures.

**Why:** Webhook targets can experience transient failures; retries improve delivery reliability.

**How:** Runs up to `maxAttempts`, each with its own timeout context; retries only when errors are wrapped with `errUpstreamRetryable`, sleeping with exponential backoff between attempts.

```go title="pkg/gateway/webhook/handler.go#L155" showLineNumbers
func (h *webhookHandler) forwardWithRetry(parentCtx context.Context, original *http.Request, body []byte) error {
	backoff := h.initialBackoff
	for attempt := 1; attempt <= h.maxAttempts; attempt++ {
		ctx, cancel := context.WithTimeout(parentCtx, h.timeout)
		err := h.forwardOnce(ctx, original, body, attempt)
		cancel()
		if err == nil {
			return nil
		}

		retryable := errors.Is(err, errUpstreamRetryable)
		h.logger.Warnw("webhook delivery attempt failed",
			"webhook", h.name,
			"attempt", attempt,
			"maxAttempts", h.maxAttempts,
			"retryable", retryable,
			"error", err,
		)

		if !retryable || attempt == h.maxAttempts {
			return err
		}

		select {
		case <-time.After(backoff):
			backoff = increaseBackoff(backoff, 4*time.Second)
		case <-parentCtx.Done():
			return parentCtx.Err()
		}
	}
	return errors.New("webhook delivery exhausted retries")
}
```

### `(*webhookHandler).forwardOnce`

**What:** Performs a single forwarding attempt to the configured target.

**Why:** Separates one attempt from retry logic and keeps retry policy centralized.

**How:** Creates a POST request with the same body, copies headers, adds `X-Router-Webhook-*` headers, executes the request, and classifies status codes as success, non-retryable (4xx), or retryable (5xx/network).

```go title="pkg/gateway/webhook/handler.go#L188" showLineNumbers
func (h *webhookHandler) forwardOnce(ctx context.Context, original *http.Request, body []byte, attempt int) error {
	req, err := http.NewRequestWithContext(ctx, http.MethodPost, h.targetURL, bytes.NewReader(body))
	if err != nil {
		return fmt.Errorf("build request: %w", err)
	}

	copyHeaders(original.Header, req.Header)
	req.Header.Set("X-Router-Webhook-Name", h.name)
	req.Header.Set("X-Router-Webhook-Attempt", fmt.Sprintf("%d", attempt))

	resp, err := h.client.Do(req)
	if err != nil {
		return fmt.Errorf("%w: %v", errUpstreamRetryable, err)
	}
	defer resp.Body.Close()
	io.Copy(io.Discard, resp.Body)

	if resp.StatusCode >= 200 && resp.StatusCode < 300 {
		return nil
	}
	if resp.StatusCode >= 400 && resp.StatusCode < 500 {
		return fmt.Errorf("upstream returned status %d", resp.StatusCode)
	}
	return fmt.Errorf("%w: upstream status %d", errUpstreamRetryable, resp.StatusCode)
}
```

### `readRequestBody`

**What:** Reads the request body up to a maximum number of bytes.

**Why:** Webhooks must be bounded in size for safety and predictability.

**How:** Uses `io.LimitReader` to read at most `maxBytes+1`, returning `errBodyTooLarge` when the limit is exceeded.

```go title="pkg/gateway/webhook/handler.go#L214" showLineNumbers
func readRequestBody(body io.Reader, maxBytes int64) ([]byte, error) {
	if maxBytes <= 0 {
		maxBytes = defaultMaxBodyBytes
	}
	limited := io.LimitReader(body, maxBytes+1)
	data, err := io.ReadAll(limited)
	if err != nil {
		return nil, err
	}
	if int64(len(data)) > maxBytes {
		return nil, &errBodyTooLarge{size: int64(len(data)), limit: maxBytes}
	}
	return data, nil
}
```

### `computeHMAC`

**What:** Computes an HMAC-SHA256 digest for a request body using a secret key.

**Why:** HMAC validation is the authenticity mechanism for incoming webhooks.

**How:** Uses `crypto/hmac` with `sha256.New` and returns the raw digest bytes.

```go title="pkg/gateway/webhook/handler.go#L229" showLineNumbers
func computeHMAC(body []byte, secret []byte) []byte {
	mac := hmac.New(sha256.New, secret)
	mac.Write(body)
	return mac.Sum(nil)
}
```

### `copyHeaders`

**What:** Copies HTTP headers from the incoming webhook request to the forwarded request.

**Why:** Some webhook senders include metadata headers that the target may need.

**How:** Adds all header values and deletes `Host` to avoid forcing a host override on the outgoing request.

```go title="pkg/gateway/webhook/handler.go#L235" showLineNumbers
func copyHeaders(src http.Header, dst http.Header) {
	for key, values := range src {
		for _, value := range values {
			dst.Add(key, value)
		}
	}
	dst.Del("Host")
}
```

### `increaseBackoff`

**What:** Computes the next backoff duration for a retry loop with an upper bound.

**Why:** Exponential backoff reduces load on failing upstreams and avoids tight retry loops.

**How:** Doubles the current duration and clamps to the provided max duration.

```go title="pkg/gateway/webhook/handler.go#L244" showLineNumbers
func increaseBackoff(current time.Duration, max time.Duration) time.Duration {
	next := current * 2
	if next > max {
		return max
	}
	return next
}
```

### `(*errBodyTooLarge).Error`

**What:** Formats an error message describing how much the request exceeded the body size limit.

**Why:** Useful for debugging and logging size-related rejections.

**How:** Returns a string with the actual size and configured limit.

```go title="pkg/gateway/webhook/handler.go#L259" showLineNumbers
func (e *errBodyTooLarge) Error() string {
	return fmt.Sprintf("body size %d exceeds limit %d bytes", e.size, e.limit)
}
```

